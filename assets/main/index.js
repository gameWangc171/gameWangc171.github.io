window.__require = function e(t, n, r) {
  function s(o, u) {
    if (!n[o]) {
      if (!t[o]) {
        var b = o.split("/");
        b = b[b.length - 1];
        if (!t[b]) {
          var a = "function" == typeof __require && __require;
          if (!u && a) return a(b, !0);
          if (i) return i(b, !0);
          throw new Error("Cannot find module '" + o + "'");
        }
        o = b;
      }
      var f = n[o] = {
        exports: {}
      };
      t[o][0].call(f.exports, function(e) {
        var n = t[o][1][e];
        return s(n || e);
      }, f, f.exports, e, t, n, r);
    }
    return n[o].exports;
  }
  var i = "function" == typeof __require && __require;
  for (var o = 0; o < r.length; o++) s(r[o]);
  return s;
}({
  1: [ function(require, module, exports) {
    (function(global) {
      (function() {
        var undefined;
        var VERSION = "4.17.21";
        var LARGE_ARRAY_SIZE = 200;
        var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
        var HASH_UNDEFINED = "__lodash_hash_undefined__";
        var MAX_MEMOIZE_SIZE = 500;
        var PLACEHOLDER = "__lodash_placeholder__";
        var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
        var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
        var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
        var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
        var HOT_COUNT = 800, HOT_SPAN = 16;
        var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
        var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = NaN;
        var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
        var wrapFlags = [ [ "ary", WRAP_ARY_FLAG ], [ "bind", WRAP_BIND_FLAG ], [ "bindKey", WRAP_BIND_KEY_FLAG ], [ "curry", WRAP_CURRY_FLAG ], [ "curryRight", WRAP_CURRY_RIGHT_FLAG ], [ "flip", WRAP_FLIP_FLAG ], [ "partial", WRAP_PARTIAL_FLAG ], [ "partialRight", WRAP_PARTIAL_RIGHT_FLAG ], [ "rearg", WRAP_REARG_FLAG ] ];
        var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
        var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
        var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
        var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
        var reTrimStart = /^\s+/;
        var reWhitespace = /\s/;
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
        var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
        var reEscapeChar = /\\(\\)?/g;
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
        var reFlags = /\w*$/;
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
        var reIsBinary = /^0b[01]+$/i;
        var reIsHostCtor = /^\[object .+?Constructor\]$/;
        var reIsOctal = /^0o[0-7]+$/i;
        var reIsUint = /^(?:0|[1-9]\d*)$/;
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
        var reNoMatch = /($^)/;
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
        var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
        var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
        var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [ rsNonAstral, rsRegional, rsSurrPair ].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [ rsDingbat, rsRegional, rsSurrPair ].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [ rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral ].join("|") + ")";
        var reApos = RegExp(rsApos, "g");
        var reComboMark = RegExp(rsCombo, "g");
        var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
        var reUnicodeWord = RegExp([ rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [ rsBreak, rsUpper, "$" ].join("|") + ")", rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [ rsBreak, rsUpper + rsMiscLower, "$" ].join("|") + ")", rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower, rsUpper + "+" + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji ].join("|"), "g");
        var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
        var contextProps = [ "Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout" ];
        var templateCounter = -1;
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
        var deburredLetters = {
          "\xc0": "A",
          "\xc1": "A",
          "\xc2": "A",
          "\xc3": "A",
          "\xc4": "A",
          "\xc5": "A",
          "\xe0": "a",
          "\xe1": "a",
          "\xe2": "a",
          "\xe3": "a",
          "\xe4": "a",
          "\xe5": "a",
          "\xc7": "C",
          "\xe7": "c",
          "\xd0": "D",
          "\xf0": "d",
          "\xc8": "E",
          "\xc9": "E",
          "\xca": "E",
          "\xcb": "E",
          "\xe8": "e",
          "\xe9": "e",
          "\xea": "e",
          "\xeb": "e",
          "\xcc": "I",
          "\xcd": "I",
          "\xce": "I",
          "\xcf": "I",
          "\xec": "i",
          "\xed": "i",
          "\xee": "i",
          "\xef": "i",
          "\xd1": "N",
          "\xf1": "n",
          "\xd2": "O",
          "\xd3": "O",
          "\xd4": "O",
          "\xd5": "O",
          "\xd6": "O",
          "\xd8": "O",
          "\xf2": "o",
          "\xf3": "o",
          "\xf4": "o",
          "\xf5": "o",
          "\xf6": "o",
          "\xf8": "o",
          "\xd9": "U",
          "\xda": "U",
          "\xdb": "U",
          "\xdc": "U",
          "\xf9": "u",
          "\xfa": "u",
          "\xfb": "u",
          "\xfc": "u",
          "\xdd": "Y",
          "\xfd": "y",
          "\xff": "y",
          "\xc6": "Ae",
          "\xe6": "ae",
          "\xde": "Th",
          "\xfe": "th",
          "\xdf": "ss",
          "\u0100": "A",
          "\u0102": "A",
          "\u0104": "A",
          "\u0101": "a",
          "\u0103": "a",
          "\u0105": "a",
          "\u0106": "C",
          "\u0108": "C",
          "\u010a": "C",
          "\u010c": "C",
          "\u0107": "c",
          "\u0109": "c",
          "\u010b": "c",
          "\u010d": "c",
          "\u010e": "D",
          "\u0110": "D",
          "\u010f": "d",
          "\u0111": "d",
          "\u0112": "E",
          "\u0114": "E",
          "\u0116": "E",
          "\u0118": "E",
          "\u011a": "E",
          "\u0113": "e",
          "\u0115": "e",
          "\u0117": "e",
          "\u0119": "e",
          "\u011b": "e",
          "\u011c": "G",
          "\u011e": "G",
          "\u0120": "G",
          "\u0122": "G",
          "\u011d": "g",
          "\u011f": "g",
          "\u0121": "g",
          "\u0123": "g",
          "\u0124": "H",
          "\u0126": "H",
          "\u0125": "h",
          "\u0127": "h",
          "\u0128": "I",
          "\u012a": "I",
          "\u012c": "I",
          "\u012e": "I",
          "\u0130": "I",
          "\u0129": "i",
          "\u012b": "i",
          "\u012d": "i",
          "\u012f": "i",
          "\u0131": "i",
          "\u0134": "J",
          "\u0135": "j",
          "\u0136": "K",
          "\u0137": "k",
          "\u0138": "k",
          "\u0139": "L",
          "\u013b": "L",
          "\u013d": "L",
          "\u013f": "L",
          "\u0141": "L",
          "\u013a": "l",
          "\u013c": "l",
          "\u013e": "l",
          "\u0140": "l",
          "\u0142": "l",
          "\u0143": "N",
          "\u0145": "N",
          "\u0147": "N",
          "\u014a": "N",
          "\u0144": "n",
          "\u0146": "n",
          "\u0148": "n",
          "\u014b": "n",
          "\u014c": "O",
          "\u014e": "O",
          "\u0150": "O",
          "\u014d": "o",
          "\u014f": "o",
          "\u0151": "o",
          "\u0154": "R",
          "\u0156": "R",
          "\u0158": "R",
          "\u0155": "r",
          "\u0157": "r",
          "\u0159": "r",
          "\u015a": "S",
          "\u015c": "S",
          "\u015e": "S",
          "\u0160": "S",
          "\u015b": "s",
          "\u015d": "s",
          "\u015f": "s",
          "\u0161": "s",
          "\u0162": "T",
          "\u0164": "T",
          "\u0166": "T",
          "\u0163": "t",
          "\u0165": "t",
          "\u0167": "t",
          "\u0168": "U",
          "\u016a": "U",
          "\u016c": "U",
          "\u016e": "U",
          "\u0170": "U",
          "\u0172": "U",
          "\u0169": "u",
          "\u016b": "u",
          "\u016d": "u",
          "\u016f": "u",
          "\u0171": "u",
          "\u0173": "u",
          "\u0174": "W",
          "\u0175": "w",
          "\u0176": "Y",
          "\u0177": "y",
          "\u0178": "Y",
          "\u0179": "Z",
          "\u017b": "Z",
          "\u017d": "Z",
          "\u017a": "z",
          "\u017c": "z",
          "\u017e": "z",
          "\u0132": "IJ",
          "\u0133": "ij",
          "\u0152": "Oe",
          "\u0153": "oe",
          "\u0149": "'n",
          "\u017f": "s"
        };
        var htmlEscapes = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;"
        };
        var htmlUnescapes = {
          "&amp;": "&",
          "&lt;": "<",
          "&gt;": ">",
          "&quot;": '"',
          "&#39;": "'"
        };
        var stringEscapes = {
          "\\": "\\",
          "'": "'",
          "\n": "n",
          "\r": "r",
          "\u2028": "u2028",
          "\u2029": "u2029"
        };
        var freeParseFloat = parseFloat, freeParseInt = parseInt;
        var freeGlobal = "object" == typeof global && global && global.Object === Object && global;
        var freeSelf = "object" == typeof self && self && self.Object === Object && self;
        var root = freeGlobal || freeSelf || Function("return this")();
        var freeExports = "object" == typeof exports && exports && !exports.nodeType && exports;
        var freeModule = freeExports && "object" == typeof module && module && !module.nodeType && module;
        var moduleExports = freeModule && freeModule.exports === freeExports;
        var freeProcess = moduleExports && freeGlobal.process;
        var nodeUtil = function() {
          try {
            var types = freeModule && freeModule.require && freeModule.require("util").types;
            if (types) return types;
            return freeProcess && freeProcess.binding && freeProcess.binding("util");
          } catch (e) {}
        }();
        var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
        function apply(func, thisArg, args) {
          switch (args.length) {
           case 0:
            return func.call(thisArg);

           case 1:
            return func.call(thisArg, args[0]);

           case 2:
            return func.call(thisArg, args[0], args[1]);

           case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }
        function arrayAggregator(array, setter, iteratee, accumulator) {
          var index = -1, length = null == array ? 0 : array.length;
          while (++index < length) {
            var value = array[index];
            setter(accumulator, value, iteratee(value), array);
          }
          return accumulator;
        }
        function arrayEach(array, iteratee) {
          var index = -1, length = null == array ? 0 : array.length;
          while (++index < length) if (false === iteratee(array[index], index, array)) break;
          return array;
        }
        function arrayEachRight(array, iteratee) {
          var length = null == array ? 0 : array.length;
          while (length--) if (false === iteratee(array[length], length, array)) break;
          return array;
        }
        function arrayEvery(array, predicate) {
          var index = -1, length = null == array ? 0 : array.length;
          while (++index < length) if (!predicate(array[index], index, array)) return false;
          return true;
        }
        function arrayFilter(array, predicate) {
          var index = -1, length = null == array ? 0 : array.length, resIndex = 0, result = [];
          while (++index < length) {
            var value = array[index];
            predicate(value, index, array) && (result[resIndex++] = value);
          }
          return result;
        }
        function arrayIncludes(array, value) {
          var length = null == array ? 0 : array.length;
          return !!length && baseIndexOf(array, value, 0) > -1;
        }
        function arrayIncludesWith(array, value, comparator) {
          var index = -1, length = null == array ? 0 : array.length;
          while (++index < length) if (comparator(value, array[index])) return true;
          return false;
        }
        function arrayMap(array, iteratee) {
          var index = -1, length = null == array ? 0 : array.length, result = Array(length);
          while (++index < length) result[index] = iteratee(array[index], index, array);
          return result;
        }
        function arrayPush(array, values) {
          var index = -1, length = values.length, offset = array.length;
          while (++index < length) array[offset + index] = values[index];
          return array;
        }
        function arrayReduce(array, iteratee, accumulator, initAccum) {
          var index = -1, length = null == array ? 0 : array.length;
          initAccum && length && (accumulator = array[++index]);
          while (++index < length) accumulator = iteratee(accumulator, array[index], index, array);
          return accumulator;
        }
        function arrayReduceRight(array, iteratee, accumulator, initAccum) {
          var length = null == array ? 0 : array.length;
          initAccum && length && (accumulator = array[--length]);
          while (length--) accumulator = iteratee(accumulator, array[length], length, array);
          return accumulator;
        }
        function arraySome(array, predicate) {
          var index = -1, length = null == array ? 0 : array.length;
          while (++index < length) if (predicate(array[index], index, array)) return true;
          return false;
        }
        var asciiSize = baseProperty("length");
        function asciiToArray(string) {
          return string.split("");
        }
        function asciiWords(string) {
          return string.match(reAsciiWord) || [];
        }
        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function(value, key, collection) {
            if (predicate(value, key, collection)) {
              result = key;
              return false;
            }
          });
          return result;
        }
        function baseFindIndex(array, predicate, fromIndex, fromRight) {
          var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index-- : ++index < length) if (predicate(array[index], index, array)) return index;
          return -1;
        }
        function baseIndexOf(array, value, fromIndex) {
          return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
        }
        function baseIndexOfWith(array, value, fromIndex, comparator) {
          var index = fromIndex - 1, length = array.length;
          while (++index < length) if (comparator(array[index], value)) return index;
          return -1;
        }
        function baseIsNaN(value) {
          return value !== value;
        }
        function baseMean(array, iteratee) {
          var length = null == array ? 0 : array.length;
          return length ? baseSum(array, iteratee) / length : NAN;
        }
        function baseProperty(key) {
          return function(object) {
            return null == object ? undefined : object[key];
          };
        }
        function basePropertyOf(object) {
          return function(key) {
            return null == object ? undefined : object[key];
          };
        }
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function(value, index, collection) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
          });
          return accumulator;
        }
        function baseSortBy(array, comparer) {
          var length = array.length;
          array.sort(comparer);
          while (length--) array[length] = array[length].value;
          return array;
        }
        function baseSum(array, iteratee) {
          var result, index = -1, length = array.length;
          while (++index < length) {
            var current = iteratee(array[index]);
            current !== undefined && (result = result === undefined ? current : result + current);
          }
          return result;
        }
        function baseTimes(n, iteratee) {
          var index = -1, result = Array(n);
          while (++index < n) result[index] = iteratee(index);
          return result;
        }
        function baseToPairs(object, props) {
          return arrayMap(props, function(key) {
            return [ key, object[key] ];
          });
        }
        function baseTrim(string) {
          return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
        }
        function baseUnary(func) {
          return function(value) {
            return func(value);
          };
        }
        function baseValues(object, props) {
          return arrayMap(props, function(key) {
            return object[key];
          });
        }
        function cacheHas(cache, key) {
          return cache.has(key);
        }
        function charsStartIndex(strSymbols, chrSymbols) {
          var index = -1, length = strSymbols.length;
          while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) ;
          return index;
        }
        function charsEndIndex(strSymbols, chrSymbols) {
          var index = strSymbols.length;
          while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) ;
          return index;
        }
        function countHolders(array, placeholder) {
          var length = array.length, result = 0;
          while (length--) array[length] === placeholder && ++result;
          return result;
        }
        var deburrLetter = basePropertyOf(deburredLetters);
        var escapeHtmlChar = basePropertyOf(htmlEscapes);
        function escapeStringChar(chr) {
          return "\\" + stringEscapes[chr];
        }
        function getValue(object, key) {
          return null == object ? undefined : object[key];
        }
        function hasUnicode(string) {
          return reHasUnicode.test(string);
        }
        function hasUnicodeWord(string) {
          return reHasUnicodeWord.test(string);
        }
        function iteratorToArray(iterator) {
          var data, result = [];
          while (!(data = iterator.next()).done) result.push(data.value);
          return result;
        }
        function mapToArray(map) {
          var index = -1, result = Array(map.size);
          map.forEach(function(value, key) {
            result[++index] = [ key, value ];
          });
          return result;
        }
        function overArg(func, transform) {
          return function(arg) {
            return func(transform(arg));
          };
        }
        function replaceHolders(array, placeholder) {
          var index = -1, length = array.length, resIndex = 0, result = [];
          while (++index < length) {
            var value = array[index];
            if (value === placeholder || value === PLACEHOLDER) {
              array[index] = PLACEHOLDER;
              result[resIndex++] = index;
            }
          }
          return result;
        }
        function setToArray(set) {
          var index = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index] = value;
          });
          return result;
        }
        function setToPairs(set) {
          var index = -1, result = Array(set.size);
          set.forEach(function(value) {
            result[++index] = [ value, value ];
          });
          return result;
        }
        function strictIndexOf(array, value, fromIndex) {
          var index = fromIndex - 1, length = array.length;
          while (++index < length) if (array[index] === value) return index;
          return -1;
        }
        function strictLastIndexOf(array, value, fromIndex) {
          var index = fromIndex + 1;
          while (index--) if (array[index] === value) return index;
          return index;
        }
        function stringSize(string) {
          return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
        }
        function stringToArray(string) {
          return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
        }
        function trimmedEndIndex(string) {
          var index = string.length;
          while (index-- && reWhitespace.test(string.charAt(index))) ;
          return index;
        }
        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
        function unicodeSize(string) {
          var result = reUnicode.lastIndex = 0;
          while (reUnicode.test(string)) ++result;
          return result;
        }
        function unicodeToArray(string) {
          return string.match(reUnicode) || [];
        }
        function unicodeWords(string) {
          return string.match(reUnicodeWord) || [];
        }
        var runInContext = function runInContext(context) {
          context = null == context ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
          var Array = context.Array, Date = context.Date, Error = context.Error, Function = context.Function, Math = context.Math, Object = context.Object, RegExp = context.RegExp, String = context.String, TypeError = context.TypeError;
          var arrayProto = Array.prototype, funcProto = Function.prototype, objectProto = Object.prototype;
          var coreJsData = context["__core-js_shared__"];
          var funcToString = funcProto.toString;
          var hasOwnProperty = objectProto.hasOwnProperty;
          var idCounter = 0;
          var maskSrcKey = function() {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
            return uid ? "Symbol(src)_1." + uid : "";
          }();
          var nativeObjectToString = objectProto.toString;
          var objectCtorString = funcToString.call(Object);
          var oldDash = root._;
          var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
          var Buffer = moduleExports ? context.Buffer : undefined, Symbol = context.Symbol, Uint8Array = context.Uint8Array, allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined, getPrototype = overArg(Object.getPrototypeOf, Object), objectCreate = Object.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined, symIterator = Symbol ? Symbol.iterator : undefined, symToStringTag = Symbol ? Symbol.toStringTag : undefined;
          var defineProperty = function() {
            try {
              var func = getNative(Object, "defineProperty");
              func({}, "", {});
              return func;
            } catch (e) {}
          }();
          var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date && Date.now !== root.Date.now && Date.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
          var nativeCeil = Math.ceil, nativeFloor = Math.floor, nativeGetSymbols = Object.getOwnPropertySymbols, nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object.keys, Object), nativeMax = Math.max, nativeMin = Math.min, nativeNow = Date.now, nativeParseInt = context.parseInt, nativeRandom = Math.random, nativeReverse = arrayProto.reverse;
          var DataView = getNative(context, "DataView"), Map = getNative(context, "Map"), Promise = getNative(context, "Promise"), Set = getNative(context, "Set"), WeakMap = getNative(context, "WeakMap"), nativeCreate = getNative(Object, "create");
          var metaMap = WeakMap && new WeakMap();
          var realNames = {};
          var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map), promiseCtorString = toSource(Promise), setCtorString = toSource(Set), weakMapCtorString = toSource(WeakMap);
          var symbolProto = Symbol ? Symbol.prototype : undefined, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined, symbolToString = symbolProto ? symbolProto.toString : undefined;
          function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) return value;
              if (hasOwnProperty.call(value, "__wrapped__")) return wrapperClone(value);
            }
            return new LodashWrapper(value);
          }
          var baseCreate = function() {
            function object() {}
            return function(proto) {
              if (!isObject(proto)) return {};
              if (objectCreate) return objectCreate(proto);
              object.prototype = proto;
              var result = new object();
              object.prototype = undefined;
              return result;
            };
          }();
          function baseLodash() {}
          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined;
          }
          lodash.templateSettings = {
            escape: reEscape,
            evaluate: reEvaluate,
            interpolate: reInterpolate,
            variable: "",
            imports: {
              _: lodash
            }
          };
          lodash.prototype = baseLodash.prototype;
          lodash.prototype.constructor = lodash;
          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;
          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }
          function lazyClone() {
            var result = new LazyWrapper(this.__wrapped__);
            result.__actions__ = copyArray(this.__actions__);
            result.__dir__ = this.__dir__;
            result.__filtered__ = this.__filtered__;
            result.__iteratees__ = copyArray(this.__iteratees__);
            result.__takeCount__ = this.__takeCount__;
            result.__views__ = copyArray(this.__views__);
            return result;
          }
          function lazyReverse() {
            if (this.__filtered__) {
              var result = new LazyWrapper(this);
              result.__dir__ = -1;
              result.__filtered__ = true;
            } else {
              result = this.clone();
              result.__dir__ *= -1;
            }
            return result;
          }
          function lazyValue() {
            var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length && takeCount == length) return baseWrapperValue(array, this.__actions__);
            var result = [];
            outer: while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee = data.iteratee, type = data.type, computed = iteratee(value);
                if (type == LAZY_MAP_FLAG) value = computed; else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) continue outer;
                  break outer;
                }
              }
              result[resIndex++] = value;
            }
            return result;
          }
          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;
          function Hash(entries) {
            var index = -1, length = null == entries ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }
          function hashDelete(key) {
            var result = this.has(key) && delete this.__data__[key];
            this.size -= result ? 1 : 0;
            return result;
          }
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result = data[key];
              return result === HASH_UNDEFINED ? undefined : result;
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined;
          }
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
          }
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
            return this;
          }
          Hash.prototype.clear = hashClear;
          Hash.prototype["delete"] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;
          function ListCache(entries) {
            var index = -1, length = null == entries ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }
          function listCacheDelete(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) return false;
            var lastIndex = data.length - 1;
            index == lastIndex ? data.pop() : splice.call(data, index, 1);
            --this.size;
            return true;
          }
          function listCacheGet(key) {
            var data = this.__data__, index = assocIndexOf(data, key);
            return index < 0 ? undefined : data[index][1];
          }
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }
          function listCacheSet(key, value) {
            var data = this.__data__, index = assocIndexOf(data, key);
            if (index < 0) {
              ++this.size;
              data.push([ key, value ]);
            } else data[index][1] = value;
            return this;
          }
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype["delete"] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;
          function MapCache(entries) {
            var index = -1, length = null == entries ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              hash: new Hash(),
              map: new (Map || ListCache)(),
              string: new Hash()
            };
          }
          function mapCacheDelete(key) {
            var result = getMapData(this, key)["delete"](key);
            this.size -= result ? 1 : 0;
            return result;
          }
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }
          function mapCacheSet(key, value) {
            var data = getMapData(this, key), size = data.size;
            data.set(key, value);
            this.size += data.size == size ? 0 : 1;
            return this;
          }
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype["delete"] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;
          function SetCache(values) {
            var index = -1, length = null == values ? 0 : values.length;
            this.__data__ = new MapCache();
            while (++index < length) this.add(values[index]);
          }
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
          }
          function setCacheHas(value) {
            return this.__data__.has(value);
          }
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;
          function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }
          function stackDelete(key) {
            var data = this.__data__, result = data["delete"](key);
            this.size = data.size;
            return result;
          }
          function stackGet(key) {
            return this.__data__.get(key);
          }
          function stackHas(key) {
            return this.__data__.has(key);
          }
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([ key, value ]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }
          Stack.prototype.clear = stackClear;
          Stack.prototype["delete"] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
            for (var key in value) !inherited && !hasOwnProperty.call(value, key) || skipIndexes && ("length" == key || isBuff && ("offset" == key || "parent" == key) || isType && ("buffer" == key || "byteLength" == key || "byteOffset" == key) || isIndex(key, length)) || result.push(key);
            return result;
          }
          function arraySample(array) {
            var length = array.length;
            return length ? array[baseRandom(0, length - 1)] : undefined;
          }
          function arraySampleSize(array, n) {
            return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
          }
          function arrayShuffle(array) {
            return shuffleSelf(copyArray(array));
          }
          function assignMergeValue(object, key, value) {
            (value === undefined || eq(object[key], value)) && (value !== undefined || key in object) || baseAssignValue(object, key, value);
          }
          function assignValue(object, key, value) {
            var objValue = object[key];
            hasOwnProperty.call(object, key) && eq(objValue, value) && (value !== undefined || key in object) || baseAssignValue(object, key, value);
          }
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) if (eq(array[length][0], key)) return length;
            return -1;
          }
          function baseAggregator(collection, setter, iteratee, accumulator) {
            baseEach(collection, function(value, key, collection) {
              setter(accumulator, value, iteratee(value), collection);
            });
            return accumulator;
          }
          function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
          }
          function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
          }
          function baseAssignValue(object, key, value) {
            "__proto__" == key && defineProperty ? defineProperty(object, key, {
              configurable: true,
              enumerable: true,
              value: value,
              writable: true
            }) : object[key] = value;
          }
          function baseAt(object, paths) {
            var index = -1, length = paths.length, result = Array(length), skip = null == object;
            while (++index < length) result[index] = skip ? undefined : get(object, paths[index]);
            return result;
          }
          function baseClamp(number, lower, upper) {
            if (number === number) {
              upper !== undefined && (number = number <= upper ? number : upper);
              lower !== undefined && (number = number >= lower ? number : lower);
            }
            return number;
          }
          function baseClone(value, bitmask, customizer, key, object, stack) {
            var result, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
            customizer && (result = object ? customizer(value, key, object, stack) : customizer(value));
            if (result !== undefined) return result;
            if (!isObject(value)) return value;
            var isArr = isArray(value);
            if (isArr) {
              result = initCloneArray(value);
              if (!isDeep) return copyArray(value, result);
            } else {
              var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
              if (isBuffer(value)) return cloneBuffer(value, isDeep);
              if (tag == objectTag || tag == argsTag || isFunc && !object) {
                result = isFlat || isFunc ? {} : initCloneObject(value);
                if (!isDeep) return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
              } else {
                if (!cloneableTags[tag]) return object ? value : {};
                result = initCloneByTag(value, tag, isDeep);
              }
            }
            stack || (stack = new Stack());
            var stacked = stack.get(value);
            if (stacked) return stacked;
            stack.set(value, result);
            isSet(value) ? value.forEach(function(subValue) {
              result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            }) : isMap(value) && value.forEach(function(subValue, key) {
              result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
            });
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
            var props = isArr ? undefined : keysFunc(value);
            arrayEach(props || value, function(subValue, key) {
              if (props) {
                key = subValue;
                subValue = value[key];
              }
              assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
            });
            return result;
          }
          function baseConforms(source) {
            var props = keys(source);
            return function(object) {
              return baseConformsTo(object, source, props);
            };
          }
          function baseConformsTo(object, source, props) {
            var length = props.length;
            if (null == object) return !length;
            object = Object(object);
            while (length--) {
              var key = props[length], predicate = source[key], value = object[key];
              if (value === undefined && !(key in object) || !predicate(value)) return false;
            }
            return true;
          }
          function baseDelay(func, wait, args) {
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            return setTimeout(function() {
              func.apply(undefined, args);
            }, wait);
          }
          function baseDifference(array, values, iteratee, comparator) {
            var index = -1, includes = arrayIncludes, isCommon = true, length = array.length, result = [], valuesLength = values.length;
            if (!length) return result;
            iteratee && (values = arrayMap(values, baseUnary(iteratee)));
            if (comparator) {
              includes = arrayIncludesWith;
              isCommon = false;
            } else if (values.length >= LARGE_ARRAY_SIZE) {
              includes = cacheHas;
              isCommon = false;
              values = new SetCache(values);
            }
            outer: while (++index < length) {
              var value = array[index], computed = null == iteratee ? value : iteratee(value);
              value = comparator || 0 !== value ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) if (values[valuesIndex] === computed) continue outer;
                result.push(value);
              } else includes(values, computed, comparator) || result.push(value);
            }
            return result;
          }
          var baseEach = createBaseEach(baseForOwn);
          var baseEachRight = createBaseEach(baseForOwnRight, true);
          function baseEvery(collection, predicate) {
            var result = true;
            baseEach(collection, function(value, index, collection) {
              result = !!predicate(value, index, collection);
              return result;
            });
            return result;
          }
          function baseExtremum(array, iteratee, comparator) {
            var index = -1, length = array.length;
            while (++index < length) {
              var value = array[index], current = iteratee(value);
              if (null != current && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))) var computed = current, result = value;
            }
            return result;
          }
          function baseFill(array, value, start, end) {
            var length = array.length;
            start = toInteger(start);
            start < 0 && (start = -start > length ? 0 : length + start);
            end = end === undefined || end > length ? length : toInteger(end);
            end < 0 && (end += length);
            end = start > end ? 0 : toLength(end);
            while (start < end) array[start++] = value;
            return array;
          }
          function baseFilter(collection, predicate) {
            var result = [];
            baseEach(collection, function(value, index, collection) {
              predicate(value, index, collection) && result.push(value);
            });
            return result;
          }
          function baseFlatten(array, depth, predicate, isStrict, result) {
            var index = -1, length = array.length;
            predicate || (predicate = isFlattenable);
            result || (result = []);
            while (++index < length) {
              var value = array[index];
              depth > 0 && predicate(value) ? depth > 1 ? baseFlatten(value, depth - 1, predicate, isStrict, result) : arrayPush(result, value) : isStrict || (result[result.length] = value);
            }
            return result;
          }
          var baseFor = createBaseFor();
          var baseForRight = createBaseFor(true);
          function baseForOwn(object, iteratee) {
            return object && baseFor(object, iteratee, keys);
          }
          function baseForOwnRight(object, iteratee) {
            return object && baseForRight(object, iteratee, keys);
          }
          function baseFunctions(object, props) {
            return arrayFilter(props, function(key) {
              return isFunction(object[key]);
            });
          }
          function baseGet(object, path) {
            path = castPath(path, object);
            var index = 0, length = path.length;
            while (null != object && index < length) object = object[toKey(path[index++])];
            return index && index == length ? object : undefined;
          }
          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result = keysFunc(object);
            return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
          }
          function baseGetTag(value) {
            if (null == value) return value === undefined ? undefinedTag : nullTag;
            return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
          }
          function baseGt(value, other) {
            return value > other;
          }
          function baseHas(object, key) {
            return null != object && hasOwnProperty.call(object, key);
          }
          function baseHasIn(object, key) {
            return null != object && key in Object(object);
          }
          function baseInRange(number, start, end) {
            return number >= nativeMin(start, end) && number < nativeMax(start, end);
          }
          function baseIntersection(arrays, iteratee, comparator) {
            var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = Infinity, result = [];
            while (othIndex--) {
              var array = arrays[othIndex];
              othIndex && iteratee && (array = arrayMap(array, baseUnary(iteratee)));
              maxLength = nativeMin(array.length, maxLength);
              caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined;
            }
            array = arrays[0];
            var index = -1, seen = caches[0];
            outer: while (++index < length && result.length < maxLength) {
              var value = array[index], computed = iteratee ? iteratee(value) : value;
              value = comparator || 0 !== value ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) continue outer;
                }
                seen && seen.push(computed);
                result.push(value);
              }
            }
            return result;
          }
          function baseInverter(object, setter, iteratee, accumulator) {
            baseForOwn(object, function(value, key, object) {
              setter(accumulator, iteratee(value), key, object);
            });
            return accumulator;
          }
          function baseInvoke(object, path, args) {
            path = castPath(path, object);
            object = parent(object, path);
            var func = null == object ? object : object[toKey(last(path))];
            return null == func ? undefined : apply(func, object, args);
          }
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }
          function baseIsArrayBuffer(value) {
            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
          }
          function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag;
          }
          function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) return true;
            if (null == value || null == other || !isObjectLike(value) && !isObjectLike(other)) return value !== value && other !== other;
            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
          }
          function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object)) {
              if (!isBuffer(other)) return false;
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack());
              return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
              }
            }
            if (!isSameTag) return false;
            stack || (stack = new Stack());
            return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
          }
          function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
          }
          function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length, length = index, noCustomizer = !customizer;
            if (null == object) return !length;
            object = Object(object);
            while (index--) {
              var data = matchData[index];
              if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) return false;
            }
            while (++index < length) {
              data = matchData[index];
              var key = data[0], objValue = object[key], srcValue = data[1];
              if (noCustomizer && data[2]) {
                if (objValue === undefined && !(key in object)) return false;
              } else {
                var stack = new Stack();
                if (customizer) var result = customizer(objValue, srcValue, key, object, source, stack);
                if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) return false;
              }
            }
            return true;
          }
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) return false;
            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }
          function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
          }
          function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
          }
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }
          function baseIteratee(value) {
            if ("function" == typeof value) return value;
            if (null == value) return identity;
            if ("object" == typeof value) return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            return property(value);
          }
          function baseKeys(object) {
            if (!isPrototype(object)) return nativeKeys(object);
            var result = [];
            for (var key in Object(object)) hasOwnProperty.call(object, key) && "constructor" != key && result.push(key);
            return result;
          }
          function baseKeysIn(object) {
            if (!isObject(object)) return nativeKeysIn(object);
            var isProto = isPrototype(object), result = [];
            for (var key in object) "constructor" == key && (isProto || !hasOwnProperty.call(object, key)) || result.push(key);
            return result;
          }
          function baseLt(value, other) {
            return value < other;
          }
          function baseMap(collection, iteratee) {
            var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
            baseEach(collection, function(value, key, collection) {
              result[++index] = iteratee(value, key, collection);
            });
            return result;
          }
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (1 == matchData.length && matchData[0][2]) return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            return function(object) {
              return object === source || baseIsMatch(object, source, matchData);
            };
          }
          function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) return matchesStrictComparable(toKey(path), srcValue);
            return function(object) {
              var objValue = get(object, path);
              return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
          }
          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) return;
            baseFor(source, function(srcValue, key) {
              stack || (stack = new Stack());
              if (isObject(srcValue)) baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack); else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined;
                newValue === undefined && (newValue = srcValue);
                assignMergeValue(object, key, newValue);
              }
            }, keysIn);
          }
          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
            if (stacked) {
              assignMergeValue(object, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined;
            var isCommon = newValue === undefined;
            if (isCommon) {
              var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) if (isArray(objValue)) newValue = objValue; else if (isArrayLikeObject(objValue)) newValue = copyArray(objValue); else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else newValue = []; else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                newValue = objValue;
                isArguments(objValue) ? newValue = toPlainObject(objValue) : isObject(objValue) && !isFunction(objValue) || (newValue = initCloneObject(srcValue));
              } else isCommon = false;
            }
            if (isCommon) {
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack["delete"](srcValue);
            }
            assignMergeValue(object, key, newValue);
          }
          function baseNth(array, n) {
            var length = array.length;
            if (!length) return;
            n += n < 0 ? length : 0;
            return isIndex(n, length) ? array[n] : undefined;
          }
          function baseOrderBy(collection, iteratees, orders) {
            iteratees = iteratees.length ? arrayMap(iteratees, function(iteratee) {
              if (isArray(iteratee)) return function(value) {
                return baseGet(value, 1 === iteratee.length ? iteratee[0] : iteratee);
              };
              return iteratee;
            }) : [ identity ];
            var index = -1;
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            var result = baseMap(collection, function(value, key, collection) {
              var criteria = arrayMap(iteratees, function(iteratee) {
                return iteratee(value);
              });
              return {
                criteria: criteria,
                index: ++index,
                value: value
              };
            });
            return baseSortBy(result, function(object, other) {
              return compareMultiple(object, other, orders);
            });
          }
          function basePick(object, paths) {
            return basePickBy(object, paths, function(value, path) {
              return hasIn(object, path);
            });
          }
          function basePickBy(object, paths, predicate) {
            var index = -1, length = paths.length, result = {};
            while (++index < length) {
              var path = paths[index], value = baseGet(object, path);
              predicate(value, path) && baseSet(result, castPath(path, object), value);
            }
            return result;
          }
          function basePropertyDeep(path) {
            return function(object) {
              return baseGet(object, path);
            };
          }
          function basePullAll(array, values, iteratee, comparator) {
            var indexOf = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values.length, seen = array;
            array === values && (values = copyArray(values));
            iteratee && (seen = arrayMap(array, baseUnary(iteratee)));
            while (++index < length) {
              var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value;
              while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
                seen !== array && splice.call(seen, fromIndex, 1);
                splice.call(array, fromIndex, 1);
              }
            }
            return array;
          }
          function basePullAt(array, indexes) {
            var length = array ? indexes.length : 0, lastIndex = length - 1;
            while (length--) {
              var index = indexes[length];
              if (length == lastIndex || index !== previous) {
                var previous = index;
                isIndex(index) ? splice.call(array, index, 1) : baseUnset(array, index);
              }
            }
            return array;
          }
          function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
          }
          function baseRange(start, end, step, fromRight) {
            var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
            while (length--) {
              result[fromRight ? length : ++index] = start;
              start += step;
            }
            return result;
          }
          function baseRepeat(string, n) {
            var result = "";
            if (!string || n < 1 || n > MAX_SAFE_INTEGER) return result;
            do {
              n % 2 && (result += string);
              n = nativeFloor(n / 2);
              n && (string += string);
            } while (n);
            return result;
          }
          function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + "");
          }
          function baseSample(collection) {
            return arraySample(values(collection));
          }
          function baseSampleSize(collection, n) {
            var array = values(collection);
            return shuffleSelf(array, baseClamp(n, 0, array.length));
          }
          function baseSet(object, path, value, customizer) {
            if (!isObject(object)) return object;
            path = castPath(path, object);
            var index = -1, length = path.length, lastIndex = length - 1, nested = object;
            while (null != nested && ++index < length) {
              var key = toKey(path[index]), newValue = value;
              if ("__proto__" === key || "constructor" === key || "prototype" === key) return object;
              if (index != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined;
                newValue === undefined && (newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {});
              }
              assignValue(nested, key, newValue);
              nested = nested[key];
            }
            return object;
          }
          var baseSetData = metaMap ? function(func, data) {
            metaMap.set(func, data);
            return func;
          } : identity;
          var baseSetToString = defineProperty ? function(func, string) {
            return defineProperty(func, "toString", {
              configurable: true,
              enumerable: false,
              value: constant(string),
              writable: true
            });
          } : identity;
          function baseShuffle(collection) {
            return shuffleSelf(values(collection));
          }
          function baseSlice(array, start, end) {
            var index = -1, length = array.length;
            start < 0 && (start = -start > length ? 0 : length + start);
            end = end > length ? length : end;
            end < 0 && (end += length);
            length = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result = Array(length);
            while (++index < length) result[index] = array[index + start];
            return result;
          }
          function baseSome(collection, predicate) {
            var result;
            baseEach(collection, function(value, index, collection) {
              result = predicate(value, index, collection);
              return !result;
            });
            return !!result;
          }
          function baseSortedIndex(array, value, retHighest) {
            var low = 0, high = null == array ? low : array.length;
            if ("number" == typeof value && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1, computed = array[mid];
                null !== computed && !isSymbol(computed) && (retHighest ? computed <= value : computed < value) ? low = mid + 1 : high = mid;
              }
              return high;
            }
            return baseSortedIndexBy(array, value, identity, retHighest);
          }
          function baseSortedIndexBy(array, value, iteratee, retHighest) {
            var low = 0, high = null == array ? 0 : array.length;
            if (0 === high) return 0;
            value = iteratee(value);
            var valIsNaN = value !== value, valIsNull = null === value, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined;
            while (low < high) {
              var mid = nativeFloor((low + high) / 2), computed = iteratee(array[mid]), othIsDefined = computed !== undefined, othIsNull = null === computed, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
              if (valIsNaN) var setLow = retHighest || othIsReflexive; else setLow = valIsUndefined ? othIsReflexive && (retHighest || othIsDefined) : valIsNull ? othIsReflexive && othIsDefined && (retHighest || !othIsNull) : valIsSymbol ? othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol) : !othIsNull && !othIsSymbol && (retHighest ? computed <= value : computed < value);
              setLow ? low = mid + 1 : high = mid;
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
          }
          function baseSortedUniq(array, iteratee) {
            var index = -1, length = array.length, resIndex = 0, result = [];
            while (++index < length) {
              var value = array[index], computed = iteratee ? iteratee(value) : value;
              if (!index || !eq(computed, seen)) {
                var seen = computed;
                result[resIndex++] = 0 === value ? 0 : value;
              }
            }
            return result;
          }
          function baseToNumber(value) {
            if ("number" == typeof value) return value;
            if (isSymbol(value)) return NAN;
            return +value;
          }
          function baseToString(value) {
            if ("string" == typeof value) return value;
            if (isArray(value)) return arrayMap(value, baseToString) + "";
            if (isSymbol(value)) return symbolToString ? symbolToString.call(value) : "";
            var result = value + "";
            return "0" == result && 1 / value == -INFINITY ? "-0" : result;
          }
          function baseUniq(array, iteratee, comparator) {
            var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
            if (comparator) {
              isCommon = false;
              includes = arrayIncludesWith;
            } else if (length >= LARGE_ARRAY_SIZE) {
              var set = iteratee ? null : createSet(array);
              if (set) return setToArray(set);
              isCommon = false;
              includes = cacheHas;
              seen = new SetCache();
            } else seen = iteratee ? [] : result;
            outer: while (++index < length) {
              var value = array[index], computed = iteratee ? iteratee(value) : value;
              value = comparator || 0 !== value ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) if (seen[seenIndex] === computed) continue outer;
                iteratee && seen.push(computed);
                result.push(value);
              } else if (!includes(seen, computed, comparator)) {
                seen !== result && seen.push(computed);
                result.push(value);
              }
            }
            return result;
          }
          function baseUnset(object, path) {
            path = castPath(path, object);
            object = parent(object, path);
            return null == object || delete object[toKey(last(path))];
          }
          function baseUpdate(object, path, updater, customizer) {
            return baseSet(object, path, updater(baseGet(object, path)), customizer);
          }
          function baseWhile(array, predicate, isDrop, fromRight) {
            var length = array.length, index = fromRight ? length : -1;
            while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) ;
            return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
          }
          function baseWrapperValue(value, actions) {
            var result = value;
            result instanceof LazyWrapper && (result = result.value());
            return arrayReduce(actions, function(result, action) {
              return action.func.apply(action.thisArg, arrayPush([ result ], action.args));
            }, result);
          }
          function baseXor(arrays, iteratee, comparator) {
            var length = arrays.length;
            if (length < 2) return length ? baseUniq(arrays[0]) : [];
            var index = -1, result = Array(length);
            while (++index < length) {
              var array = arrays[index], othIndex = -1;
              while (++othIndex < length) othIndex != index && (result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator));
            }
            return baseUniq(baseFlatten(result, 1), iteratee, comparator);
          }
          function baseZipObject(props, values, assignFunc) {
            var index = -1, length = props.length, valsLength = values.length, result = {};
            while (++index < length) {
              var value = index < valsLength ? values[index] : undefined;
              assignFunc(result, props[index], value);
            }
            return result;
          }
          function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
          }
          function castFunction(value) {
            return "function" == typeof value ? value : identity;
          }
          function castPath(value, object) {
            if (isArray(value)) return value;
            return isKey(value, object) ? [ value ] : stringToPath(toString(value));
          }
          var castRest = baseRest;
          function castSlice(array, start, end) {
            var length = array.length;
            end = end === undefined ? length : end;
            return !start && end >= length ? array : baseSlice(array, start, end);
          }
          var clearTimeout = ctxClearTimeout || function(id) {
            return root.clearTimeout(id);
          };
          function cloneBuffer(buffer, isDeep) {
            if (isDeep) return buffer.slice();
            var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            buffer.copy(result);
            return result;
          }
          function cloneArrayBuffer(arrayBuffer) {
            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array(result).set(new Uint8Array(arrayBuffer));
            return result;
          }
          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
          }
          function cloneRegExp(regexp) {
            var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result.lastIndex = regexp.lastIndex;
            return result;
          }
          function cloneSymbol(symbol) {
            return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
          }
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }
          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined, valIsNull = null === value, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
              var othIsDefined = other !== undefined, othIsNull = null === other, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) return 1;
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) return -1;
            }
            return 0;
          }
          function compareMultiple(object, other, orders) {
            var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
            while (++index < length) {
              var result = compareAscending(objCriteria[index], othCriteria[index]);
              if (result) {
                if (index >= ordersLength) return result;
                var order = orders[index];
                return result * ("desc" == order ? -1 : 1);
              }
            }
            return object.index - other.index;
          }
          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried;
            while (++leftIndex < leftLength) result[leftIndex] = partials[leftIndex];
            while (++argsIndex < holdersLength) (isUncurried || argsIndex < argsLength) && (result[holders[argsIndex]] = args[argsIndex]);
            while (rangeLength--) result[leftIndex++] = args[argsIndex++];
            return result;
          }
          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried;
            while (++argsIndex < rangeLength) result[argsIndex] = args[argsIndex];
            var offset = argsIndex;
            while (++rightIndex < rightLength) result[offset + rightIndex] = partials[rightIndex];
            while (++holdersIndex < holdersLength) (isUncurried || argsIndex < argsLength) && (result[offset + holders[holdersIndex]] = args[argsIndex++]);
            return result;
          }
          function copyArray(source, array) {
            var index = -1, length = source.length;
            array || (array = Array(length));
            while (++index < length) array[index] = source[index];
            return array;
          }
          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index = -1, length = props.length;
            while (++index < length) {
              var key = props[index];
              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
              newValue === undefined && (newValue = source[key]);
              isNew ? baseAssignValue(object, key, newValue) : assignValue(object, key, newValue);
            }
            return object;
          }
          function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
          }
          function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
          }
          function createAggregator(setter, initializer) {
            return function(collection, iteratee) {
              var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee, 2), accumulator);
            };
          }
          function createAssigner(assigner) {
            return baseRest(function(object, sources) {
              var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;
              customizer = assigner.length > 3 && "function" == typeof customizer ? (length--, 
              customizer) : undefined;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined : customizer;
                length = 1;
              }
              object = Object(object);
              while (++index < length) {
                var source = sources[index];
                source && assigner(object, source, index, customizer);
              }
              return object;
            });
          }
          function createBaseEach(eachFunc, fromRight) {
            return function(collection, iteratee) {
              if (null == collection) return collection;
              if (!isArrayLike(collection)) return eachFunc(collection, iteratee);
              var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
              while (fromRight ? index-- : ++index < length) if (false === iteratee(iterable[index], index, iterable)) break;
              return collection;
            };
          }
          function createBaseFor(fromRight) {
            return function(object, iteratee, keysFunc) {
              var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
              while (length--) {
                var key = props[fromRight ? length : ++index];
                if (false === iteratee(iterable[key], key, iterable)) break;
              }
              return object;
            };
          }
          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return fn.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper;
          }
          function createCaseFirst(methodName) {
            return function(string) {
              string = toString(string);
              var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;
              var chr = strSymbols ? strSymbols[0] : string.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
              return chr[methodName]() + trailing;
            };
          }
          function createCompounder(callback) {
            return function(string) {
              return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
            };
          }
          function createCtor(Ctor) {
            return function() {
              var args = arguments;
              switch (args.length) {
               case 0:
                return new Ctor();

               case 1:
                return new Ctor(args[0]);

               case 2:
                return new Ctor(args[0], args[1]);

               case 3:
                return new Ctor(args[0], args[1], args[2]);

               case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);

               case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);

               case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);

               case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }
              var thisBinding = baseCreate(Ctor.prototype), result = Ctor.apply(thisBinding, args);
              return isObject(result) ? result : thisBinding;
            };
          }
          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array(length), index = length, placeholder = getHolder(wrapper);
              while (index--) args[index] = arguments[index];
              var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
              length -= holders.length;
              if (length < arity) return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);
              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return apply(fn, this, args);
            }
            return wrapper;
          }
          function createFind(findIndexFunc) {
            return function(collection, predicate, fromIndex) {
              var iterable = Object(collection);
              if (!isArrayLike(collection)) {
                var iteratee = getIteratee(predicate, 3);
                collection = keys(collection);
                predicate = function(key) {
                  return iteratee(iterable[key], key, iterable);
                };
              }
              var index = findIndexFunc(collection, predicate, fromIndex);
              return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
            };
          }
          function createFlow(fromRight) {
            return flatRest(function(funcs) {
              var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
              fromRight && funcs.reverse();
              while (index--) {
                var func = funcs[index];
                if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                if (prereq && !wrapper && "wrapper" == getFuncName(func)) var wrapper = new LodashWrapper([], true);
              }
              index = wrapper ? index : length;
              while (++index < length) {
                func = funcs[index];
                var funcName = getFuncName(func), data = "wrapper" == funcName ? getData(func) : undefined;
                wrapper = data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && 1 == data[9] ? wrapper[getFuncName(data[0])].apply(wrapper, data[3]) : 1 == func.length && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
              return function() {
                var args = arguments, value = args[0];
                if (wrapper && 1 == args.length && isArray(value)) return wrapper.plant(value).value();
                var index = 0, result = length ? funcs[index].apply(this, args) : value;
                while (++index < length) result = funcs[index].call(this, result);
                return result;
              };
            });
          }
          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined : createCtor(func);
            function wrapper() {
              var length = arguments.length, args = Array(length), index = length;
              while (index--) args[index] = arguments[index];
              if (isCurried) var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
              partials && (args = composeArgs(args, partials, holders, isCurried));
              partialsRight && (args = composeArgsRight(args, partialsRight, holdersRight, isCurried));
              length -= holdersCount;
              if (isCurried && length < arity) {
                var newHolders = replaceHolders(args, placeholder);
                return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
              }
              var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
              length = args.length;
              argPos ? args = reorder(args, argPos) : isFlip && length > 1 && args.reverse();
              isAry && ary < length && (args.length = ary);
              this && this !== root && this instanceof wrapper && (fn = Ctor || createCtor(fn));
              return fn.apply(thisBinding, args);
            }
            return wrapper;
          }
          function createInverter(setter, toIteratee) {
            return function(object, iteratee) {
              return baseInverter(object, setter, toIteratee(iteratee), {});
            };
          }
          function createMathOperation(operator, defaultValue) {
            return function(value, other) {
              var result;
              if (value === undefined && other === undefined) return defaultValue;
              value !== undefined && (result = value);
              if (other !== undefined) {
                if (result === undefined) return other;
                if ("string" == typeof value || "string" == typeof other) {
                  value = baseToString(value);
                  other = baseToString(other);
                } else {
                  value = baseToNumber(value);
                  other = baseToNumber(other);
                }
                result = operator(value, other);
              }
              return result;
            };
          }
          function createOver(arrayFunc) {
            return flatRest(function(iteratees) {
              iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
              return baseRest(function(args) {
                var thisArg = this;
                return arrayFunc(iteratees, function(iteratee) {
                  return apply(iteratee, thisArg, args);
                });
              });
            });
          }
          function createPadding(length, chars) {
            chars = chars === undefined ? " " : baseToString(chars);
            var charsLength = chars.length;
            if (charsLength < 2) return charsLength ? baseRepeat(chars, length) : chars;
            var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join("") : result.slice(0, length);
          }
          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
            function wrapper() {
              var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              while (++leftIndex < leftLength) args[leftIndex] = partials[leftIndex];
              while (argsLength--) args[leftIndex++] = arguments[++argsIndex];
              return apply(fn, isBind ? thisArg : this, args);
            }
            return wrapper;
          }
          function createRange(fromRight) {
            return function(start, end, step) {
              step && "number" != typeof step && isIterateeCall(start, end, step) && (end = step = undefined);
              start = toFinite(start);
              if (end === undefined) {
                end = start;
                start = 0;
              } else end = toFinite(end);
              step = step === undefined ? start < end ? 1 : -1 : toFinite(step);
              return baseRange(start, end, step, fromRight);
            };
          }
          function createRelationalOperation(operator) {
            return function(value, other) {
              if (!("string" == typeof value && "string" == typeof other)) {
                value = toNumber(value);
                other = toNumber(other);
              }
              return operator(value, other);
            };
          }
          function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined, newHoldersRight = isCurry ? undefined : holders, newPartials = isCurry ? partials : undefined, newPartialsRight = isCurry ? undefined : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
            bitmask & WRAP_CURRY_BOUND_FLAG || (bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG));
            var newData = [ func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity ];
            var result = wrapFunc.apply(undefined, newData);
            isLaziable(func) && setData(result, newData);
            result.placeholder = placeholder;
            return setWrapToString(result, func, bitmask);
          }
          function createRound(methodName) {
            var func = Math[methodName];
            return function(number, precision) {
              number = toNumber(number);
              precision = null == precision ? 0 : nativeMin(toInteger(precision), 292);
              if (precision && nativeIsFinite(number)) {
                var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                pair = (toString(value) + "e").split("e");
                return +(pair[0] + "e" + (+pair[1] - precision));
              }
              return func(number);
            };
          }
          var createSet = Set && 1 / setToArray(new Set([ , -0 ]))[1] == INFINITY ? function(values) {
            return new Set(values);
          } : noop;
          function createToPairs(keysFunc) {
            return function(object) {
              var tag = getTag(object);
              if (tag == mapTag) return mapToArray(object);
              if (tag == setTag) return setToPairs(object);
              return baseToPairs(object, keysFunc(object));
            };
          }
          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && "function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            var length = partials ? partials.length : 0;
            if (!length) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined;
            }
            ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
            arity = arity === undefined ? arity : toInteger(arity);
            length -= holders ? holders.length : 0;
            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials, holdersRight = holders;
              partials = holders = undefined;
            }
            var data = isBindKey ? undefined : getData(func);
            var newData = [ func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity ];
            data && mergeData(newData, data);
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
            !arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG) && (bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG));
            if (bitmask && bitmask != WRAP_BIND_FLAG) result = bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG ? createCurry(func, bitmask, arity) : bitmask != WRAP_PARTIAL_FLAG && bitmask != (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG) || holders.length ? createHybrid.apply(undefined, newData) : createPartial(func, bitmask, thisArg, partials); else var result = createBind(func, bitmask, thisArg);
            var setter = data ? baseSetData : setData;
            return setWrapToString(setter(result, newData), func, bitmask);
          }
          function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) return srcValue;
            return objValue;
          }
          function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
            if (isObject(objValue) && isObject(srcValue)) {
              stack.set(srcValue, objValue);
              baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
              stack["delete"](srcValue);
            }
            return objValue;
          }
          function customOmitClone(value) {
            return isPlainObject(value) ? undefined : value;
          }
          function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) return false;
            var arrStacked = stack.get(array);
            var othStacked = stack.get(other);
            if (arrStacked && othStacked) return arrStacked == other && othStacked == array;
            var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
            stack.set(array, other);
            stack.set(other, array);
            while (++index < arrLength) {
              var arrValue = array[index], othValue = other[index];
              if (customizer) var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
              if (compared !== undefined) {
                if (compared) continue;
                result = false;
                break;
              }
              if (seen) {
                if (!arraySome(other, function(othValue, othIndex) {
                  if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) return seen.push(othIndex);
                })) {
                  result = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result = false;
                break;
              }
            }
            stack["delete"](array);
            stack["delete"](other);
            return result;
          }
          function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
             case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) return false;
              object = object.buffer;
              other = other.buffer;

             case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) return false;
              return true;

             case boolTag:
             case dateTag:
             case numberTag:
              return eq(+object, +other);

             case errorTag:
              return object.name == other.name && object.message == other.message;

             case regexpTag:
             case stringTag:
              return object == other + "";

             case mapTag:
              var convert = mapToArray;

             case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) return false;
              var stacked = stack.get(object);
              if (stacked) return stacked == other;
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result;

             case symbolTag:
              if (symbolValueOf) return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
            return false;
          }
          function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
            if (objLength != othLength && !isPartial) return false;
            var index = objLength;
            while (index--) {
              var key = objProps[index];
              if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) return false;
            }
            var objStacked = stack.get(object);
            var othStacked = stack.get(other);
            if (objStacked && othStacked) return objStacked == other && othStacked == object;
            var result = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;
            while (++index < objLength) {
              key = objProps[index];
              var objValue = object[key], othValue = other[key];
              if (customizer) var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
              if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result = false;
                break;
              }
              skipCtor || (skipCtor = "constructor" == key);
            }
            if (result && !skipCtor) {
              var objCtor = object.constructor, othCtor = other.constructor;
              objCtor != othCtor && "constructor" in object && "constructor" in other && !("function" == typeof objCtor && objCtor instanceof objCtor && "function" == typeof othCtor && othCtor instanceof othCtor) && (result = false);
            }
            stack["delete"](object);
            stack["delete"](other);
            return result;
          }
          function flatRest(func) {
            return setToString(overRest(func, undefined, flatten), func + "");
          }
          function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
          }
          function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
          }
          var getData = metaMap ? function(func) {
            return metaMap.get(func);
          } : noop;
          function getFuncName(func) {
            var result = func.name + "", array = realNames[result], length = hasOwnProperty.call(realNames, result) ? array.length : 0;
            while (length--) {
              var data = array[length], otherFunc = data.func;
              if (null == otherFunc || otherFunc == func) return data.name;
            }
            return result;
          }
          function getHolder(func) {
            var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
            return object.placeholder;
          }
          function getIteratee() {
            var result = lodash.iteratee || iteratee;
            result = result === iteratee ? baseIteratee : result;
            return arguments.length ? result(arguments[0], arguments[1]) : result;
          }
          function getMapData(map, key) {
            var data = map.__data__;
            return isKeyable(key) ? data["string" == typeof key ? "string" : "hash"] : data.map;
          }
          function getMatchData(object) {
            var result = keys(object), length = result.length;
            while (length--) {
              var key = result[length], value = object[key];
              result[length] = [ key, value, isStrictComparable(value) ];
            }
            return result;
          }
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined;
          }
          function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
            try {
              value[symToStringTag] = undefined;
              var unmasked = true;
            } catch (e) {}
            var result = nativeObjectToString.call(value);
            unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]);
            return result;
          }
          var getSymbols = nativeGetSymbols ? function(object) {
            if (null == object) return [];
            object = Object(object);
            return arrayFilter(nativeGetSymbols(object), function(symbol) {
              return propertyIsEnumerable.call(object, symbol);
            });
          } : stubArray;
          var getSymbolsIn = nativeGetSymbols ? function(object) {
            var result = [];
            while (object) {
              arrayPush(result, getSymbols(object));
              object = getPrototype(object);
            }
            return result;
          } : stubArray;
          var getTag = baseGetTag;
          (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) && (getTag = function(value) {
            var result = baseGetTag(value), Ctor = result == objectTag ? value.constructor : undefined, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) switch (ctorString) {
             case dataViewCtorString:
              return dataViewTag;

             case mapCtorString:
              return mapTag;

             case promiseCtorString:
              return promiseTag;

             case setCtorString:
              return setTag;

             case weakMapCtorString:
              return weakMapTag;
            }
            return result;
          });
          function getView(start, end, transforms) {
            var index = -1, length = transforms.length;
            while (++index < length) {
              var data = transforms[index], size = data.size;
              switch (data.type) {
               case "drop":
                start += size;
                break;

               case "dropRight":
                end -= size;
                break;

               case "take":
                end = nativeMin(end, start + size);
                break;

               case "takeRight":
                start = nativeMax(start, end - size);
              }
            }
            return {
              start: start,
              end: end
            };
          }
          function getWrapDetails(source) {
            var match = source.match(reWrapDetails);
            return match ? match[1].split(reSplitDetails) : [];
          }
          function hasPath(object, path, hasFunc) {
            path = castPath(path, object);
            var index = -1, length = path.length, result = false;
            while (++index < length) {
              var key = toKey(path[index]);
              if (!(result = null != object && hasFunc(object, key))) break;
              object = object[key];
            }
            if (result || ++index != length) return result;
            length = null == object ? 0 : object.length;
            return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
          }
          function initCloneArray(array) {
            var length = array.length, result = new array.constructor(length);
            if (length && "string" == typeof array[0] && hasOwnProperty.call(array, "index")) {
              result.index = array.index;
              result.input = array.input;
            }
            return result;
          }
          function initCloneObject(object) {
            return "function" != typeof object.constructor || isPrototype(object) ? {} : baseCreate(getPrototype(object));
          }
          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
             case arrayBufferTag:
              return cloneArrayBuffer(object);

             case boolTag:
             case dateTag:
              return new Ctor(+object);

             case dataViewTag:
              return cloneDataView(object, isDeep);

             case float32Tag:
             case float64Tag:
             case int8Tag:
             case int16Tag:
             case int32Tag:
             case uint8Tag:
             case uint8ClampedTag:
             case uint16Tag:
             case uint32Tag:
              return cloneTypedArray(object, isDeep);

             case mapTag:
              return new Ctor();

             case numberTag:
             case stringTag:
              return new Ctor(object);

             case regexpTag:
              return cloneRegExp(object);

             case setTag:
              return new Ctor();

             case symbolTag:
              return cloneSymbol(object);
            }
          }
          function insertWrapDetails(source, details) {
            var length = details.length;
            if (!length) return source;
            var lastIndex = length - 1;
            details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
            details = details.join(length > 2 ? ", " : " ");
            return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
          }
          function isFlattenable(value) {
            return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
          }
          function isIndex(value, length) {
            var type = typeof value;
            length = null == length ? MAX_SAFE_INTEGER : length;
            return !!length && ("number" == type || "symbol" != type && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
          }
          function isIterateeCall(value, index, object) {
            if (!isObject(object)) return false;
            var type = typeof index;
            if ("number" == type ? isArrayLike(object) && isIndex(index, object.length) : "string" == type && index in object) return eq(object[index], value);
            return false;
          }
          function isKey(value, object) {
            if (isArray(value)) return false;
            var type = typeof value;
            if ("number" == type || "symbol" == type || "boolean" == type || null == value || isSymbol(value)) return true;
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || null != object && value in Object(object);
          }
          function isKeyable(value) {
            var type = typeof value;
            return "string" == type || "number" == type || "symbol" == type || "boolean" == type ? "__proto__" !== value : null === value;
          }
          function isLaziable(func) {
            var funcName = getFuncName(func), other = lodash[funcName];
            if ("function" != typeof other || !(funcName in LazyWrapper.prototype)) return false;
            if (func === other) return true;
            var data = getData(other);
            return !!data && func === data[0];
          }
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }
          var isMaskable = coreJsData ? isFunction : stubFalse;
          function isPrototype(value) {
            var Ctor = value && value.constructor, proto = "function" == typeof Ctor && Ctor.prototype || objectProto;
            return value === proto;
          }
          function isStrictComparable(value) {
            return value === value && !isObject(value);
          }
          function matchesStrictComparable(key, srcValue) {
            return function(object) {
              if (null == object) return false;
              return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
            };
          }
          function memoizeCapped(func) {
            var result = memoize(func, function(key) {
              cache.size === MAX_MEMOIZE_SIZE && cache.clear();
              return key;
            });
            var cache = result.cache;
            return result;
          }
          function mergeData(data, source) {
            var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
            if (!(isCommon || isCombo)) return data;
            if (srcBitmask & WRAP_BIND_FLAG) {
              data[2] = source[2];
              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            }
            var value = source[3];
            if (value) {
              var partials = data[3];
              data[3] = partials ? composeArgs(partials, value, source[4]) : value;
              data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            value = source[5];
            if (value) {
              partials = data[5];
              data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
              data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            }
            value = source[7];
            value && (data[7] = value);
            srcBitmask & WRAP_ARY_FLAG && (data[8] = null == data[8] ? source[8] : nativeMin(data[8], source[8]));
            null == data[9] && (data[9] = source[9]);
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
          }
          function nativeKeysIn(object) {
            var result = [];
            if (null != object) for (var key in Object(object)) result.push(key);
            return result;
          }
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }
          function overRest(func, start, transform) {
            start = nativeMax(start === undefined ? func.length - 1 : start, 0);
            return function() {
              var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
              while (++index < length) array[index] = args[start + index];
              index = -1;
              var otherArgs = Array(start + 1);
              while (++index < start) otherArgs[index] = args[index];
              otherArgs[start] = transform(array);
              return apply(func, this, otherArgs);
            };
          }
          function parent(object, path) {
            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
          }
          function reorder(array, indexes) {
            var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
            while (length--) {
              var index = indexes[length];
              array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
            }
            return array;
          }
          function safeGet(object, key) {
            if ("constructor" === key && "function" === typeof object[key]) return;
            if ("__proto__" == key) return;
            return object[key];
          }
          var setData = shortOut(baseSetData);
          var setTimeout = ctxSetTimeout || function(func, wait) {
            return root.setTimeout(func, wait);
          };
          var setToString = shortOut(baseSetToString);
          function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + "";
            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
          }
          function shortOut(func) {
            var count = 0, lastCalled = 0;
            return function() {
              var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) return arguments[0];
              } else count = 0;
              return func.apply(undefined, arguments);
            };
          }
          function shuffleSelf(array, size) {
            var index = -1, length = array.length, lastIndex = length - 1;
            size = size === undefined ? length : size;
            while (++index < size) {
              var rand = baseRandom(index, lastIndex), value = array[rand];
              array[rand] = array[index];
              array[index] = value;
            }
            array.length = size;
            return array;
          }
          var stringToPath = memoizeCapped(function(string) {
            var result = [];
            46 === string.charCodeAt(0) && result.push("");
            string.replace(rePropName, function(match, number, quote, subString) {
              result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
            });
            return result;
          });
          function toKey(value) {
            if ("string" == typeof value || isSymbol(value)) return value;
            var result = value + "";
            return "0" == result && 1 / value == -INFINITY ? "-0" : result;
          }
          function toSource(func) {
            if (null != func) {
              try {
                return funcToString.call(func);
              } catch (e) {}
              try {
                return func + "";
              } catch (e) {}
            }
            return "";
          }
          function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function(pair) {
              var value = "_." + pair[0];
              bitmask & pair[1] && !arrayIncludes(details, value) && details.push(value);
            });
            return details.sort();
          }
          function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) return wrapper.clone();
            var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result.__actions__ = copyArray(wrapper.__actions__);
            result.__index__ = wrapper.__index__;
            result.__values__ = wrapper.__values__;
            return result;
          }
          function chunk(array, size, guard) {
            size = (guard ? isIterateeCall(array, size, guard) : size === undefined) ? 1 : nativeMax(toInteger(size), 0);
            var length = null == array ? 0 : array.length;
            if (!length || size < 1) return [];
            var index = 0, resIndex = 0, result = Array(nativeCeil(length / size));
            while (index < length) result[resIndex++] = baseSlice(array, index, index += size);
            return result;
          }
          function compact(array) {
            var index = -1, length = null == array ? 0 : array.length, resIndex = 0, result = [];
            while (++index < length) {
              var value = array[index];
              value && (result[resIndex++] = value);
            }
            return result;
          }
          function concat() {
            var length = arguments.length;
            if (!length) return [];
            var args = Array(length - 1), array = arguments[0], index = length;
            while (index--) args[index - 1] = arguments[index];
            return arrayPush(isArray(array) ? copyArray(array) : [ array ], baseFlatten(args, 1));
          }
          var difference = baseRest(function(array, values) {
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
          });
          var differenceBy = baseRest(function(array, values) {
            var iteratee = last(values);
            isArrayLikeObject(iteratee) && (iteratee = undefined);
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2)) : [];
          });
          var differenceWith = baseRest(function(array, values) {
            var comparator = last(values);
            isArrayLikeObject(comparator) && (comparator = undefined);
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator) : [];
          });
          function drop(array, n, guard) {
            var length = null == array ? 0 : array.length;
            if (!length) return [];
            n = guard || n === undefined ? 1 : toInteger(n);
            return baseSlice(array, n < 0 ? 0 : n, length);
          }
          function dropRight(array, n, guard) {
            var length = null == array ? 0 : array.length;
            if (!length) return [];
            n = guard || n === undefined ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }
          function dropRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
          }
          function dropWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
          }
          function fill(array, value, start, end) {
            var length = null == array ? 0 : array.length;
            if (!length) return [];
            if (start && "number" != typeof start && isIterateeCall(array, value, start)) {
              start = 0;
              end = length;
            }
            return baseFill(array, value, start, end);
          }
          function findIndex(array, predicate, fromIndex) {
            var length = null == array ? 0 : array.length;
            if (!length) return -1;
            var index = null == fromIndex ? 0 : toInteger(fromIndex);
            index < 0 && (index = nativeMax(length + index, 0));
            return baseFindIndex(array, getIteratee(predicate, 3), index);
          }
          function findLastIndex(array, predicate, fromIndex) {
            var length = null == array ? 0 : array.length;
            if (!length) return -1;
            var index = length - 1;
            if (fromIndex !== undefined) {
              index = toInteger(fromIndex);
              index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index, true);
          }
          function flatten(array) {
            var length = null == array ? 0 : array.length;
            return length ? baseFlatten(array, 1) : [];
          }
          function flattenDeep(array) {
            var length = null == array ? 0 : array.length;
            return length ? baseFlatten(array, INFINITY) : [];
          }
          function flattenDepth(array, depth) {
            var length = null == array ? 0 : array.length;
            if (!length) return [];
            depth = depth === undefined ? 1 : toInteger(depth);
            return baseFlatten(array, depth);
          }
          function fromPairs(pairs) {
            var index = -1, length = null == pairs ? 0 : pairs.length, result = {};
            while (++index < length) {
              var pair = pairs[index];
              result[pair[0]] = pair[1];
            }
            return result;
          }
          function head(array) {
            return array && array.length ? array[0] : undefined;
          }
          function indexOf(array, value, fromIndex) {
            var length = null == array ? 0 : array.length;
            if (!length) return -1;
            var index = null == fromIndex ? 0 : toInteger(fromIndex);
            index < 0 && (index = nativeMax(length + index, 0));
            return baseIndexOf(array, value, index);
          }
          function initial(array) {
            var length = null == array ? 0 : array.length;
            return length ? baseSlice(array, 0, -1) : [];
          }
          var intersection = baseRest(function(arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });
          var intersectionBy = baseRest(function(arrays) {
            var iteratee = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            iteratee === last(mapped) ? iteratee = undefined : mapped.pop();
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee, 2)) : [];
          });
          var intersectionWith = baseRest(function(arrays) {
            var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
            comparator = "function" == typeof comparator ? comparator : undefined;
            comparator && mapped.pop();
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : [];
          });
          function join(array, separator) {
            return null == array ? "" : nativeJoin.call(array, separator);
          }
          function last(array) {
            var length = null == array ? 0 : array.length;
            return length ? array[length - 1] : undefined;
          }
          function lastIndexOf(array, value, fromIndex) {
            var length = null == array ? 0 : array.length;
            if (!length) return -1;
            var index = length;
            if (fromIndex !== undefined) {
              index = toInteger(fromIndex);
              index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }
            return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
          }
          function nth(array, n) {
            return array && array.length ? baseNth(array, toInteger(n)) : undefined;
          }
          var pull = baseRest(pullAll);
          function pullAll(array, values) {
            return array && array.length && values && values.length ? basePullAll(array, values) : array;
          }
          function pullAllBy(array, values, iteratee) {
            return array && array.length && values && values.length ? basePullAll(array, values, getIteratee(iteratee, 2)) : array;
          }
          function pullAllWith(array, values, comparator) {
            return array && array.length && values && values.length ? basePullAll(array, values, undefined, comparator) : array;
          }
          var pullAt = flatRest(function(array, indexes) {
            var length = null == array ? 0 : array.length, result = baseAt(array, indexes);
            basePullAt(array, arrayMap(indexes, function(index) {
              return isIndex(index, length) ? +index : index;
            }).sort(compareAscending));
            return result;
          });
          function remove(array, predicate) {
            var result = [];
            if (!(array && array.length)) return result;
            var index = -1, indexes = [], length = array.length;
            predicate = getIteratee(predicate, 3);
            while (++index < length) {
              var value = array[index];
              if (predicate(value, index, array)) {
                result.push(value);
                indexes.push(index);
              }
            }
            basePullAt(array, indexes);
            return result;
          }
          function reverse(array) {
            return null == array ? array : nativeReverse.call(array);
          }
          function slice(array, start, end) {
            var length = null == array ? 0 : array.length;
            if (!length) return [];
            if (end && "number" != typeof end && isIterateeCall(array, start, end)) {
              start = 0;
              end = length;
            } else {
              start = null == start ? 0 : toInteger(start);
              end = end === undefined ? length : toInteger(end);
            }
            return baseSlice(array, start, end);
          }
          function sortedIndex(array, value) {
            return baseSortedIndex(array, value);
          }
          function sortedIndexBy(array, value, iteratee) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
          }
          function sortedIndexOf(array, value) {
            var length = null == array ? 0 : array.length;
            if (length) {
              var index = baseSortedIndex(array, value);
              if (index < length && eq(array[index], value)) return index;
            }
            return -1;
          }
          function sortedLastIndex(array, value) {
            return baseSortedIndex(array, value, true);
          }
          function sortedLastIndexBy(array, value, iteratee) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
          }
          function sortedLastIndexOf(array, value) {
            var length = null == array ? 0 : array.length;
            if (length) {
              var index = baseSortedIndex(array, value, true) - 1;
              if (eq(array[index], value)) return index;
            }
            return -1;
          }
          function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : [];
          }
          function sortedUniqBy(array, iteratee) {
            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee, 2)) : [];
          }
          function tail(array) {
            var length = null == array ? 0 : array.length;
            return length ? baseSlice(array, 1, length) : [];
          }
          function take(array, n, guard) {
            if (!(array && array.length)) return [];
            n = guard || n === undefined ? 1 : toInteger(n);
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }
          function takeRight(array, n, guard) {
            var length = null == array ? 0 : array.length;
            if (!length) return [];
            n = guard || n === undefined ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, n < 0 ? 0 : n, length);
          }
          function takeRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
          }
          function takeWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
          }
          var union = baseRest(function(arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
          });
          var unionBy = baseRest(function(arrays) {
            var iteratee = last(arrays);
            isArrayLikeObject(iteratee) && (iteratee = undefined);
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
          });
          var unionWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = "function" == typeof comparator ? comparator : undefined;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
          });
          function uniq(array) {
            return array && array.length ? baseUniq(array) : [];
          }
          function uniqBy(array, iteratee) {
            return array && array.length ? baseUniq(array, getIteratee(iteratee, 2)) : [];
          }
          function uniqWith(array, comparator) {
            comparator = "function" == typeof comparator ? comparator : undefined;
            return array && array.length ? baseUniq(array, undefined, comparator) : [];
          }
          function unzip(array) {
            if (!(array && array.length)) return [];
            var length = 0;
            array = arrayFilter(array, function(group) {
              if (isArrayLikeObject(group)) {
                length = nativeMax(group.length, length);
                return true;
              }
            });
            return baseTimes(length, function(index) {
              return arrayMap(array, baseProperty(index));
            });
          }
          function unzipWith(array, iteratee) {
            if (!(array && array.length)) return [];
            var result = unzip(array);
            if (null == iteratee) return result;
            return arrayMap(result, function(group) {
              return apply(iteratee, undefined, group);
            });
          }
          var without = baseRest(function(array, values) {
            return isArrayLikeObject(array) ? baseDifference(array, values) : [];
          });
          var xor = baseRest(function(arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
          });
          var xorBy = baseRest(function(arrays) {
            var iteratee = last(arrays);
            isArrayLikeObject(iteratee) && (iteratee = undefined);
            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
          });
          var xorWith = baseRest(function(arrays) {
            var comparator = last(arrays);
            comparator = "function" == typeof comparator ? comparator : undefined;
            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
          });
          var zip = baseRest(unzip);
          function zipObject(props, values) {
            return baseZipObject(props || [], values || [], assignValue);
          }
          function zipObjectDeep(props, values) {
            return baseZipObject(props || [], values || [], baseSet);
          }
          var zipWith = baseRest(function(arrays) {
            var length = arrays.length, iteratee = length > 1 ? arrays[length - 1] : undefined;
            iteratee = "function" == typeof iteratee ? (arrays.pop(), iteratee) : undefined;
            return unzipWith(arrays, iteratee);
          });
          function chain(value) {
            var result = lodash(value);
            result.__chain__ = true;
            return result;
          }
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }
          function thru(value, interceptor) {
            return interceptor(value);
          }
          var wrapperAt = flatRest(function(paths) {
            var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
              return baseAt(object, paths);
            };
            if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) return this.thru(interceptor);
            value = value.slice(start, +start + (length ? 1 : 0));
            value.__actions__.push({
              func: thru,
              args: [ interceptor ],
              thisArg: undefined
            });
            return new LodashWrapper(value, this.__chain__).thru(function(array) {
              length && !array.length && array.push(undefined);
              return array;
            });
          });
          function wrapperChain() {
            return chain(this);
          }
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }
          function wrapperNext() {
            this.__values__ === undefined && (this.__values__ = toArray(this.value()));
            var done = this.__index__ >= this.__values__.length, value = done ? undefined : this.__values__[this.__index__++];
            return {
              done: done,
              value: value
            };
          }
          function wrapperToIterator() {
            return this;
          }
          function wrapperPlant(value) {
            var result, parent = this;
            while (parent instanceof baseLodash) {
              var clone = wrapperClone(parent);
              clone.__index__ = 0;
              clone.__values__ = undefined;
              result ? previous.__wrapped__ = clone : result = clone;
              var previous = clone;
              parent = parent.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result;
          }
          function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
              var wrapped = value;
              this.__actions__.length && (wrapped = new LazyWrapper(this));
              wrapped = wrapped.reverse();
              wrapped.__actions__.push({
                func: thru,
                args: [ reverse ],
                thisArg: undefined
              });
              return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse);
          }
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }
          var countBy = createAggregator(function(result, value, key) {
            hasOwnProperty.call(result, key) ? ++result[key] : baseAssignValue(result, key, 1);
          });
          function every(collection, predicate, guard) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined);
            return func(collection, getIteratee(predicate, 3));
          }
          function filter(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
          }
          var find = createFind(findIndex);
          var findLast = createFind(findLastIndex);
          function flatMap(collection, iteratee) {
            return baseFlatten(map(collection, iteratee), 1);
          }
          function flatMapDeep(collection, iteratee) {
            return baseFlatten(map(collection, iteratee), INFINITY);
          }
          function flatMapDepth(collection, iteratee, depth) {
            depth = depth === undefined ? 1 : toInteger(depth);
            return baseFlatten(map(collection, iteratee), depth);
          }
          function forEach(collection, iteratee) {
            var func = isArray(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee, 3));
          }
          function forEachRight(collection, iteratee) {
            var func = isArray(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee, 3));
          }
          var groupBy = createAggregator(function(result, value, key) {
            hasOwnProperty.call(result, key) ? result[key].push(value) : baseAssignValue(result, key, [ value ]);
          });
          function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;
            fromIndex < 0 && (fromIndex = nativeMax(length + fromIndex, 0));
            return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
          }
          var invokeMap = baseRest(function(collection, path, args) {
            var index = -1, isFunc = "function" == typeof path, result = isArrayLike(collection) ? Array(collection.length) : [];
            baseEach(collection, function(value) {
              result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
            });
            return result;
          });
          var keyBy = createAggregator(function(result, value, key) {
            baseAssignValue(result, key, value);
          });
          function map(collection, iteratee) {
            var func = isArray(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee, 3));
          }
          function orderBy(collection, iteratees, orders, guard) {
            if (null == collection) return [];
            isArray(iteratees) || (iteratees = null == iteratees ? [] : [ iteratees ]);
            orders = guard ? undefined : orders;
            isArray(orders) || (orders = null == orders ? [] : [ orders ]);
            return baseOrderBy(collection, iteratees, orders);
          }
          var partition = createAggregator(function(result, value, key) {
            result[key ? 0 : 1].push(value);
          }, function() {
            return [ [], [] ];
          });
          function reduce(collection, iteratee, accumulator) {
            var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
          }
          function reduceRight(collection, iteratee, accumulator) {
            var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
          }
          function reject(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, negate(getIteratee(predicate, 3)));
          }
          function sample(collection) {
            var func = isArray(collection) ? arraySample : baseSample;
            return func(collection);
          }
          function sampleSize(collection, n, guard) {
            n = (guard ? isIterateeCall(collection, n, guard) : n === undefined) ? 1 : toInteger(n);
            var func = isArray(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n);
          }
          function shuffle(collection) {
            var func = isArray(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }
          function size(collection) {
            if (null == collection) return 0;
            if (isArrayLike(collection)) return isString(collection) ? stringSize(collection) : collection.length;
            var tag = getTag(collection);
            if (tag == mapTag || tag == setTag) return collection.size;
            return baseKeys(collection).length;
          }
          function some(collection, predicate, guard) {
            var func = isArray(collection) ? arraySome : baseSome;
            guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined);
            return func(collection, getIteratee(predicate, 3));
          }
          var sortBy = baseRest(function(collection, iteratees) {
            if (null == collection) return [];
            var length = iteratees.length;
            length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1]) ? iteratees = [] : length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2]) && (iteratees = [ iteratees[0] ]);
            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
          });
          var now = ctxNow || function() {
            return root.Date.now();
          };
          function after(n, func) {
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            n = toInteger(n);
            return function() {
              if (--n < 1) return func.apply(this, arguments);
            };
          }
          function ary(func, n, guard) {
            n = guard ? undefined : n;
            n = func && null == n ? func.length : n;
            return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
          }
          function before(n, func) {
            var result;
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            n = toInteger(n);
            return function() {
              --n > 0 && (result = func.apply(this, arguments));
              n <= 1 && (func = undefined);
              return result;
            };
          }
          var bind = baseRest(function(func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
          });
          var bindKey = baseRest(function(object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object, partials, holders);
          });
          function curry(func, arity, guard) {
            arity = guard ? undefined : arity;
            var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
            result.placeholder = curry.placeholder;
            return result;
          }
          function curryRight(func, arity, guard) {
            arity = guard ? undefined : arity;
            var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
            result.placeholder = curryRight.placeholder;
            return result;
          }
          function debounce(func, wait, options) {
            var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            wait = toNumber(wait) || 0;
            if (isObject(options)) {
              leading = !!options.leading;
              maxing = "maxWait" in options;
              maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
              var args = lastArgs, thisArg = lastThis;
              lastArgs = lastThis = undefined;
              lastInvokeTime = time;
              result = func.apply(thisArg, args);
              return result;
            }
            function leadingEdge(time) {
              lastInvokeTime = time;
              timerId = setTimeout(timerExpired, wait);
              return leading ? invokeFunc(time) : result;
            }
            function remainingWait(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
              return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
              return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
              var time = now();
              if (shouldInvoke(time)) return trailingEdge(time);
              timerId = setTimeout(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
              timerId = undefined;
              if (trailing && lastArgs) return invokeFunc(time);
              lastArgs = lastThis = undefined;
              return result;
            }
            function cancel() {
              timerId !== undefined && clearTimeout(timerId);
              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined;
            }
            function flush() {
              return timerId === undefined ? result : trailingEdge(now());
            }
            function debounced() {
              var time = now(), isInvoking = shouldInvoke(time);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time;
              if (isInvoking) {
                if (timerId === undefined) return leadingEdge(lastCallTime);
                if (maxing) {
                  clearTimeout(timerId);
                  timerId = setTimeout(timerExpired, wait);
                  return invokeFunc(lastCallTime);
                }
              }
              timerId === undefined && (timerId = setTimeout(timerExpired, wait));
              return result;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
          }
          var defer = baseRest(function(func, args) {
            return baseDelay(func, 1, args);
          });
          var delay = baseRest(function(func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args);
          });
          function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }
          function memoize(func, resolver) {
            if ("function" != typeof func || null != resolver && "function" != typeof resolver) throw new TypeError(FUNC_ERROR_TEXT);
            var memoized = function() {
              var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
              if (cache.has(key)) return cache.get(key);
              var result = func.apply(this, args);
              memoized.cache = cache.set(key, result) || cache;
              return result;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }
          memoize.Cache = MapCache;
          function negate(predicate) {
            if ("function" != typeof predicate) throw new TypeError(FUNC_ERROR_TEXT);
            return function() {
              var args = arguments;
              switch (args.length) {
               case 0:
                return !predicate.call(this);

               case 1:
                return !predicate.call(this, args[0]);

               case 2:
                return !predicate.call(this, args[0], args[1]);

               case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
              }
              return !predicate.apply(this, args);
            };
          }
          function once(func) {
            return before(2, func);
          }
          var overArgs = castRest(function(func, transforms) {
            transforms = 1 == transforms.length && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function(args) {
              var index = -1, length = nativeMin(args.length, funcsLength);
              while (++index < length) args[index] = transforms[index].call(this, args[index]);
              return apply(func, this, args);
            });
          });
          var partial = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
          });
          var partialRight = baseRest(function(func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
          });
          var rearg = flatRest(function(func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
          });
          function rest(func, start) {
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            start = start === undefined ? start : toInteger(start);
            return baseRest(func, start);
          }
          function spread(func, start) {
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            start = null == start ? 0 : nativeMax(toInteger(start), 0);
            return baseRest(function(args) {
              var array = args[start], otherArgs = castSlice(args, 0, start);
              array && arrayPush(otherArgs, array);
              return apply(func, this, otherArgs);
            });
          }
          function throttle(func, wait, options) {
            var leading = true, trailing = true;
            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
            if (isObject(options)) {
              leading = "leading" in options ? !!options.leading : leading;
              trailing = "trailing" in options ? !!options.trailing : trailing;
            }
            return debounce(func, wait, {
              leading: leading,
              maxWait: wait,
              trailing: trailing
            });
          }
          function unary(func) {
            return ary(func, 1);
          }
          function wrap(value, wrapper) {
            return partial(castFunction(wrapper), value);
          }
          function castArray() {
            if (!arguments.length) return [];
            var value = arguments[0];
            return isArray(value) ? value : [ value ];
          }
          function clone(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
          }
          function cloneWith(value, customizer) {
            customizer = "function" == typeof customizer ? customizer : undefined;
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
          }
          function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }
          function cloneDeepWith(value, customizer) {
            customizer = "function" == typeof customizer ? customizer : undefined;
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
          }
          function conformsTo(object, source) {
            return null == source || baseConformsTo(object, source, keys(source));
          }
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }
          var gt = createRelationalOperation(baseGt);
          var gte = createRelationalOperation(function(value, other) {
            return value >= other;
          });
          var isArguments = baseIsArguments(function() {
            return arguments;
          }()) ? baseIsArguments : function(value) {
            return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
          };
          var isArray = Array.isArray;
          var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
          function isArrayLike(value) {
            return null != value && isLength(value.length) && !isFunction(value);
          }
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }
          function isBoolean(value) {
            return true === value || false === value || isObjectLike(value) && baseGetTag(value) == boolTag;
          }
          var isBuffer = nativeIsBuffer || stubFalse;
          var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
          function isElement(value) {
            return isObjectLike(value) && 1 === value.nodeType && !isPlainObject(value);
          }
          function isEmpty(value) {
            if (null == value) return true;
            if (isArrayLike(value) && (isArray(value) || "string" == typeof value || "function" == typeof value.splice || isBuffer(value) || isTypedArray(value) || isArguments(value))) return !value.length;
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) return !value.size;
            if (isPrototype(value)) return !baseKeys(value).length;
            for (var key in value) if (hasOwnProperty.call(value, key)) return false;
            return true;
          }
          function isEqual(value, other) {
            return baseIsEqual(value, other);
          }
          function isEqualWith(value, other, customizer) {
            customizer = "function" == typeof customizer ? customizer : undefined;
            var result = customizer ? customizer(value, other) : undefined;
            return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
          }
          function isError(value) {
            if (!isObjectLike(value)) return false;
            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || "string" == typeof value.message && "string" == typeof value.name && !isPlainObject(value);
          }
          function isFinite(value) {
            return "number" == typeof value && nativeIsFinite(value);
          }
          function isFunction(value) {
            if (!isObject(value)) return false;
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }
          function isInteger(value) {
            return "number" == typeof value && value == toInteger(value);
          }
          function isLength(value) {
            return "number" == typeof value && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }
          function isObject(value) {
            var type = typeof value;
            return null != value && ("object" == type || "function" == type);
          }
          function isObjectLike(value) {
            return null != value && "object" == typeof value;
          }
          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
          function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
          }
          function isMatchWith(object, source, customizer) {
            customizer = "function" == typeof customizer ? customizer : undefined;
            return baseIsMatch(object, source, getMatchData(source), customizer);
          }
          function isNaN(value) {
            return isNumber(value) && value != +value;
          }
          function isNative(value) {
            if (isMaskable(value)) throw new Error(CORE_ERROR_TEXT);
            return baseIsNative(value);
          }
          function isNull(value) {
            return null === value;
          }
          function isNil(value) {
            return null == value;
          }
          function isNumber(value) {
            return "number" == typeof value || isObjectLike(value) && baseGetTag(value) == numberTag;
          }
          function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) return false;
            var proto = getPrototype(value);
            if (null === proto) return true;
            var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
            return "function" == typeof Ctor && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }
          var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
          function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
          }
          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
          function isString(value) {
            return "string" == typeof value || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
          }
          function isSymbol(value) {
            return "symbol" == typeof value || isObjectLike(value) && baseGetTag(value) == symbolTag;
          }
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
          function isUndefined(value) {
            return value === undefined;
          }
          function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag;
          }
          function isWeakSet(value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
          }
          var lt = createRelationalOperation(baseLt);
          var lte = createRelationalOperation(function(value, other) {
            return value <= other;
          });
          function toArray(value) {
            if (!value) return [];
            if (isArrayLike(value)) return isString(value) ? stringToArray(value) : copyArray(value);
            if (symIterator && value[symIterator]) return iteratorToArray(value[symIterator]());
            var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
            return func(value);
          }
          function toFinite(value) {
            if (!value) return 0 === value ? value : 0;
            value = toNumber(value);
            if (value === INFINITY || value === -INFINITY) {
              var sign = value < 0 ? -1 : 1;
              return sign * MAX_INTEGER;
            }
            return value === value ? value : 0;
          }
          function toInteger(value) {
            var result = toFinite(value), remainder = result % 1;
            return result === result ? remainder ? result - remainder : result : 0;
          }
          function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
          }
          function toNumber(value) {
            if ("number" == typeof value) return value;
            if (isSymbol(value)) return NAN;
            if (isObject(value)) {
              var other = "function" == typeof value.valueOf ? value.valueOf() : value;
              value = isObject(other) ? other + "" : other;
            }
            if ("string" != typeof value) return 0 === value ? value : +value;
            value = baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
          }
          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }
          function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : 0 === value ? value : 0;
          }
          function toString(value) {
            return null == value ? "" : baseToString(value);
          }
          var assign = createAssigner(function(object, source) {
            if (isPrototype(source) || isArrayLike(source)) {
              copyObject(source, keys(source), object);
              return;
            }
            for (var key in source) hasOwnProperty.call(source, key) && assignValue(object, key, source[key]);
          });
          var assignIn = createAssigner(function(object, source) {
            copyObject(source, keysIn(source), object);
          });
          var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
          });
          var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
            copyObject(source, keys(source), object, customizer);
          });
          var at = flatRest(baseAt);
          function create(prototype, properties) {
            var result = baseCreate(prototype);
            return null == properties ? result : baseAssign(result, properties);
          }
          var defaults = baseRest(function(object, sources) {
            object = Object(object);
            var index = -1;
            var length = sources.length;
            var guard = length > 2 ? sources[2] : undefined;
            guard && isIterateeCall(sources[0], sources[1], guard) && (length = 1);
            while (++index < length) {
              var source = sources[index];
              var props = keysIn(source);
              var propsIndex = -1;
              var propsLength = props.length;
              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object[key];
                (value === undefined || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) && (object[key] = source[key]);
              }
            }
            return object;
          });
          var defaultsDeep = baseRest(function(args) {
            args.push(undefined, customDefaultsMerge);
            return apply(mergeWith, undefined, args);
          });
          function findKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
          }
          function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
          }
          function forIn(object, iteratee) {
            return null == object ? object : baseFor(object, getIteratee(iteratee, 3), keysIn);
          }
          function forInRight(object, iteratee) {
            return null == object ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn);
          }
          function forOwn(object, iteratee) {
            return object && baseForOwn(object, getIteratee(iteratee, 3));
          }
          function forOwnRight(object, iteratee) {
            return object && baseForOwnRight(object, getIteratee(iteratee, 3));
          }
          function functions(object) {
            return null == object ? [] : baseFunctions(object, keys(object));
          }
          function functionsIn(object) {
            return null == object ? [] : baseFunctions(object, keysIn(object));
          }
          function get(object, path, defaultValue) {
            var result = null == object ? undefined : baseGet(object, path);
            return result === undefined ? defaultValue : result;
          }
          function has(object, path) {
            return null != object && hasPath(object, path, baseHas);
          }
          function hasIn(object, path) {
            return null != object && hasPath(object, path, baseHasIn);
          }
          var invert = createInverter(function(result, value, key) {
            null != value && "function" != typeof value.toString && (value = nativeObjectToString.call(value));
            result[value] = key;
          }, constant(identity));
          var invertBy = createInverter(function(result, value, key) {
            null != value && "function" != typeof value.toString && (value = nativeObjectToString.call(value));
            hasOwnProperty.call(result, value) ? result[value].push(key) : result[value] = [ key ];
          }, getIteratee);
          var invoke = baseRest(baseInvoke);
          function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
          }
          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
          }
          function mapKeys(object, iteratee) {
            var result = {};
            iteratee = getIteratee(iteratee, 3);
            baseForOwn(object, function(value, key, object) {
              baseAssignValue(result, iteratee(value, key, object), value);
            });
            return result;
          }
          function mapValues(object, iteratee) {
            var result = {};
            iteratee = getIteratee(iteratee, 3);
            baseForOwn(object, function(value, key, object) {
              baseAssignValue(result, key, iteratee(value, key, object));
            });
            return result;
          }
          var merge = createAssigner(function(object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
          });
          var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
          });
          var omit = flatRest(function(object, paths) {
            var result = {};
            if (null == object) return result;
            var isDeep = false;
            paths = arrayMap(paths, function(path) {
              path = castPath(path, object);
              isDeep || (isDeep = path.length > 1);
              return path;
            });
            copyObject(object, getAllKeysIn(object), result);
            isDeep && (result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone));
            var length = paths.length;
            while (length--) baseUnset(result, paths[length]);
            return result;
          });
          function omitBy(object, predicate) {
            return pickBy(object, negate(getIteratee(predicate)));
          }
          var pick = flatRest(function(object, paths) {
            return null == object ? {} : basePick(object, paths);
          });
          function pickBy(object, predicate) {
            if (null == object) return {};
            var props = arrayMap(getAllKeysIn(object), function(prop) {
              return [ prop ];
            });
            predicate = getIteratee(predicate);
            return basePickBy(object, props, function(value, path) {
              return predicate(value, path[0]);
            });
          }
          function result(object, path, defaultValue) {
            path = castPath(path, object);
            var index = -1, length = path.length;
            if (!length) {
              length = 1;
              object = undefined;
            }
            while (++index < length) {
              var value = null == object ? undefined : object[toKey(path[index])];
              if (value === undefined) {
                index = length;
                value = defaultValue;
              }
              object = isFunction(value) ? value.call(object) : value;
            }
            return object;
          }
          function set(object, path, value) {
            return null == object ? object : baseSet(object, path, value);
          }
          function setWith(object, path, value, customizer) {
            customizer = "function" == typeof customizer ? customizer : undefined;
            return null == object ? object : baseSet(object, path, value, customizer);
          }
          var toPairs = createToPairs(keys);
          var toPairsIn = createToPairs(keysIn);
          function transform(object, iteratee, accumulator) {
            var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
            iteratee = getIteratee(iteratee, 4);
            if (null == accumulator) {
              var Ctor = object && object.constructor;
              accumulator = isArrLike ? isArr ? new Ctor() : [] : isObject(object) && isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            }
            (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
              return iteratee(accumulator, value, index, object);
            });
            return accumulator;
          }
          function unset(object, path) {
            return null == object || baseUnset(object, path);
          }
          function update(object, path, updater) {
            return null == object ? object : baseUpdate(object, path, castFunction(updater));
          }
          function updateWith(object, path, updater, customizer) {
            customizer = "function" == typeof customizer ? customizer : undefined;
            return null == object ? object : baseUpdate(object, path, castFunction(updater), customizer);
          }
          function values(object) {
            return null == object ? [] : baseValues(object, keys(object));
          }
          function valuesIn(object) {
            return null == object ? [] : baseValues(object, keysIn(object));
          }
          function clamp(number, lower, upper) {
            if (upper === undefined) {
              upper = lower;
              lower = undefined;
            }
            if (upper !== undefined) {
              upper = toNumber(upper);
              upper = upper === upper ? upper : 0;
            }
            if (lower !== undefined) {
              lower = toNumber(lower);
              lower = lower === lower ? lower : 0;
            }
            return baseClamp(toNumber(number), lower, upper);
          }
          function inRange(number, start, end) {
            start = toFinite(start);
            if (end === undefined) {
              end = start;
              start = 0;
            } else end = toFinite(end);
            number = toNumber(number);
            return baseInRange(number, start, end);
          }
          function random(lower, upper, floating) {
            floating && "boolean" != typeof floating && isIterateeCall(lower, upper, floating) && (upper = floating = undefined);
            if (floating === undefined) if ("boolean" == typeof upper) {
              floating = upper;
              upper = undefined;
            } else if ("boolean" == typeof lower) {
              floating = lower;
              lower = undefined;
            }
            if (lower === undefined && upper === undefined) {
              lower = 0;
              upper = 1;
            } else {
              lower = toFinite(lower);
              if (upper === undefined) {
                upper = lower;
                lower = 0;
              } else upper = toFinite(upper);
            }
            if (lower > upper) {
              var temp = lower;
              lower = upper;
              upper = temp;
            }
            if (floating || lower % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
            }
            return baseRandom(lower, upper);
          }
          var camelCase = createCompounder(function(result, word, index) {
            word = word.toLowerCase();
            return result + (index ? capitalize(word) : word);
          });
          function capitalize(string) {
            return upperFirst(toString(string).toLowerCase());
          }
          function deburr(string) {
            string = toString(string);
            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
          }
          function endsWith(string, target, position) {
            string = toString(string);
            target = baseToString(target);
            var length = string.length;
            position = position === undefined ? length : baseClamp(toInteger(position), 0, length);
            var end = position;
            position -= target.length;
            return position >= 0 && string.slice(position, end) == target;
          }
          function escape(string) {
            string = toString(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
          }
          function escapeRegExp(string) {
            string = toString(string);
            return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
          }
          var kebabCase = createCompounder(function(result, word, index) {
            return result + (index ? "-" : "") + word.toLowerCase();
          });
          var lowerCase = createCompounder(function(result, word, index) {
            return result + (index ? " " : "") + word.toLowerCase();
          });
          var lowerFirst = createCaseFirst("toLowerCase");
          function pad(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            if (!length || strLength >= length) return string;
            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
          }
          function padEnd(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
          }
          function padStart(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
          }
          function parseInt(string, radix, guard) {
            guard || null == radix ? radix = 0 : radix && (radix = +radix);
            return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
          }
          function repeat(string, n, guard) {
            n = (guard ? isIterateeCall(string, n, guard) : n === undefined) ? 1 : toInteger(n);
            return baseRepeat(toString(string), n);
          }
          function replace() {
            var args = arguments, string = toString(args[0]);
            return args.length < 3 ? string : string.replace(args[1], args[2]);
          }
          var snakeCase = createCompounder(function(result, word, index) {
            return result + (index ? "_" : "") + word.toLowerCase();
          });
          function split(string, separator, limit) {
            limit && "number" != typeof limit && isIterateeCall(string, separator, limit) && (separator = limit = undefined);
            limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) return [];
            string = toString(string);
            if (string && ("string" == typeof separator || null != separator && !isRegExp(separator))) {
              separator = baseToString(separator);
              if (!separator && hasUnicode(string)) return castSlice(stringToArray(string), 0, limit);
            }
            return string.split(separator, limit);
          }
          var startCase = createCompounder(function(result, word, index) {
            return result + (index ? " " : "") + upperFirst(word);
          });
          function startsWith(string, target, position) {
            string = toString(string);
            position = null == position ? 0 : baseClamp(toInteger(position), 0, string.length);
            target = baseToString(target);
            return string.slice(position, position + target.length) == target;
          }
          function template(string, options, guard) {
            var settings = lodash.templateSettings;
            guard && isIterateeCall(string, options, guard) && (options = undefined);
            string = toString(string);
            options = assignInWith({}, options, settings, customDefaultsAssignIn);
            var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
            var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
            var reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
            var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
            string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              interpolateValue || (interpolateValue = esTemplateValue);
              source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              interpolateValue && (source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'");
              index = offset + match.length;
              return match;
            });
            source += "';\n";
            var variable = hasOwnProperty.call(options, "variable") && options.variable;
            if (variable) {
              if (reForbiddenIdentifierChars.test(variable)) throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
            } else source = "with (obj) {\n" + source + "\n}\n";
            source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
            source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
            var result = attempt(function() {
              return Function(importsKeys, sourceURL + "return " + source).apply(undefined, importsValues);
            });
            result.source = source;
            if (isError(result)) throw result;
            return result;
          }
          function toLower(value) {
            return toString(value).toLowerCase();
          }
          function toUpper(value) {
            return toString(value).toUpperCase();
          }
          function trim(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined)) return baseTrim(string);
            if (!string || !(chars = baseToString(chars))) return string;
            var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start, end).join("");
          }
          function trimEnd(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined)) return string.slice(0, trimmedEndIndex(string) + 1);
            if (!string || !(chars = baseToString(chars))) return string;
            var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join("");
          }
          function trimStart(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined)) return string.replace(reTrimStart, "");
            if (!string || !(chars = baseToString(chars))) return string;
            var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start).join("");
          }
          function truncate(string, options) {
            var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
            if (isObject(options)) {
              var separator = "separator" in options ? options.separator : separator;
              length = "length" in options ? toInteger(options.length) : length;
              omission = "omission" in options ? baseToString(options.omission) : omission;
            }
            string = toString(string);
            var strLength = string.length;
            if (hasUnicode(string)) {
              var strSymbols = stringToArray(string);
              strLength = strSymbols.length;
            }
            if (length >= strLength) return string;
            var end = length - stringSize(omission);
            if (end < 1) return omission;
            var result = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
            if (separator === undefined) return result + omission;
            strSymbols && (end += result.length - end);
            if (isRegExp(separator)) {
              if (string.slice(end).search(separator)) {
                var match, substring = result;
                separator.global || (separator = RegExp(separator.source, toString(reFlags.exec(separator)) + "g"));
                separator.lastIndex = 0;
                while (match = separator.exec(substring)) var newEnd = match.index;
                result = result.slice(0, newEnd === undefined ? end : newEnd);
              }
            } else if (string.indexOf(baseToString(separator), end) != end) {
              var index = result.lastIndexOf(separator);
              index > -1 && (result = result.slice(0, index));
            }
            return result + omission;
          }
          function unescape(string) {
            string = toString(string);
            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
          }
          var upperCase = createCompounder(function(result, word, index) {
            return result + (index ? " " : "") + word.toUpperCase();
          });
          var upperFirst = createCaseFirst("toUpperCase");
          function words(string, pattern, guard) {
            string = toString(string);
            pattern = guard ? undefined : pattern;
            if (pattern === undefined) return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
            return string.match(pattern) || [];
          }
          var attempt = baseRest(function(func, args) {
            try {
              return apply(func, undefined, args);
            } catch (e) {
              return isError(e) ? e : new Error(e);
            }
          });
          var bindAll = flatRest(function(object, methodNames) {
            arrayEach(methodNames, function(key) {
              key = toKey(key);
              baseAssignValue(object, key, bind(object[key], object));
            });
            return object;
          });
          function cond(pairs) {
            var length = null == pairs ? 0 : pairs.length, toIteratee = getIteratee();
            pairs = length ? arrayMap(pairs, function(pair) {
              if ("function" != typeof pair[1]) throw new TypeError(FUNC_ERROR_TEXT);
              return [ toIteratee(pair[0]), pair[1] ];
            }) : [];
            return baseRest(function(args) {
              var index = -1;
              while (++index < length) {
                var pair = pairs[index];
                if (apply(pair[0], this, args)) return apply(pair[1], this, args);
              }
            });
          }
          function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
          }
          function constant(value) {
            return function() {
              return value;
            };
          }
          function defaultTo(value, defaultValue) {
            return null == value || value !== value ? defaultValue : value;
          }
          var flow = createFlow();
          var flowRight = createFlow(true);
          function identity(value) {
            return value;
          }
          function iteratee(func) {
            return baseIteratee("function" == typeof func ? func : baseClone(func, CLONE_DEEP_FLAG));
          }
          function matches(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
          }
          function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
          }
          var method = baseRest(function(path, args) {
            return function(object) {
              return baseInvoke(object, path, args);
            };
          });
          var methodOf = baseRest(function(object, args) {
            return function(path) {
              return baseInvoke(object, path, args);
            };
          });
          function mixin(object, source, options) {
            var props = keys(source), methodNames = baseFunctions(source, props);
            if (null == options && !(isObject(source) && (methodNames.length || !props.length))) {
              options = source;
              source = object;
              object = this;
              methodNames = baseFunctions(source, keys(source));
            }
            var chain = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
            arrayEach(methodNames, function(methodName) {
              var func = source[methodName];
              object[methodName] = func;
              isFunc && (object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain || chainAll) {
                  var result = object(this.__wrapped__), actions = result.__actions__ = copyArray(this.__actions__);
                  actions.push({
                    func: func,
                    args: arguments,
                    thisArg: object
                  });
                  result.__chain__ = chainAll;
                  return result;
                }
                return func.apply(object, arrayPush([ this.value() ], arguments));
              });
            });
            return object;
          }
          function noConflict() {
            root._ === this && (root._ = oldDash);
            return this;
          }
          function noop() {}
          function nthArg(n) {
            n = toInteger(n);
            return baseRest(function(args) {
              return baseNth(args, n);
            });
          }
          var over = createOver(arrayMap);
          var overEvery = createOver(arrayEvery);
          var overSome = createOver(arraySome);
          function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
          }
          function propertyOf(object) {
            return function(path) {
              return null == object ? undefined : baseGet(object, path);
            };
          }
          var range = createRange();
          var rangeRight = createRange(true);
          function stubArray() {
            return [];
          }
          function stubFalse() {
            return false;
          }
          function stubObject() {
            return {};
          }
          function stubString() {
            return "";
          }
          function stubTrue() {
            return true;
          }
          function times(n, iteratee) {
            n = toInteger(n);
            if (n < 1 || n > MAX_SAFE_INTEGER) return [];
            var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
            iteratee = getIteratee(iteratee);
            n -= MAX_ARRAY_LENGTH;
            var result = baseTimes(length, iteratee);
            while (++index < n) iteratee(index);
            return result;
          }
          function toPath(value) {
            if (isArray(value)) return arrayMap(value, toKey);
            return isSymbol(value) ? [ value ] : copyArray(stringToPath(toString(value)));
          }
          function uniqueId(prefix) {
            var id = ++idCounter;
            return toString(prefix) + id;
          }
          var add = createMathOperation(function(augend, addend) {
            return augend + addend;
          }, 0);
          var ceil = createRound("ceil");
          var divide = createMathOperation(function(dividend, divisor) {
            return dividend / divisor;
          }, 1);
          var floor = createRound("floor");
          function max(array) {
            return array && array.length ? baseExtremum(array, identity, baseGt) : undefined;
          }
          function maxBy(array, iteratee) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined;
          }
          function mean(array) {
            return baseMean(array, identity);
          }
          function meanBy(array, iteratee) {
            return baseMean(array, getIteratee(iteratee, 2));
          }
          function min(array) {
            return array && array.length ? baseExtremum(array, identity, baseLt) : undefined;
          }
          function minBy(array, iteratee) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined;
          }
          var multiply = createMathOperation(function(multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);
          var round = createRound("round");
          var subtract = createMathOperation(function(minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);
          function sum(array) {
            return array && array.length ? baseSum(array, identity) : 0;
          }
          function sumBy(array, iteratee) {
            return array && array.length ? baseSum(array, getIteratee(iteratee, 2)) : 0;
          }
          lodash.after = after;
          lodash.ary = ary;
          lodash.assign = assign;
          lodash.assignIn = assignIn;
          lodash.assignInWith = assignInWith;
          lodash.assignWith = assignWith;
          lodash.at = at;
          lodash.before = before;
          lodash.bind = bind;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey;
          lodash.castArray = castArray;
          lodash.chain = chain;
          lodash.chunk = chunk;
          lodash.compact = compact;
          lodash.concat = concat;
          lodash.cond = cond;
          lodash.conforms = conforms;
          lodash.constant = constant;
          lodash.countBy = countBy;
          lodash.create = create;
          lodash.curry = curry;
          lodash.curryRight = curryRight;
          lodash.debounce = debounce;
          lodash.defaults = defaults;
          lodash.defaultsDeep = defaultsDeep;
          lodash.defer = defer;
          lodash.delay = delay;
          lodash.difference = difference;
          lodash.differenceBy = differenceBy;
          lodash.differenceWith = differenceWith;
          lodash.drop = drop;
          lodash.dropRight = dropRight;
          lodash.dropRightWhile = dropRightWhile;
          lodash.dropWhile = dropWhile;
          lodash.fill = fill;
          lodash.filter = filter;
          lodash.flatMap = flatMap;
          lodash.flatMapDeep = flatMapDeep;
          lodash.flatMapDepth = flatMapDepth;
          lodash.flatten = flatten;
          lodash.flattenDeep = flattenDeep;
          lodash.flattenDepth = flattenDepth;
          lodash.flip = flip;
          lodash.flow = flow;
          lodash.flowRight = flowRight;
          lodash.fromPairs = fromPairs;
          lodash.functions = functions;
          lodash.functionsIn = functionsIn;
          lodash.groupBy = groupBy;
          lodash.initial = initial;
          lodash.intersection = intersection;
          lodash.intersectionBy = intersectionBy;
          lodash.intersectionWith = intersectionWith;
          lodash.invert = invert;
          lodash.invertBy = invertBy;
          lodash.invokeMap = invokeMap;
          lodash.iteratee = iteratee;
          lodash.keyBy = keyBy;
          lodash.keys = keys;
          lodash.keysIn = keysIn;
          lodash.map = map;
          lodash.mapKeys = mapKeys;
          lodash.mapValues = mapValues;
          lodash.matches = matches;
          lodash.matchesProperty = matchesProperty;
          lodash.memoize = memoize;
          lodash.merge = merge;
          lodash.mergeWith = mergeWith;
          lodash.method = method;
          lodash.methodOf = methodOf;
          lodash.mixin = mixin;
          lodash.negate = negate;
          lodash.nthArg = nthArg;
          lodash.omit = omit;
          lodash.omitBy = omitBy;
          lodash.once = once;
          lodash.orderBy = orderBy;
          lodash.over = over;
          lodash.overArgs = overArgs;
          lodash.overEvery = overEvery;
          lodash.overSome = overSome;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.partition = partition;
          lodash.pick = pick;
          lodash.pickBy = pickBy;
          lodash.property = property;
          lodash.propertyOf = propertyOf;
          lodash.pull = pull;
          lodash.pullAll = pullAll;
          lodash.pullAllBy = pullAllBy;
          lodash.pullAllWith = pullAllWith;
          lodash.pullAt = pullAt;
          lodash.range = range;
          lodash.rangeRight = rangeRight;
          lodash.rearg = rearg;
          lodash.reject = reject;
          lodash.remove = remove;
          lodash.rest = rest;
          lodash.reverse = reverse;
          lodash.sampleSize = sampleSize;
          lodash.set = set;
          lodash.setWith = setWith;
          lodash.shuffle = shuffle;
          lodash.slice = slice;
          lodash.sortBy = sortBy;
          lodash.sortedUniq = sortedUniq;
          lodash.sortedUniqBy = sortedUniqBy;
          lodash.split = split;
          lodash.spread = spread;
          lodash.tail = tail;
          lodash.take = take;
          lodash.takeRight = takeRight;
          lodash.takeRightWhile = takeRightWhile;
          lodash.takeWhile = takeWhile;
          lodash.tap = tap;
          lodash.throttle = throttle;
          lodash.thru = thru;
          lodash.toArray = toArray;
          lodash.toPairs = toPairs;
          lodash.toPairsIn = toPairsIn;
          lodash.toPath = toPath;
          lodash.toPlainObject = toPlainObject;
          lodash.transform = transform;
          lodash.unary = unary;
          lodash.union = union;
          lodash.unionBy = unionBy;
          lodash.unionWith = unionWith;
          lodash.uniq = uniq;
          lodash.uniqBy = uniqBy;
          lodash.uniqWith = uniqWith;
          lodash.unset = unset;
          lodash.unzip = unzip;
          lodash.unzipWith = unzipWith;
          lodash.update = update;
          lodash.updateWith = updateWith;
          lodash.values = values;
          lodash.valuesIn = valuesIn;
          lodash.without = without;
          lodash.words = words;
          lodash.wrap = wrap;
          lodash.xor = xor;
          lodash.xorBy = xorBy;
          lodash.xorWith = xorWith;
          lodash.zip = zip;
          lodash.zipObject = zipObject;
          lodash.zipObjectDeep = zipObjectDeep;
          lodash.zipWith = zipWith;
          lodash.entries = toPairs;
          lodash.entriesIn = toPairsIn;
          lodash.extend = assignIn;
          lodash.extendWith = assignInWith;
          mixin(lodash, lodash);
          lodash.add = add;
          lodash.attempt = attempt;
          lodash.camelCase = camelCase;
          lodash.capitalize = capitalize;
          lodash.ceil = ceil;
          lodash.clamp = clamp;
          lodash.clone = clone;
          lodash.cloneDeep = cloneDeep;
          lodash.cloneDeepWith = cloneDeepWith;
          lodash.cloneWith = cloneWith;
          lodash.conformsTo = conformsTo;
          lodash.deburr = deburr;
          lodash.defaultTo = defaultTo;
          lodash.divide = divide;
          lodash.endsWith = endsWith;
          lodash.eq = eq;
          lodash.escape = escape;
          lodash.escapeRegExp = escapeRegExp;
          lodash.every = every;
          lodash.find = find;
          lodash.findIndex = findIndex;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.floor = floor;
          lodash.forEach = forEach;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.get = get;
          lodash.gt = gt;
          lodash.gte = gte;
          lodash.has = has;
          lodash.hasIn = hasIn;
          lodash.head = head;
          lodash.identity = identity;
          lodash.includes = includes;
          lodash.indexOf = indexOf;
          lodash.inRange = inRange;
          lodash.invoke = invoke;
          lodash.isArguments = isArguments;
          lodash.isArray = isArray;
          lodash.isArrayBuffer = isArrayBuffer;
          lodash.isArrayLike = isArrayLike;
          lodash.isArrayLikeObject = isArrayLikeObject;
          lodash.isBoolean = isBoolean;
          lodash.isBuffer = isBuffer;
          lodash.isDate = isDate;
          lodash.isElement = isElement;
          lodash.isEmpty = isEmpty;
          lodash.isEqual = isEqual;
          lodash.isEqualWith = isEqualWith;
          lodash.isError = isError;
          lodash.isFinite = isFinite;
          lodash.isFunction = isFunction;
          lodash.isInteger = isInteger;
          lodash.isLength = isLength;
          lodash.isMap = isMap;
          lodash.isMatch = isMatch;
          lodash.isMatchWith = isMatchWith;
          lodash.isNaN = isNaN;
          lodash.isNative = isNative;
          lodash.isNil = isNil;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber;
          lodash.isObject = isObject;
          lodash.isObjectLike = isObjectLike;
          lodash.isPlainObject = isPlainObject;
          lodash.isRegExp = isRegExp;
          lodash.isSafeInteger = isSafeInteger;
          lodash.isSet = isSet;
          lodash.isString = isString;
          lodash.isSymbol = isSymbol;
          lodash.isTypedArray = isTypedArray;
          lodash.isUndefined = isUndefined;
          lodash.isWeakMap = isWeakMap;
          lodash.isWeakSet = isWeakSet;
          lodash.join = join;
          lodash.kebabCase = kebabCase;
          lodash.last = last;
          lodash.lastIndexOf = lastIndexOf;
          lodash.lowerCase = lowerCase;
          lodash.lowerFirst = lowerFirst;
          lodash.lt = lt;
          lodash.lte = lte;
          lodash.max = max;
          lodash.maxBy = maxBy;
          lodash.mean = mean;
          lodash.meanBy = meanBy;
          lodash.min = min;
          lodash.minBy = minBy;
          lodash.stubArray = stubArray;
          lodash.stubFalse = stubFalse;
          lodash.stubObject = stubObject;
          lodash.stubString = stubString;
          lodash.stubTrue = stubTrue;
          lodash.multiply = multiply;
          lodash.nth = nth;
          lodash.noConflict = noConflict;
          lodash.noop = noop;
          lodash.now = now;
          lodash.pad = pad;
          lodash.padEnd = padEnd;
          lodash.padStart = padStart;
          lodash.parseInt = parseInt;
          lodash.random = random;
          lodash.reduce = reduce;
          lodash.reduceRight = reduceRight;
          lodash.repeat = repeat;
          lodash.replace = replace;
          lodash.result = result;
          lodash.round = round;
          lodash.runInContext = runInContext;
          lodash.sample = sample;
          lodash.size = size;
          lodash.snakeCase = snakeCase;
          lodash.some = some;
          lodash.sortedIndex = sortedIndex;
          lodash.sortedIndexBy = sortedIndexBy;
          lodash.sortedIndexOf = sortedIndexOf;
          lodash.sortedLastIndex = sortedLastIndex;
          lodash.sortedLastIndexBy = sortedLastIndexBy;
          lodash.sortedLastIndexOf = sortedLastIndexOf;
          lodash.startCase = startCase;
          lodash.startsWith = startsWith;
          lodash.subtract = subtract;
          lodash.sum = sum;
          lodash.sumBy = sumBy;
          lodash.template = template;
          lodash.times = times;
          lodash.toFinite = toFinite;
          lodash.toInteger = toInteger;
          lodash.toLength = toLength;
          lodash.toLower = toLower;
          lodash.toNumber = toNumber;
          lodash.toSafeInteger = toSafeInteger;
          lodash.toString = toString;
          lodash.toUpper = toUpper;
          lodash.trim = trim;
          lodash.trimEnd = trimEnd;
          lodash.trimStart = trimStart;
          lodash.truncate = truncate;
          lodash.unescape = unescape;
          lodash.uniqueId = uniqueId;
          lodash.upperCase = upperCase;
          lodash.upperFirst = upperFirst;
          lodash.each = forEach;
          lodash.eachRight = forEachRight;
          lodash.first = head;
          mixin(lodash, function() {
            var source = {};
            baseForOwn(lodash, function(func, methodName) {
              hasOwnProperty.call(lodash.prototype, methodName) || (source[methodName] = func);
            });
            return source;
          }(), {
            chain: false
          });
          lodash.VERSION = VERSION;
          arrayEach([ "bind", "bindKey", "curry", "curryRight", "partial", "partialRight" ], function(methodName) {
            lodash[methodName].placeholder = lodash;
          });
          arrayEach([ "drop", "take" ], function(methodName, index) {
            LazyWrapper.prototype[methodName] = function(n) {
              n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
              var result = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
              result.__filtered__ ? result.__takeCount__ = nativeMin(n, result.__takeCount__) : result.__views__.push({
                size: nativeMin(n, MAX_ARRAY_LENGTH),
                type: methodName + (result.__dir__ < 0 ? "Right" : "")
              });
              return result;
            };
            LazyWrapper.prototype[methodName + "Right"] = function(n) {
              return this.reverse()[methodName](n).reverse();
            };
          });
          arrayEach([ "filter", "map", "takeWhile" ], function(methodName, index) {
            var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function(iteratee) {
              var result = this.clone();
              result.__iteratees__.push({
                iteratee: getIteratee(iteratee, 3),
                type: type
              });
              result.__filtered__ = result.__filtered__ || isFilter;
              return result;
            };
          });
          arrayEach([ "head", "last" ], function(methodName, index) {
            var takeName = "take" + (index ? "Right" : "");
            LazyWrapper.prototype[methodName] = function() {
              return this[takeName](1).value()[0];
            };
          });
          arrayEach([ "initial", "tail" ], function(methodName, index) {
            var dropName = "drop" + (index ? "" : "Right");
            LazyWrapper.prototype[methodName] = function() {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });
          LazyWrapper.prototype.compact = function() {
            return this.filter(identity);
          };
          LazyWrapper.prototype.find = function(predicate) {
            return this.filter(predicate).head();
          };
          LazyWrapper.prototype.findLast = function(predicate) {
            return this.reverse().find(predicate);
          };
          LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
            if ("function" == typeof path) return new LazyWrapper(this);
            return this.map(function(value) {
              return baseInvoke(value, path, args);
            });
          });
          LazyWrapper.prototype.reject = function(predicate) {
            return this.filter(negate(getIteratee(predicate)));
          };
          LazyWrapper.prototype.slice = function(start, end) {
            start = toInteger(start);
            var result = this;
            if (result.__filtered__ && (start > 0 || end < 0)) return new LazyWrapper(result);
            start < 0 ? result = result.takeRight(-start) : start && (result = result.drop(start));
            if (end !== undefined) {
              end = toInteger(end);
              result = end < 0 ? result.dropRight(-end) : result.take(end - start);
            }
            return result;
          };
          LazyWrapper.prototype.takeRightWhile = function(predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };
          LazyWrapper.prototype.toArray = function() {
            return this.take(MAX_ARRAY_LENGTH);
          };
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + ("last" == methodName ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) return;
            lodash.prototype[methodName] = function() {
              var value = this.__wrapped__, args = isTaker ? [ 1 ] : arguments, isLazy = value instanceof LazyWrapper, iteratee = args[0], useLazy = isLazy || isArray(value);
              var interceptor = function(value) {
                var result = lodashFunc.apply(lodash, arrayPush([ value ], args));
                return isTaker && chainAll ? result[0] : result;
              };
              useLazy && checkIteratee && "function" == typeof iteratee && 1 != iteratee.length && (isLazy = useLazy = false);
              var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result = func.apply(value, args);
                result.__actions__.push({
                  func: thru,
                  args: [ interceptor ],
                  thisArg: undefined
                });
                return new LodashWrapper(result, chainAll);
              }
              if (isUnwrapped && onlyLazy) return func.apply(this, args);
              result = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result.value()[0] : result.value() : result;
            };
          });
          arrayEach([ "pop", "push", "shift", "sort", "splice", "unshift" ], function(methodName) {
            var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function() {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray(value) ? value : [], args);
              }
              return this[chainName](function(value) {
                return func.apply(isArray(value) ? value : [], args);
              });
            };
          });
          baseForOwn(LazyWrapper.prototype, function(func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name + "";
              hasOwnProperty.call(realNames, key) || (realNames[key] = []);
              realNames[key].push({
                name: methodName,
                func: lodashFunc
              });
            }
          });
          realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [ {
            name: "wrapper",
            func: undefined
          } ];
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;
          lodash.prototype.at = wrapperAt;
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.commit = wrapperCommit;
          lodash.prototype.next = wrapperNext;
          lodash.prototype.plant = wrapperPlant;
          lodash.prototype.reverse = wrapperReverse;
          lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
          lodash.prototype.first = lodash.prototype.head;
          symIterator && (lodash.prototype[symIterator] = wrapperToIterator);
          return lodash;
        };
        var _ = runInContext();
        if ("function" == typeof define && "object" == typeof define.amd && define.amd) {
          root._ = _;
          define(function() {
            return _;
          });
        } else if (freeModule) {
          (freeModule.exports = _)._ = _;
          freeExports._ = _;
        } else root._ = _;
      }).call(this);
    }).call(this, "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {});
  }, {} ],
  AdapterMgr: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "c7c88EclmxBRbUUgNKeHBgH", "AdapterMgr");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var AdapterMgr_1;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AdapterType = void 0;
    let flagOffset = 0;
    const _None = 1 << flagOffset++;
    const _Left = 1 << flagOffset++;
    const _Right = 1 << flagOffset++;
    const _Top = 1 << flagOffset++;
    const _Bottom = 1 << flagOffset++;
    const _StretchWidth = _Left | _Right;
    const _StretchHeight = _Top | _Bottom;
    const _FullWidth = 1 << flagOffset++;
    const _FullHeight = 1 << flagOffset++;
    const _Final = 1 << flagOffset++;
    var AdapterType;
    (function(AdapterType) {
      AdapterType[AdapterType["Top"] = _Top] = "Top";
      AdapterType[AdapterType["Bottom"] = _Bottom] = "Bottom";
      AdapterType[AdapterType["Left"] = _Left] = "Left";
      AdapterType[AdapterType["Right"] = _Right] = "Right";
      AdapterType[AdapterType["StretchWidth"] = _StretchWidth] = "StretchWidth";
      AdapterType[AdapterType["StretchHeight"] = _StretchHeight] = "StretchHeight";
      AdapterType[AdapterType["FullWidth"] = _FullWidth] = "FullWidth";
      AdapterType[AdapterType["FullHeight"] = _FullHeight] = "FullHeight";
    })(AdapterType = exports.AdapterType || (exports.AdapterType = {}));
    const {ccclass: ccclass, property: property} = cc._decorator;
    let AdapterMgr = AdapterMgr_1 = class AdapterMgr {
      static get inst() {
        if (null == this._instance) {
          this._instance = new AdapterMgr_1();
          this._instance.visibleSize = cc.view.getVisibleSize();
          console.log(`visiable size: ${this._instance.visibleSize}`);
        }
        return this._instance;
      }
      adapteByType(flag, node, distance = 0) {
        let tFlag = _Final;
        while (tFlag > 0) {
          tFlag & flag && this._doAdapte(tFlag, node, distance);
          tFlag >>= 1;
        }
        let widget = node.getComponent(cc.Widget);
        widget.target = cc.find("Canvas");
        widget.updateAlignment();
      }
      _doAdapte(flag, node, distance = 0) {
        let widget = node.getComponent(cc.Widget);
        widget || (widget = node.addComponent(cc.Widget));
        switch (flag) {
         case _None:
          break;

         case _Left:
          widget.isAlignLeft = true;
          widget.isAbsoluteLeft = true;
          widget.left = distance || 0;
          break;

         case _Right:
          widget.isAlignRight = true;
          widget.isAbsoluteRight = true;
          widget.right = distance || 0;
          break;

         case _Top:
          if (cc.sys.platform === cc.sys.WECHAT_GAME) {
            let menuInfo = window["wx"].getMenuButtonBoundingClientRect();
            let systemInfo = window["wx"].getSystemInfoSync();
            distance += cc.find("Canvas").height * (menuInfo.top / systemInfo.screenHeight);
          }
          widget.isAlignTop = true;
          widget.isAbsoluteTop = true;
          widget.top = distance || 0;
          break;

         case _Bottom:
          widget.isAlignBottom = true;
          widget.isAbsoluteBottom = true;
          widget.bottom = distance || 0;
          break;

         case _FullWidth:
          node.height /= node.width / this.visibleSize.width;
          node.width = this.visibleSize.width;
          break;

         case _FullHeight:
          node.width /= node.height / this.visibleSize.height;
          node.height = this.visibleSize.height;
        }
      }
      removeAdaptater(node) {
        node.getComponent(cc.Widget) && node.removeComponent(cc.Widget);
      }
    };
    AdapterMgr._instance = null;
    AdapterMgr = AdapterMgr_1 = __decorate([ ccclass ], AdapterMgr);
    exports.default = AdapterMgr;
    cc._RF.pop();
  }, {} ],
  AutoFindPath: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "8b2cbBZJ+VGGaj2+N51QmgM", "AutoFindPath");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.AutoFindPath = exports.lands = exports.models = void 0;
    var PathPointData = function() {
      function PathPointData(x, y) {
        this.x = 0;
        this.y = 0;
        this.F = 0;
        this.G = 0;
        this.H = 0;
        this.parent = null;
        this.K = lands.normal;
        this.x = x;
        this.y = y;
      }
      return PathPointData;
    }();
    var models;
    (function(models) {
      models[models["normal"] = 0] = "normal";
      models[models["tilt"] = 1] = "tilt";
    })(models = exports.models || (exports.models = {}));
    var lands;
    (function(lands) {
      lands[lands["normal"] = 1] = "normal";
      lands[lands["hard"] = 2] = "hard";
    })(lands = exports.lands || (exports.lands = {}));
    var AutoFindPath = function() {
      function AutoFindPath(mapData, obstacles) {
        this.model = models.tilt;
        this.mapTable = new Map();
        this.openList = [];
        this.openListMap = new Map();
        this.fixClosedListMap = new Map();
        this.closedListMap = new Map();
        this.bronPoint = null;
        this.targetPoint = null;
        this.nowPoint = null;
        this.mapData = null;
        this.searchLimit = 2e3;
        mapData.searchLimit > 0 && (this.searchLimit = mapData.searchLimit);
        mapData.x = mapData.x - mapData.width * mapData.anchorX;
        mapData.y = mapData.y - mapData.height * mapData.anchorY;
        this.mapData = mapData;
        for (var i = 0, i1 = Math.ceil(mapData.width / this.mapData.gridLength); i < i1; ++i) for (var j = 0, j1 = Math.ceil(mapData.height / this.mapData.gridLength); j < j1; ++j) this.mapTable.set(i.toString() + AutoFindPath.sep + j.toString(), new PathPointData(i, j));
        obstacles && this.updateMap.apply(this, obstacles);
        null === AutoFindPath._ins && (AutoFindPath._ins = this);
      }
      AutoFindPath.formatToMapData = function(gameObject, gridLength) {
        return {
          anchorY: gameObject.anchorY,
          anchorX: gameObject.anchorX,
          height: gameObject.height,
          width: gameObject.width,
          x: gameObject.x,
          y: gameObject.y,
          gridLength: gridLength,
          angle: -gameObject.angle
        };
      };
      AutoFindPath.getKey = function(p) {
        return p.x.toString() + AutoFindPath.sep + p.y.toString();
      };
      AutoFindPath.prototype.addToOpenList = function(v2) {
        var p = AutoFindPath.getKey(v2);
        if (void 0 === this.mapTable.get(p)) throw new Error("this point not in map");
        if (this.openListMap.get(p)) {
          var oldParent = v2.parent;
          var oldF = v2.F;
          v2.parent = this.nowPoint;
          this.F(v2);
          if (v2.F > oldF) {
            v2.parent = oldParent;
            this.F(v2);
            return;
          }
          return;
        }
        v2.parent = this.nowPoint;
        this.F(v2);
        this.openList.push(v2);
        this.openListMap.set(p, this.mapTable.get(p));
      };
      AutoFindPath.prototype.isInClosedList = function(p) {
        var key = AutoFindPath.getKey(p);
        return !!(this.fixClosedListMap.get(key) || this.closedListMap.get(key));
      };
      AutoFindPath.prototype.removeMinFFromOpenList = function() {
        this.openList.sort(function(a, b) {
          if (a.F > b.F) return -1;
          return 1;
        });
        var v2 = this.openList.pop();
        v2 && this.removeFromOpenList(v2);
        return v2;
      };
      AutoFindPath.prototype.removeFromOpenList = function(v2) {
        var p = AutoFindPath.getKey(v2);
        if (!this.openListMap.has(p)) throw new Error("not in openList");
        this.openListMap.delete(p);
      };
      AutoFindPath.prototype.addToClosedList = function(v2) {
        var p = AutoFindPath.getKey(v2);
        if (void 0 === this.mapTable.get(p)) throw new Error("this point not in map");
        if (this.closedListMap.get(p)) throw new Error("is in closedList");
        this.closedListMap.set(p, this.mapTable.get(p));
      };
      Object.defineProperty(AutoFindPath, "ins", {
        get: function() {
          return AutoFindPath._ins;
        },
        enumerable: false,
        configurable: true
      });
      AutoFindPath.prototype.getGridPositions = function(nodeData) {
        var vec2s = [];
        var width = nodeData.width;
        var height = nodeData.height;
        if (-90 === nodeData.angle || -270 === nodeData.angle) {
          width += height;
          height = width - height;
          width -= height;
        }
        var minX = nodeData.x - width * nodeData.anchorX;
        var maxX = nodeData.x + width * (1 - nodeData.anchorX);
        var minY = nodeData.y - height * nodeData.anchorY;
        var maxY = nodeData.y + height * (1 - nodeData.anchorY);
        var minPoint = this.getGridPositionRaw({
          x: minX,
          y: minY
        });
        var w = this.getGridPositionRaw({
          x: maxX,
          y: minY
        }).x - minPoint.x + 1;
        var h = this.getGridPositionRaw({
          x: minX,
          y: maxY
        }).y - minPoint.y + 1;
        var startGridX = minPoint.x;
        var startGridY = minPoint.y;
        for (var i = 0, i1 = w; i < i1; ++i) for (var j = 0, j1 = h; j < j1; ++j) {
          var key = (i + startGridX).toString() + AutoFindPath.sep + (startGridY + j).toString();
          if (void 0 === this.mapTable.get(key)) continue;
          vec2s.push(key);
        }
        return vec2s;
      };
      AutoFindPath.prototype.getGridPositionRaw = function(v2) {
        return {
          x: Math.floor((v2.x - this.mapData.x) / this.mapData.gridLength),
          y: Math.floor((v2.y - this.mapData.y) / this.mapData.gridLength)
        };
      };
      AutoFindPath.prototype.getGridPosition = function(v2) {
        return this.mapTable.get(AutoFindPath.getKey(this.getGridPositionRaw(v2)));
      };
      AutoFindPath.prototype.updateMap = function() {
        var obstacles = [];
        for (var _i = 0; _i < arguments.length; _i++) obstacles[_i] = arguments[_i];
        for (var _a = 0, obstacles_1 = obstacles; _a < obstacles_1.length; _a++) {
          var obstacle = obstacles_1[_a];
          if (obstacle.width * obstacle.height < 2) continue;
          for (var _b = 0, _c = this.getGridPositions(obstacle); _b < _c.length; _b++) {
            var gridPositionKey = _c[_b];
            this.fixClosedListMap.set(gridPositionKey, this.mapTable.get(gridPositionKey));
          }
        }
      };
      AutoFindPath.prototype.removeFixObstacle = function() {
        var obstacles = [];
        for (var _i = 0; _i < arguments.length; _i++) obstacles[_i] = arguments[_i];
        for (var _a = 0, obstacles_2 = obstacles; _a < obstacles_2.length; _a++) {
          var obstacle = obstacles_2[_a];
          for (var _b = 0, _c = this.getGridPositions(obstacle); _b < _c.length; _b++) {
            var gridPositionKey = _c[_b];
            this.fixClosedListMap.delete(gridPositionKey);
          }
        }
      };
      AutoFindPath.prototype.removeAllObstacle = function() {
        this.fixClosedListMap.clear();
      };
      AutoFindPath.prototype.autoAddPathPoint = function() {
        var p0 = {
          x: this.nowPoint.x,
          y: this.nowPoint.y + 1
        };
        var p1 = {
          x: this.nowPoint.x + 1,
          y: this.nowPoint.y
        };
        var p2 = {
          x: this.nowPoint.x,
          y: this.nowPoint.y - 1
        };
        var p3 = {
          x: this.nowPoint.x - 1,
          y: this.nowPoint.y
        };
        var maybePoints = [ p0, p1, p2, p3 ];
        if (this.model === models.tilt) {
          this.isInClosedList(p0) || this.isInClosedList(p1) || maybePoints.push({
            x: this.nowPoint.x + 1,
            y: this.nowPoint.y + 1
          });
          this.isInClosedList(p2) || this.isInClosedList(p1) || maybePoints.push({
            x: this.nowPoint.x + 1,
            y: this.nowPoint.y - 1
          });
          this.isInClosedList(p0) || this.isInClosedList(p3) || maybePoints.push({
            x: this.nowPoint.x - 1,
            y: this.nowPoint.y + 1
          });
          this.isInClosedList(p2) || this.isInClosedList(p3) || maybePoints.push({
            x: this.nowPoint.x - 1,
            y: this.nowPoint.y - 1
          });
        }
        var targetPointKey = AutoFindPath.getKey(this.targetPoint);
        for (var _i = 0, maybePoints_1 = maybePoints; _i < maybePoints_1.length; _i++) {
          var point = maybePoints_1[_i];
          var key = AutoFindPath.getKey(point);
          var pathPoint = this.mapTable.get(key);
          if (void 0 === pathPoint) continue;
          this.isInClosedList(pathPoint) && key !== targetPointKey || this.addToOpenList(pathPoint);
        }
      };
      AutoFindPath.prototype.findGridPath = function(bornPoint, targetPoint, model) {
        this.clear();
        this.model = model;
        var p1 = this.getGridPosition(bornPoint);
        var p2 = this.getGridPosition(targetPoint);
        if (!p1 || this.fixClosedListMap.get(AutoFindPath.getKey(p2))) {
          cc.error("\u8d77\u70b9\u6709\u8bef");
          return [];
        }
        if (!p2 || this.fixClosedListMap.get(AutoFindPath.getKey(p2))) {
          cc.error("\u7ec8\u70b9\u6709\u8bef");
          return [];
        }
        this.nowPoint = this.bronPoint = this.mapTable.get(AutoFindPath.getKey(p1));
        this.targetPoint = this.mapTable.get(AutoFindPath.getKey(p2));
        var paths = [];
        if (AutoFindPath.getKey(p1) === AutoFindPath.getKey(p2)) return paths;
        var maxSearchAmount = 0;
        while (!this.closedListMap.get(AutoFindPath.getKey(this.targetPoint))) {
          this.addToClosedList(this.nowPoint);
          this.autoAddPathPoint();
          this.nowPoint = this.removeMinFFromOpenList();
          if (void 0 === this.nowPoint) return paths;
          if (AutoFindPath.getKey(this.nowPoint) === AutoFindPath.getKey(this.targetPoint)) break;
          if (++maxSearchAmount > this.searchLimit) {
            cc.error("\u8def\u5f84\u641c\u5bfb\u8d85\u9650");
            return paths;
          }
        }
        var nowPointKey = AutoFindPath.getKey(this.targetPoint);
        var bornPointKey = AutoFindPath.getKey(this.bronPoint);
        do {
          var pathPointData = this.mapTable.get(nowPointKey);
          paths.push(pathPointData);
          nowPointKey = AutoFindPath.getKey(pathPointData.parent);
        } while (nowPointKey !== bornPointKey);
        return paths.reverse();
      };
      AutoFindPath.prototype.gridPositionConvertGameObjectPosition = function(positions, anchor, ctor) {
        var res = [];
        for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
          var position = positions_1[_i];
          var x = position.x * this.mapData.gridLength + this.mapData.x + this.mapData.gridLength * anchor.x;
          var y = position.y * this.mapData.gridLength + this.mapData.y + this.mapData.gridLength * anchor.y;
          res.push(new ctor(x, y));
        }
        return res;
      };
      AutoFindPath.prototype.hasObstacle = function(v2) {
        var res = true;
        try {
          res = !!this.fixClosedListMap.get(AutoFindPath.getKey(this.getGridPosition(v2)));
        } catch (e) {}
        return res;
      };
      AutoFindPath.prototype.clear = function() {
        this.openList.length = 0;
        this.openListMap.clear();
        this.closedListMap.clear();
        this.bronPoint = null;
        this.targetPoint = null;
        this.nowPoint = null;
      };
      AutoFindPath.prototype.F = function(p) {
        AutoFindPath.G(p);
        this.H(p);
        p.F = p.G + p.H + p.K;
      };
      AutoFindPath.G = function(p) {
        p.parent.x === p.x || p.parent.y === p.y ? p.G = p.parent.G + 10 : p.G = p.parent.G + 14;
      };
      AutoFindPath.prototype.H = function(p) {
        p.H = 10 * Math.abs(this.targetPoint.x - p.x) + 10 * Math.abs(this.targetPoint.y - p.y);
      };
      AutoFindPath.getNextPosition = function(position, path, speed, dt) {
        var dx = speed * dt;
        while (true) {
          var point = path[0];
          var newPos = cc.v2(point.x, point.y);
          var vec = newPos.sub(position);
          var mag = vec.mag();
          if (dx < mag) return position.add(vec.mul(dx / mag));
          dx -= mag;
          path.shift();
          if (0 == path.length) return newPos;
        }
      };
      AutoFindPath.prototype.setNodeZindex = function(node) {
        node.zIndex = -AutoFindPath.ins.mapData.y - node.y;
      };
      AutoFindPath.sep = "_";
      AutoFindPath._ins = null;
      return AutoFindPath;
    }();
    exports.AutoFindPath = AutoFindPath;
    cc._RF.pop();
  }, {} ],
  BackpackContent: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "876c02VZpJOm7mbCQOB0Rx0", "BackpackContent");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const List_1 = require("../../Common/Components/List");
    const ListItem_1 = require("../../Common/Components/ListItem");
    const RawMaterial_1 = require("../../Config/RawMaterial");
    const BackpackItem_1 = require("./BackpackItem");
    const {ccclass: ccclass, property: property} = cc._decorator;
    let BackpackContent = class BackpackContent extends ListItem_1.default {
      constructor() {
        super(...arguments);
        this.data = null;
        this.desk = null;
        this.curModuleNum = 0;
        this.curTypeNum = 0;
        this.content = null;
        this.prefabItem = null;
      }
      onLoad() {
        super.onLoad();
      }
      onEnable() {}
      onDisable() {}
      initUi(data, moduleNumber, typeNum, desk) {
        this.content.removeAllChildren();
        this.data = data;
        this.desk = desk;
        this.curModuleNum = moduleNumber;
        this.curTypeNum = typeNum;
        this.node["contentNum"] = "" + this.curTypeNum;
        this.title.getComponent(cc.Label).string = this.data.name;
        this.onAfterShow(null);
      }
      onAfterShow(params) {
        this.curTypeNum == RawMaterial_1.BackpackList[this.curModuleNum].length - 1 && (this.desk.view.BackpackScroll.enabled = false);
        this.node.getComponent(List_1.default).numItems = RawMaterial_1.BackpackList[this.curModuleNum][this.curTypeNum].length;
        this.node.getComponent(List_1.default).scrollTo(0, 0, .1);
      }
      onListGridRender(item, idx) {
        item.getComponent(BackpackItem_1.default).initUi(RawMaterial_1.BackpackList[this.curModuleNum][this.curTypeNum][idx], idx, this);
        let self = this;
        this.scheduleOnce(() => {
          self.content.y = 0;
          self.node.height = self.content.height;
        });
      }
    };
    __decorate([ property({
      type: cc.Node,
      tooltip: "Content"
    }) ], BackpackContent.prototype, "content", void 0);
    __decorate([ property({
      type: cc.Prefab,
      tooltip: "prefabItem"
    }) ], BackpackContent.prototype, "prefabItem", void 0);
    BackpackContent = __decorate([ ccclass ], BackpackContent);
    exports.default = BackpackContent;
    cc._RF.pop();
  }, {
    "../../Common/Components/List": "List",
    "../../Common/Components/ListItem": "ListItem",
    "../../Config/RawMaterial": "RawMaterial",
    "./BackpackItem": "BackpackItem"
  } ],
  BackpackItem: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "3cb71FBlLBDrbf37/09niUO", "BackpackItem");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var BackpackItem_1;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const ListItem_1 = require("../../Common/Components/ListItem");
    const CommonUtils_1 = require("../../Common/Utils/CommonUtils");
    const GlobalData_1 = require("../../Config/GlobalData");
    const UIBackpackInfo_1 = require("../../UIScript/UIBackpackInfo");
    const {ccclass: ccclass, property: property} = cc._decorator;
    let BackpackItem = BackpackItem_1 = class BackpackItem extends ListItem_1.default {
      constructor() {
        super(...arguments);
        this.itemData = null;
        this.desk = null;
      }
      onLoad() {
        super.onLoad();
      }
      onEnable() {
        this.registerEvent();
      }
      onDisable() {
        this.unRegisterEvent();
      }
      registerEvent() {
        this.node.on(cc.Node.EventType.TOUCH_END, this.clickRecipeInfo, this);
      }
      unRegisterEvent() {
        this.node.off(cc.Node.EventType.TOUCH_END, this.clickRecipeInfo, this);
      }
      initUi(data, idx, desk) {
        this.itemData = data;
        this.desk = desk;
        this.node["itemNum"] = "" + idx;
        this.title.getComponent(cc.Label).string = data["name"];
        let tempResPath = data["resPath"] ? data["resPath"] : GlobalData_1.GlobalData.rawPath;
        CommonUtils_1.CommonUtils.setItemSpriteFrame(this.icon, `${tempResPath}${data["ID"]}`);
        this.numberNode.active = "item_raw" != data["type"];
        this.numberCount.string = data["count"];
        this.scheduleOnce(() => {
          CommonUtils_1.CommonUtils.checkIconSize(this.icon.node, 125);
          this.icon.node.active = true;
        }, .15);
      }
      clickRecipeInfo() {
        let pNode = this.node.parent;
        pNode.children.forEach(element => {
          element.getComponent(BackpackItem_1).selected = false;
        });
        this.selected = true;
        UIBackpackInfo_1.default.open(this.itemData);
      }
    };
    __decorate([ property(cc.Node) ], BackpackItem.prototype, "numberNode", void 0);
    __decorate([ property(cc.Label) ], BackpackItem.prototype, "numberCount", void 0);
    BackpackItem = BackpackItem_1 = __decorate([ ccclass ], BackpackItem);
    exports.default = BackpackItem;
    cc._RF.pop();
  }, {
    "../../Common/Components/ListItem": "ListItem",
    "../../Common/Utils/CommonUtils": "CommonUtils",
    "../../Config/GlobalData": "GlobalData",
    "../../UIScript/UIBackpackInfo": "UIBackpackInfo"
  } ],
  BackpackTypeItem: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "f7966yNq/NLy6qy/WQrp6jh", "BackpackTypeItem");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const {ccclass: ccclass, property: property} = cc._decorator;
    let BackpackTypeItem = class BackpackTypeItem extends cc.Component {
      constructor() {
        super(...arguments);
        this.icon = null;
        this.title = null;
        this.light = null;
        this.polygon = null;
        this.desk = null;
        this.itemData = null;
        this.isSelected = false;
        this.initPolygonPos = null;
      }
      onLoad() {}
      start() {}
      onEnable() {}
      onDisable() {
        this.polygon.position = this.initPolygonPos;
        this.unRegisterEvent();
      }
      registerEvent() {
        this.node.on(cc.Node.EventType.TOUCH_END, this.clickTypeNode, this);
      }
      unRegisterEvent() {
        this.node.off(cc.Node.EventType.TOUCH_END, this.clickTypeNode, this);
      }
      initData() {
        this.registerEvent();
        this.polygon.stopAllActions();
        this.initPolygonPos = this.polygon.position;
        this.polygon.active = false;
        this.light.active = false;
      }
      initUi(data, idx, desk) {
        this.initData();
        this.itemData = data;
        this.desk = desk;
        this.node["typeNum"] = "" + idx;
        this.node.color = cc.color(data.color);
        this.title.string = data.name;
        this.isSelectedFunction();
      }
      isSelectedFunction() {
        if (this.isSelected) {
          this.light.active = true;
          this.polygon.active = true;
          this.node.color = cc.color(this.itemData.color);
          cc.tween(this.polygon).by(.5, {
            position: cc.v3(0, -10, 0)
          }).by(.5, {
            position: cc.v3(0, 10, 0)
          }).union().repeatForever().start();
        } else {
          this.node.color = cc.color(this.itemData.color_unSelected);
          this.polygon.position = this.initPolygonPos;
          this.polygon.stopAllActions();
          this.polygon.active = false;
          this.light.active = false;
        }
      }
      clickTypeNode(e) {
        let nodeName = e.target["typeNum"];
        this.desk.curTypeNumber = parseInt(nodeName);
        this.desk.clickTypeNode();
        this.isSelected = true;
        this.isSelectedFunction();
      }
    };
    __decorate([ property({
      type: cc.Sprite,
      tooltip: false
    }) ], BackpackTypeItem.prototype, "icon", void 0);
    __decorate([ property({
      type: cc.Label,
      tooltip: false
    }) ], BackpackTypeItem.prototype, "title", void 0);
    __decorate([ property({
      type: cc.Node,
      tooltip: false
    }) ], BackpackTypeItem.prototype, "light", void 0);
    __decorate([ property({
      type: cc.Node,
      tooltip: false
    }) ], BackpackTypeItem.prototype, "polygon", void 0);
    BackpackTypeItem = __decorate([ ccclass ], BackpackTypeItem);
    exports.default = BackpackTypeItem;
    cc._RF.pop();
  }, {} ],
  BaseAssembler: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "e3feaq91SVBdIfW2t1TEvv2", "BaseAssembler");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var gfx = cc["gfx"];
    var vfmtPosUvColor = new gfx.VertexFormat([ {
      name: gfx.ATTR_POSITION,
      type: gfx.ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: gfx.ATTR_UV0,
      type: gfx.ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: gfx.ATTR_COLOR,
      type: gfx.ATTR_TYPE_UINT8,
      num: 4,
      normalize: true
    } ]);
    var BaseAssembler = function(_super) {
      __extends(BaseAssembler, _super);
      function BaseAssembler() {
        var _this = _super.call(this) || this;
        _this.verticesCount = 4;
        _this.indicesCount = 6;
        _this.floatsPerVert = 5;
        _this.uvOffset = 2;
        _this.colorOffset = 4;
        _this._renderData = null;
        _this._local = null;
        _this._renderData = new cc.RenderData();
        _this._renderData.init(_this);
        _this.initData();
        _this.initLocal();
        return _this;
      }
      Object.defineProperty(BaseAssembler.prototype, "verticesFloats", {
        get: function() {
          return this.verticesCount * this.floatsPerVert;
        },
        enumerable: false,
        configurable: true
      });
      BaseAssembler.prototype.getVfmt = function() {
        return vfmtPosUvColor;
      };
      BaseAssembler.prototype.getBuffer = function() {
        return cc.renderer["_handle"].getBuffer("mesh", this.getVfmt());
      };
      BaseAssembler.prototype.initData = function() {
        var data = this._renderData;
        data.createQuadData(0, this.verticesFloats, this.indicesCount);
      };
      BaseAssembler.prototype.initLocal = function() {
        this._local = [];
        this._local.length = 4;
      };
      BaseAssembler.prototype.updateColor = function(comp, color) {
        var uintVerts = this._renderData.uintVDatas[0];
        if (!uintVerts) return;
        color = null != color ? color : comp.node.color["_val"];
        var floatsPerVert = this.floatsPerVert;
        var colorOffset = this.colorOffset;
        for (var i = 0; i < this.verticesCount; i++) uintVerts[colorOffset + i * floatsPerVert] = color;
      };
      BaseAssembler.prototype.updateUVs = function(comp) {
        var uv = [ 0, 1, 1, 1, 0, 0, 1, 0 ];
        var uvOffset = this.uvOffset;
        var floatsPerVert = this.floatsPerVert;
        var verts = this._renderData.vDatas[0];
        for (var i = 0; i < this.verticesCount; i++) {
          var srcOffset = 2 * i;
          var dstOffset = floatsPerVert * i + uvOffset;
          verts[dstOffset] = uv[srcOffset];
          verts[dstOffset + 1] = uv[srcOffset + 1];
        }
      };
      BaseAssembler.prototype.updateWorldVertsWebGL = function(comp) {
        var local = this._local;
        var verts = this._renderData.vDatas[0];
        var matrix = comp.node["_worldMatrix"];
        var matrixm = matrix.m, a = matrixm[0], b = matrixm[1], c = matrixm[4], d = matrixm[5], tx = matrixm[12], ty = matrixm[13];
        var vl = local[0], vr = local[2], vb = local[1], vt = local[3];
        var justTranslate = 1 === a && 0 === b && 0 === c && 1 === d;
        var index = 0;
        var floatsPerVert = this.floatsPerVert;
        if (justTranslate) {
          verts[index] = vl + tx;
          verts[index + 1] = vb + ty;
          index += floatsPerVert;
          verts[index] = vr + tx;
          verts[index + 1] = vb + ty;
          index += floatsPerVert;
          verts[index] = vr + tx;
          verts[index + 1] = vt + ty;
          index += floatsPerVert;
          verts[index] = vl + tx;
          verts[index + 1] = vt + ty;
          index += floatsPerVert;
        } else {
          var al = a * vl, ar = a * vr, bl = b * vl, br = b * vr, cb = c * vb, ct = c * vt, db = d * vb, dt = d * vt;
          verts[index] = al + cb + tx;
          verts[index + 1] = bl + db + ty;
          index += floatsPerVert;
          verts[index] = ar + cb + tx;
          verts[index + 1] = br + db + ty;
          index += floatsPerVert;
          verts[index] = al + ct + tx;
          verts[index + 1] = bl + dt + ty;
          index += floatsPerVert;
          verts[index] = ar + ct + tx;
          verts[index + 1] = br + dt + ty;
        }
      };
      BaseAssembler.prototype.updateWorldVertsNative = function(comp) {
        var local = this._local;
        var verts = this._renderData.vDatas[0];
        var floatsPerVert = this.floatsPerVert;
        var vl = local[0], vr = local[2], vb = local[1], vt = local[3];
        var index = 0;
        verts[index] = vl;
        verts[index + 1] = vb;
        index += floatsPerVert;
        verts[index] = vr;
        verts[index + 1] = vb;
        index += floatsPerVert;
        verts[index] = vl;
        verts[index + 1] = vt;
        index += floatsPerVert;
        verts[index] = vr;
        verts[index + 1] = vt;
      };
      BaseAssembler.prototype.updateWorldVerts = function(comp) {
        false;
        this.updateWorldVertsWebGL(comp);
      };
      BaseAssembler.prototype.updateVerts = function(comp) {
        var node = comp.node, cw = node.width, ch = node.height, appx = node.anchorX * cw, appy = node.anchorY * ch, l, b, r, t;
        l = -appx;
        b = -appy;
        r = cw - appx;
        t = ch - appy;
        var local = this._local;
        local[0] = l;
        local[1] = b;
        local[2] = r;
        local[3] = t;
        this.updateWorldVerts(comp);
      };
      BaseAssembler.prototype.updateRenderData = function(comp) {
        if (comp._vertsDirty) {
          this.updateUVs(comp);
          this.updateVerts(comp);
          comp._vertsDirty = false;
        }
      };
      BaseAssembler.prototype.fillBuffers = function(comp, renderer) {
        renderer.worldMatDirty && this.updateWorldVerts(comp);
        var renderData = this._renderData;
        var vData = renderData.vDatas[0];
        var iData = renderData.iDatas[0];
        var buffer = this.getBuffer();
        var offsetInfo = buffer.request(this.verticesCount, this.indicesCount);
        var vertexOffset = offsetInfo.byteOffset >> 2, vbuf = buffer._vData;
        vData.length + vertexOffset > vbuf.length ? vbuf.set(vData.subarray(0, vbuf.length - vertexOffset), vertexOffset) : vbuf.set(vData, vertexOffset);
        var ibuf = buffer._iData, indiceOffset = offsetInfo.indiceOffset, vertexId = offsetInfo.vertexOffset;
        var textData = [ 0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7 ];
        for (var i = 0, l = iData.length; i < l; i++) ibuf[indiceOffset++] = vertexId + textData[i];
      };
      BaseAssembler.prototype.packToDynamicAtlas = function(comp, frame) {
        false;
        if (!frame._original && cc.dynamicAtlasManager && frame._texture.packable) {
          var packedFrame = cc.dynamicAtlasManager.insertSpriteFrame(frame);
          packedFrame && frame._setDynamicAtlasFrame(packedFrame);
        }
        var material = comp._materials[0];
        if (!material) return;
        if (material.getProperty("texture") !== frame._texture) {
          comp._vertsDirty = true;
          comp._updateMaterial();
        }
      };
      return BaseAssembler;
    }(cc.Assembler);
    exports.default = BaseAssembler;
    cc._RF.pop();
  }, {} ],
  BaseMgr: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "5e629wf1WBDNaVfkPO8PSYi", "BaseMgr");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.BaseMgr = void 0;
    var BaseMgr = function() {
      function BaseMgr(game) {
        this.game = null;
        this.game = game;
      }
      return BaseMgr;
    }();
    exports.BaseMgr = BaseMgr;
    cc._RF.pop();
  }, {} ],
  BaseRole: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "a7f437+BQBGaLENl/LpKYRU", "BaseRole");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const BroadcastCenter_1 = require("../../Common/BroadCasts/BroadcastCenter");
    const GlobalData_1 = require("../../Config/GlobalData");
    const ResConfig_1 = require("../../Config/ResConfig");
    const MessageType_1 = require("../../Enum/MessageType");
    const AutoFindPath_1 = require("../../Extra/AutoFindPath");
    const CocosHelper_1 = require("../../UIFrame/CocosHelper");
    const SysDefine_1 = require("../../UIFrame/config/SysDefine");
    const RoleMgr_1 = require("../Manager/RoleMgr");
    const TableMgr_1 = require("../Manager/TableMgr");
    const {ccclass: ccclass, property: property} = cc._decorator;
    let BaseRole = class BaseRole extends cc.Component {
      constructor() {
        super(...arguments);
        this.ani = null;
        this.talk = null;
        this.coffee = null;
        this.direction = ResConfig_1.EntityDirection.RIGHT_UP;
        this.awaitIndex = 0;
        this.movePath = [];
        this.moveing = false;
        this.tempBoxChild = [];
        this.home = null;
        this.makeRecipe = null;
        this.roleData = null;
        this.talkIdx = -1;
        this.repIdx = -1;
        this.isSite = false;
        this.aniNameArr = [ "idle", "run" ];
        this._state = MessageType_1.RoleType.COME;
      }
      start() {}
      init(home, callback) {
        this.home = home;
        this.state = MessageType_1.RoleType.COME;
        this.talk.active = false;
        this.coffee.active = false;
        this.changeRole(callback);
      }
      changeRole(callback) {
        return __awaiter(this, void 0, void 0, function*() {
          let clip = null;
          for (let i = 0; i < this.aniNameArr.length; i++) {
            clip = yield CocosHelper_1.default.loadResSync(GlobalData_1.GlobalData.rolePath + this.roleData.name + "/" + this.aniNameArr[i], cc.AnimationClip);
            this.ani.addClip(clip);
          }
          callback();
        });
      }
      toPos(endPos) {
        this.searchPath(endPos);
      }
      update(dt) {
        if (!this.node.parent) return;
        this.moveHandle(dt);
      }
      set state(value) {
        this._state = value;
      }
      get state() {
        return this._state;
      }
      moveHandle(dt) {
        if (this.movePath.length <= 0) {
          this.stand();
          return null;
        }
        let nextPosition = AutoFindPath_1.AutoFindPath.getNextPosition(this.node.getPosition(), this.movePath, GlobalData_1.GlobalData.gameData.roleMoveSpeed, dt);
        let direction = null;
        let deltaX = nextPosition.x - this.node.x;
        let deltaY = nextPosition.y - this.node.y;
        if (deltaX > 0) {
          deltaY > 0 && (direction = ResConfig_1.EntityDirection.RIGHT_UP);
          deltaY < 0 && (direction = ResConfig_1.EntityDirection.RIGHT_DOWN);
          0 == deltaY && (direction = this.direction == ResConfig_1.EntityDirection.LEFT_UP || this.direction == ResConfig_1.EntityDirection.RIGHT_UP ? ResConfig_1.EntityDirection.RIGHT_UP : ResConfig_1.EntityDirection.RIGHT_DOWN);
        }
        if (deltaX < 0) {
          deltaY > 0 && (direction = ResConfig_1.EntityDirection.LEFT_UP);
          deltaY < 0 && (direction = ResConfig_1.EntityDirection.LEFT_DOWN);
          0 == deltaY && (direction = this.direction == ResConfig_1.EntityDirection.LEFT_UP || this.direction == ResConfig_1.EntityDirection.RIGHT_UP ? ResConfig_1.EntityDirection.LEFT_UP : ResConfig_1.EntityDirection.LEFT_DOWN);
        }
        if (0 == deltaX) {
          deltaY > 0 && (direction = this.direction == ResConfig_1.EntityDirection.LEFT_UP || this.direction == ResConfig_1.EntityDirection.LEFT_DOWN ? ResConfig_1.EntityDirection.LEFT_UP : ResConfig_1.EntityDirection.RIGHT_UP);
          deltaY < 0 && (direction = this.direction == ResConfig_1.EntityDirection.LEFT_UP || this.direction == ResConfig_1.EntityDirection.LEFT_DOWN ? ResConfig_1.EntityDirection.LEFT_DOWN : ResConfig_1.EntityDirection.RIGHT_DOWN);
          0 == deltaY && (direction = this.direction);
        }
        this.node.setPosition(nextPosition);
        this.run();
        AutoFindPath_1.AutoFindPath.ins.setNodeZindex(this.node);
      }
      run() {
        if (!this.moveing) {
          this.moveing = true;
          this.ani.playAdditive(ResConfig_1.RoleState.run);
        }
      }
      stand() {
        if (this.moveing) {
          this.state == MessageType_1.RoleType.COME && (this.state = MessageType_1.RoleType.WAIT);
          this.moveing = false;
          this.ani.stop();
          this.ani.playAdditive(ResConfig_1.RoleState.idle);
          switch (this.state) {
           case MessageType_1.RoleType.LEAVE:
            this.talkIdx = this.repIdx = -1;
            this.home.rolePool.put(this.node);
            RoleMgr_1.default.ins.sitRole = null;
            this.isSite = false;
            break;

           case MessageType_1.RoleType.WAIT:
            BroadcastCenter_1.BroadcastCenter.buildingState.dispatch({
              id: this.awaitIndex,
              state: MessageType_1.MessageType.RoleStand
            });
            break;

           case MessageType_1.RoleType.SIT:
            this.isSite = true;
            this.coffee.active = false;
            let table = TableMgr_1.default.ins.queryNullTable();
            this.node.zIndex = SysDefine_1.LayerLevel.SiteRole;
            table.sit(this.makeRecipe, this);
            RoleMgr_1.default.ins.sitRole = this;
          }
        }
      }
      getCoffee() {
        this.talk.active = false;
        this.coffee.active = true;
        this.state = MessageType_1.RoleType.LEAVE;
        this.home.top.playGoldAnim(this.node, this.makeRecipe.price);
        this.changeTalk(true);
      }
      changeTalk(isTalk) {
        isTalk ? this.closeTalk() : this.startTalk();
      }
      searchPath(endPos) {
        return __awaiter(this, void 0, void 0, function*() {
          this.movePath.length = 0;
          let paths = AutoFindPath_1.AutoFindPath.ins.gridPositionConvertGameObjectPosition(AutoFindPath_1.AutoFindPath.ins.findGridPath(this.node, endPos, AutoFindPath_1.models.tilt), cc.v2(.5, .5), cc.Vec2);
          if (0 === paths.length) {
            console.log("\u6b7b\u8def");
            return;
          }
          this.movePath = paths;
        });
      }
      startTalk() {
        this.ani.node.active = false;
      }
      closeTalk() {
        this.ani.node.active = true;
      }
    };
    BaseRole.prefabPath = "Prefab/Common/Role";
    __decorate([ property(cc.Animation) ], BaseRole.prototype, "ani", void 0);
    __decorate([ property(cc.Node) ], BaseRole.prototype, "talk", void 0);
    __decorate([ property(cc.Node) ], BaseRole.prototype, "coffee", void 0);
    BaseRole = __decorate([ ccclass ], BaseRole);
    exports.default = BaseRole;
    cc._RF.pop();
  }, {
    "../../Common/BroadCasts/BroadcastCenter": "BroadcastCenter",
    "../../Config/GlobalData": "GlobalData",
    "../../Config/ResConfig": "ResConfig",
    "../../Enum/MessageType": "MessageType",
    "../../Extra/AutoFindPath": "AutoFindPath",
    "../../UIFrame/CocosHelper": "CocosHelper",
    "../../UIFrame/config/SysDefine": "SysDefine",
    "../Manager/RoleMgr": "RoleMgr",
    "../Manager/TableMgr": "TableMgr"
  } ],
  BaseTable: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "4b193bvs7lFoIdxAmx7/wnl", "BaseTable");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const lodash_1 = require("lodash");
    const CommonUtils_1 = require("../../Common/Utils/CommonUtils");
    const GlobalData_1 = require("../../Config/GlobalData");
    const RawMaterial_1 = require("../../Config/RawMaterial");
    const MessageType_1 = require("../../Enum/MessageType");
    const SysDefine_1 = require("../../UIFrame/config/SysDefine");
    const RecipeCoffeeItem_1 = require("../Item/RecipeCoffeeItem");
    const {ccclass: ccclass, property: property} = cc._decorator;
    let BaseTable = class BaseTable extends cc.Component {
      constructor() {
        super(...arguments);
        this.coffee = null;
        this.laji = null;
        this.coffeePrefab = null;
        this.coffeeNode = null;
        this._state = MessageType_1.TableType.NONE;
        this.makeRecipe = null;
        this.tableData = null;
        this.posData = null;
        this.role = null;
        this.tablePath = "img/table";
        this.coffeePath = "img/recipe";
        this.home = null;
        this.initPos = null;
      }
      onLoad() {}
      start() {}
      init(home, posData, grid) {
        this.home = home;
        this.posData = posData;
        this.tableData = lodash_1.find(RawMaterial_1.TableList, item => item.ID === posData.ID);
        this.initUI(grid);
        this.initPos = this.coffee.node.position;
        this.coffeeNode = cc.instantiate(this.coffeePrefab);
        this.coffeeNode.parent = this.node;
        this.coffeeNode.position = this.initPos;
        this.coffeeNode.scale = .4;
        this.coffeeNode.active = false;
      }
      initUI(grid) {
        let tableSpr = this.node.getComponent(cc.Sprite);
        grid && grid.icon ? tableSpr.spriteFrame = grid.icon.spriteFrame : CommonUtils_1.CommonUtils.setItemSpriteFrame(tableSpr, `${GlobalData_1.GlobalData.tablePath}${this.tableData["ID"]}`);
      }
      get state() {
        return this._state;
      }
      set state(value) {
        this._state = value;
      }
      sit(data, role) {
        this.state = MessageType_1.TableType.DRINK;
        this.role = role;
        this.makeRecipe = data;
        this.coffee.node.position = this.initPos;
        if (data && data.ID) {
          this.coffeeNode.getComponent(RecipeCoffeeItem_1.default).initUi(data);
          this.coffeeNode.active = true;
        }
        this.scheduleOnce(this.leval, GlobalData_1.GlobalData.gameData.drinkTime);
      }
      leval() {
        this.state = MessageType_1.TableType.TRASH;
        this.coffeeNode.active = false;
        this.coffee.node.active = true;
        this.node.zIndex = SysDefine_1.LayerLevel.DefaultLayer;
        this.coffee.spriteFrame = this.laji;
        this.coffee.node.position = cc.v3(this.initPos.x, this.initPos.y - 20, this.initPos.z);
        this.home.leave(this.role);
      }
      clearTable() {
        if (this.state == MessageType_1.TableType.TRASH) {
          this.coffee.node.active = false;
          this.state = MessageType_1.TableType.NONE;
          this.home.top.playGoldAnim(this.node, this.makeRecipe.price);
        }
      }
    };
    BaseTable.prefabPath = "Prefab/Common/table";
    __decorate([ property(cc.Sprite) ], BaseTable.prototype, "coffee", void 0);
    __decorate([ property(cc.SpriteFrame) ], BaseTable.prototype, "laji", void 0);
    __decorate([ property(cc.Prefab) ], BaseTable.prototype, "coffeePrefab", void 0);
    BaseTable = __decorate([ ccclass ], BaseTable);
    exports.default = BaseTable;
    cc._RF.pop();
  }, {
    "../../Common/Utils/CommonUtils": "CommonUtils",
    "../../Config/GlobalData": "GlobalData",
    "../../Config/RawMaterial": "RawMaterial",
    "../../Enum/MessageType": "MessageType",
    "../../UIFrame/config/SysDefine": "SysDefine",
    "../Item/RecipeCoffeeItem": "RecipeCoffeeItem",
    lodash: 1
  } ],
  BatchAssembler: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "3989dU4L8BIBJM9muUNLD0B", "BatchAssembler");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var BaseAssembler_1 = require("./BaseAssembler");
    var BAN_FALG = cc.RenderFlow.FLAG_RENDER | cc.RenderFlow.FLAG_POST_RENDER;
    var DIRTY_PROP = cc.RenderFlow.FLAG_OPACITY | cc.RenderFlow.FLAG_WORLD_TRANSFORM;
    var BATCH_SWITCH = true;
    var BatchAssembler = function(_super) {
      __extends(BatchAssembler, _super);
      function BatchAssembler() {
        var _this = _super.call(this) || this;
        _this._groups = [];
        return _this;
      }
      BatchAssembler.prototype.fillBuffers = function(comp, renderer) {
        false;
        if (!BATCH_SWITCH) return;
        var worldTransformFlag = renderer.worldMatDirty ? cc.RenderFlow.FLAG_WORLD_TRANSFORM : 0;
        var worldOpacityFlag = renderer.parentOpacityDirty ? cc.RenderFlow.FLAG_OPACITY_COLOR : 0;
        var dirtyFlag = worldTransformFlag | worldOpacityFlag;
        comp.node["__DirtyFlag__"] = dirtyFlag;
        this._groups = [];
        this._walkByName(comp.node.children);
      };
      BatchAssembler.prototype.postFillBuffers = function(comp, renderer) {
        var originWorldMatDirty = renderer.worldMatDirty;
        if (!BATCH_SWITCH || !this._groups || this._groups.length <= 0) return;
        BATCH_SWITCH = false;
        for (var _i = 0, _a = this._groups; _i < _a.length; _i++) {
          var group = _a[_i];
          if (group.length <= 0) continue;
          for (var _b = 0, group_1 = group; _b < group_1.length; _b++) {
            var node = group_1[_b];
            var renderFlag = node["__RenderFlag__"];
            var dirtyFlag = node["__DirtyFlag__"];
            renderer.worldMatDirty = dirtyFlag > 0 ? 1 : 0;
            node._renderFlag |= renderFlag;
            renderFlag && cc.RenderFlow.flows[renderFlag]._func(node);
          }
        }
        this._groups = null;
        BATCH_SWITCH = true;
        renderer.worldMatDirty = originWorldMatDirty;
      };
      BatchAssembler.prototype._walkDefault = function(nodes) {
        if (!nodes || nodes.length <= 0) return;
        var count = nodes[0].childrenCount;
        var groups = [];
        for (var i = 0; i < count; i++) groups[i] = [];
        var group = [];
        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
          var node = nodes_1[_i];
          if (!node._activeInHierarchy || 0 == node.opacity) continue;
          var flag = node._renderFlag & BAN_FALG;
          if (flag > 0) {
            node["__RenderFlag__"] = flag;
            node._renderFlag &= ~flag;
            group.push(node);
          }
          node["__DirtyFlag__"] = node.parent["__DirtyFlag__"] | node._renderFlag & DIRTY_PROP;
          for (var i = 0; i < count; i++) groups[i].push(node.children[i]);
        }
        group.length > 0 && this._groups.push(group);
        for (var _a = 0, groups_1 = groups; _a < groups_1.length; _a++) {
          var group_2 = groups_1[_a];
          this._walkDefault(group_2);
        }
      };
      BatchAssembler.prototype._walkByName = function(nodes) {
        if (!nodes || nodes.length <= 0) return;
        var groups = {};
        var group = [];
        var keys = [];
        for (var _i = 0, nodes_2 = nodes; _i < nodes_2.length; _i++) {
          var node = nodes_2[_i];
          if (!node._activeInHierarchy || 0 == node.opacity) continue;
          var flag = node._renderFlag & BAN_FALG;
          if (flag > 0) {
            node["__RenderFlag__"] = flag;
            node._renderFlag &= ~flag;
            group.push(node);
          }
          node["__DirtyFlag__"] = node.parent["__DirtyFlag__"] | node._renderFlag & DIRTY_PROP;
          var lastKey = "";
          for (var _a = 0, _b = node.children; _a < _b.length; _a++) {
            var n = _b[_a];
            var key = n.name;
            groups[key] || (groups[key] = []);
            groups[key].push(n);
            if (-1 == keys.indexOf(key)) if (0 == lastKey.length) keys.unshift(key); else {
              var idx = keys.indexOf(lastKey);
              keys.splice(idx + 1, 0, key);
            }
            lastKey = key;
          }
        }
        group.length > 0 && this._groups.push(group);
        for (var _c = 0, keys_1 = keys; _c < keys_1.length; _c++) {
          var key = keys_1[_c];
          this._walkByName(groups[key]);
        }
      };
      return BatchAssembler;
    }(BaseAssembler_1.default);
    exports.default = BatchAssembler;
    cc._RF.pop();
  }, {
    "./BaseAssembler": "BaseAssembler"
  } ],
  BatchComponent: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "d393a5ZdPJN0q6Ay73BaSB9", "BatchComponent");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var BatchAssembler_1 = require("../Assemblers/BatchAssembler");
    var TraversalMode;
    (function(TraversalMode) {
      TraversalMode[TraversalMode["Default"] = 0] = "Default";
      TraversalMode[TraversalMode["SameName"] = 1] = "SameName";
    })(TraversalMode || (TraversalMode = {}));
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
    var BantchComponent = function(_super) {
      __extends(BantchComponent, _super);
      function BantchComponent() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.mode = 0;
        return _this;
      }
      BantchComponent.prototype.onEnable = function() {
        _super.prototype.onEnable.call(this);
        true;
        this.node._renderFlag |= cc.RenderFlow.FLAG_POST_RENDER;
      };
      BantchComponent.prototype._resetAssembler = function() {
        this.setVertsDirty();
        var assembler = this._assembler = new BatchAssembler_1.default();
        assembler.init(this);
      };
      __decorate([ property({
        type: cc.Enum(TraversalMode),
        tooltip: "\u904d\u5386\u6a21\u5f0f: Default \u9ed8\u8ba4\u7684\u5e7f\u5ea6\u904d\u5386, SameName \u540c\u540d\u7ed3\u70b9\u540c\u6279\u6b21"
      }) ], BantchComponent.prototype, "mode", void 0);
      BantchComponent = __decorate([ ccclass ], BantchComponent);
      return BantchComponent;
    }(cc.RenderComponent);
    exports.default = BantchComponent;
    cc._RF.pop();
  }, {
    "../Assemblers/BatchAssembler": "BatchAssembler"
  } ],
  BigNumUtils: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "c4b72NccXhGKofOUM3hVrvP", "BigNumUtils");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.RountType = void 0;
    var RountType;
    (function(RountType) {
      RountType[RountType["Round"] = 0] = "Round";
      RountType[RountType["Floor"] = 1] = "Floor";
      RountType[RountType["Ceil"] = 2] = "Ceil";
    })(RountType = exports.RountType || (exports.RountType = {}));
    var BigNumUtils = function() {
      function BigNumUtils() {}
      BigNumUtils.BNPlus = function() {
        var args = [];
        for (var _a = 0; _a < arguments.length; _a++) args[_a] = arguments[_a];
        var value = [ 0, 0 ];
        for (var _i = 0; _i < args.length; _i++) {
          var arg = args[_i];
          var base, zeroes;
          var num = +arg;
          if (0 === num || num && Infinity !== num) {
            zeroes = arg < 10 ? 0 : Math.floor(Math.log10(+arg) + 1e-6);
            base = arg < 10 ? arg : arg / Math.pow(10, zeroes);
          } else if (arg) {
            arg = arg.split("e");
            base = +arg[0] || 0;
            zeroes = +arg[1] || 0;
          } else {
            base = 0;
            zeroes = 0;
          }
          if (zeroes > value[1]) {
            value[0] /= Math.pow(10, zeroes - value[1]);
            value[0] += base;
            value[1] = zeroes;
          } else value[0] += base / Math.pow(10, value[1] - zeroes);
        }
        var sign = value[0] >= 0 ? 1 : -1;
        var rbase = Math.abs(value[0]);
        while (rbase < 1 && value[1] > 0) {
          rbase *= 10;
          value[1] -= 1;
        }
        while (rbase > 10) {
          rbase /= 10;
          value[1] += 1;
        }
        rbase *= sign;
        return rbase + "e" + value[1];
      };
      BigNumUtils.BNMinus = function() {
        var args = [];
        for (var _a = 0; _a < arguments.length; _a++) args[_a] = arguments[_a];
        var value = [ 0, 0 ];
        for (var _i = 0; _i < args.length; _i++) {
          var arg = args[_i];
          var idx = _i;
          var base, zeroes;
          var num = +arg;
          if (0 === num || num && Infinity !== num) {
            zeroes = arg < 10 ? 0 : Math.floor(Math.log10(+arg) + 1e-6);
            base = arg < 10 ? arg : arg / Math.pow(10, zeroes);
          } else {
            arg = arg.split("e");
            base = +arg[0];
            zeroes = +arg[1];
          }
          if (idx) if (value[1] < zeroes) {
            value[0] = value[0] / Math.pow(10, zeroes - value[1]) - base;
            value[1] = zeroes;
          } else value[0] -= base / Math.pow(10, value[1] - zeroes); else {
            value[0] = base;
            value[1] = zeroes;
          }
        }
        var sign = value[0] >= 0 ? 1 : -1;
        var rbase = Math.abs(value[0]);
        while (rbase < 1 && value[1] > 0) {
          rbase *= 10;
          value[1] -= 1;
        }
        while (rbase > 10) {
          rbase /= 10;
          value[1] += 1;
        }
        rbase *= sign;
        return rbase + "e" + value[1];
      };
      BigNumUtils.BNTimes = function() {
        var args = [];
        for (var _a = 0; _a < arguments.length; _a++) args[_a] = arguments[_a];
        var value = [ 0, 0 ];
        args.forEach(function(arg, idx) {
          var base, zeroes;
          var num = +arg;
          if (0 === num || num && Infinity !== num) {
            zeroes = arg < 10 ? 0 : Math.floor(Math.log10(+arg) + 1e-6);
            base = arg < 10 ? arg : arg / Math.pow(10, zeroes);
          } else if (arg) {
            arg = arg.split("e");
            base = +arg[0] || 0;
            zeroes = +arg[1] || 0;
          } else {
            base = 1;
            zeroes = 0;
          }
          if (idx) {
            value[0] *= base;
            value[1] += zeroes;
            if (value[0] > 1e300) {
              value[0] /= 1e300;
              value[1] += 300;
            }
          } else {
            value[0] = base;
            value[1] = zeroes;
          }
        });
        var sign = value[0] >= 0 ? 1 : -1;
        var base = Math.abs(value[0]);
        while (base < 1 && value[1] > 0) {
          base *= 10;
          value[1] -= 1;
        }
        while (base > 10) {
          base /= 10;
          value[1] += 1;
        }
        return base * sign + "e" + value[1];
      };
      BigNumUtils.BNDevide = function(value0, value1) {
        if (0 === +value1) return 0;
        var value = [ 0, 0 ];
        var sign = 1;
        [ value0, value1 ].forEach(function(arg, idx) {
          var base, zeroes;
          var realNum = +arg;
          var num = Math.abs(realNum);
          if (0 === num || num && Infinity !== num) {
            zeroes = num < 10 ? 0 : Math.floor(Math.log10(num) + 1e-6);
            base = num < 10 ? num : num / Math.pow(10, zeroes);
          } else {
            arg = arg.split("e");
            realNum = +arg[0];
            base = Math.abs(realNum);
            zeroes = +arg[1];
          }
          sign *= realNum >= 0 ? 1 : -1;
          if (0 === idx) {
            value[0] = base;
            value[1] = zeroes;
          } else {
            value[0] /= base;
            value[1] -= zeroes;
          }
        });
        var base = Math.abs(value[0]);
        while (base < 1 && value[1] > 0) {
          base *= 10;
          value[1] -= 1;
        }
        while (base > 10) {
          base /= 10;
          value[1] += 1;
        }
        base *= sign;
        if (value[1] < 100) return base * Math.pow(10, value[1]);
        return this.BNTimes(base, this.BNPow(10, value[1]));
      };
      BigNumUtils.BNCompare = function(value0, value1) {
        var bases = [ 0, 0 ];
        var zeroes = [ 0, 0 ];
        [ value0, value1 ].forEach(function(arg, idx) {
          var num = +arg;
          if (0 === num || num && Infinity !== num) {
            zeroes[idx] = arg < 10 ? 0 : Math.floor(Math.log10(+arg) + 1e-6);
            bases[idx] = arg < 10 ? arg : arg / Math.pow(10, zeroes[idx]);
          } else {
            arg = arg.split("e");
            bases[idx] = +arg[0];
            zeroes[idx] = +arg[1];
          }
        });
        return bases[0] * bases[1] < 0 ? bases[0] > 0 ? 1 : -1 : zeroes[1] > zeroes[0] ? -1 : zeroes[1] < zeroes[0] ? 1 : bases[1] > bases[0] ? -1 : bases[1] < bases[0] ? 1 : 0;
      };
      BigNumUtils.BNPow = function(di, zhi) {
        if (!di) return "0";
        if (!zhi) return "1";
        var max = Math.floor(Math.log(1e300) / Math.log(di));
        max = Math.max(max, 1);
        var val = 1;
        if (max >= zhi) val = Math.pow(di, zhi); else {
          var times = Math.floor(zhi / max);
          var arr = [];
          var mid = Math.pow(di, max);
          for (var i = 0; i < times; i++) arr.push(mid);
          arr.push(Math.pow(di, zhi - max * times));
          val = this.BNTimes.apply(this, arr);
        }
        return val;
      };
      BigNumUtils.BNMax = function(value0, value1) {
        return this.BNCompare(value0, value1) > 0 ? value0 : value1;
      };
      BigNumUtils.BNMin = function(value0, value1) {
        return this.BNCompare(value0, value1) > 0 ? value1 : value0;
      };
      BigNumUtils.BNLog = function(value) {
        var num = +value;
        if (0 === num || num && Infinity !== num) {
          var sign = num >= 0 ? 1 : -1;
          num = Math.abs(num);
          return sign * Math.log10(num);
        }
        return +value.split("e")[1];
      };
      BigNumUtils.BNSqrt = function(value) {
        var num = +value;
        if (0 === num || num && Infinity !== num) return Math.sqrt(num);
        var arr = value.split("e");
        var a = +arr[0];
        var b = +arr[1];
        return Math.sqrt(a) + "e" + b / 2;
      };
      BigNumUtils.BNSqrtEx = function(value, zhi) {
        var num = +value;
        if (0 === num || num && Infinity !== num) return Math.pow(num, 1 / zhi);
        var arr = value.split("e");
        var a = +arr[0];
        var b = +arr[1];
        return Math.pow(a, 1 / zhi) + "e" + b / zhi;
      };
      BigNumUtils.BNFloor = function(value) {
        var num = +value;
        if (0 === num || num && Infinity !== num) return Math.floor(num);
        return value;
      };
      BigNumUtils.BNCeil = function(value) {
        var num = +value;
        if (0 === num || num && Infinity !== num) return Math.ceil(num);
        return value;
      };
      BigNumUtils.BNRound = function(value) {
        var num = +value;
        if (0 === num || num && Infinity !== num) return Math.round(num);
        return value;
      };
      BigNumUtils.BN2Number = function(value) {
        var num = +value;
        if (0 === num || num && Infinity !== num) return num;
        var arr = value.split("e");
        return +arr[0] * Math.pow(10, arr[1]);
      };
      BigNumUtils.getOwnString = function(n) {
        return this.getNumberString(n, void 0, void 0, RountType.Floor);
      };
      BigNumUtils.getCostString = function(n) {
        return this.getNumberString(n, void 0, void 0, RountType.Ceil);
      };
      BigNumUtils.getNumberString = function(n, fixed, bigFixed, roundType) {
        void 0 === fixed && (fixed = 0);
        void 0 === roundType && (roundType = RountType.Round);
        var _base;
        var tailIdx;
        var num = +n;
        if (0 === num || num && Infinity !== num) {
          if (n < 1e3) return this.roundNum(n, roundType, fixed);
          var base = "" + Math.round(n);
          var digit = 0;
          if (~base.indexOf("e")) {
            var dishu = +base.split("e")[0];
            var zhishu = +base.split("e")[1];
            zhishu += Math.floor(Math.log10(dishu));
            digit = zhishu;
          } else digit = Math.floor(Math.log10(n));
          _base = ~base.indexOf("e") ? +base.split("e")[0] * Math.pow(10, digit % 3) : +base.slice(0, digit % 3 + 4) / 1e3;
          tailIdx = digit / 3 >> 0;
        } else {
          n = n.split("e");
          if (+n[1] < 3) {
            var v = n[0] * Math.pow(10, n[1]);
            return this.roundNum(v, roundType, fixed);
          }
          _base = n[0] * Math.pow(10, n[1] % 3);
          while (_base > 1e3) {
            _base /= 1e3;
            n[1] = +n[1] + 3;
          }
          tailIdx = n[1] / 3 >> 0;
        }
        var tail;
        if (tailIdx < 4) tail = [ "", "K", "M", "B" ][tailIdx]; else {
          var first = (tailIdx - 4) / 26 >> 0;
          var grade = first / 26 >> 0;
          var second = (tailIdx - 4) % 26;
          var a = "abcdefghijklmnopqrstuvwxyz";
          var b = a.toUpperCase();
          tail = (grade < 2 ? a : b)[first % 26] + (grade % 2 ? b : a)[second];
        }
        void 0 === bigFixed && (bigFixed = _base < 10 ? 2 : _base < 100 ? 1 : 0);
        var baseStr = this.roundNum(_base, roundType, bigFixed);
        return baseStr + tail;
      };
      BigNumUtils.roundNum = function(n, type, fixed) {
        var func;
        func = type === RountType.Round ? Math.round : type === RountType.Ceil ? Math.ceil : Math.floor;
        var val;
        if (0 === fixed) val = func(n); else {
          var b = Math.pow(10, fixed);
          val = func(b * n) / b;
        }
        return val.toFixed(fixed);
      };
      BigNumUtils.getFixNumber = function(num, fixed) {
        void 0 === fixed && (fixed = 1);
        var b = Math.pow(10, fixed);
        return Math.floor(num * b) / b;
      };
      BigNumUtils.getPercentString = function(num, fixed) {
        void 0 === fixed && (fixed = 1);
        return "string" === typeof num ? this.getNumberString(this.BNTimes(num, 100), fixed) + "%" : this.getNumberString(100 * num, fixed) + "%";
      };
      return BigNumUtils;
    }();
    exports.default = BigNumUtils;
    cc._RF.pop();
  }, {} ],
  BroadCast: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "082ecq87BtC3qGrtG+cRJqY", "BroadCast");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ListenerBinding = exports.Broadcast = void 0;
    var Broadcast = function() {
      function Broadcast() {
        this.bindings = [];
      }
      Broadcast.prototype.on = function(listener, target) {
        var binding = new ListenerBinding(listener, target, false, this);
        this.bindings.push(binding);
        return binding;
      };
      Broadcast.prototype.once = function(listener, target) {
        var binding = new ListenerBinding(listener, target, true, this);
        this.bindings.push(binding);
        return binding;
      };
      Broadcast.prototype.dispatch = function() {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) params[_i] = arguments[_i];
        var flag = false;
        for (var _a = 0, _b = this.bindings; _a < _b.length; _a++) {
          var item = _b[_a];
          item.hasDestroyed ? flag = true : item.execute.apply(item, params);
        }
        if (flag) for (var i = 0; i < this.bindings.length; i++) if (this.bindings[i].hasDestroyed) {
          this.bindings.splice(i, 1);
          i--;
        }
      };
      Broadcast.prototype.get = function(listener, target) {
        for (var _i = 0, _a = this.bindings; _i < _a.length; _i++) {
          var item = _a[_i];
          if (item.listener == listener && item.target == target && !item.hasDestroyed) return item;
        }
        return null;
      };
      Broadcast.prototype.has = function(listener, target) {
        for (var _i = 0, _a = this.bindings; _i < _a.length; _i++) {
          var item = _a[_i];
          if (item.listener == listener && item.target == target && !item.hasDestroyed) return true;
        }
        return false;
      };
      Broadcast.prototype.remove = function(listener, target) {
        for (var _i = 0, _a = this.bindings; _i < _a.length; _i++) {
          var item = _a[_i];
          if (item.listener == listener && item.target == target && !item.hasDestroyed) return item.destroy();
        }
      };
      Broadcast.prototype.removeAll = function() {
        while (this.bindings.length) this.bindings.pop().destroy();
      };
      return Broadcast;
    }();
    exports.Broadcast = Broadcast;
    var ListenerBinding = function() {
      function ListenerBinding(listener, target, once, boradcast) {
        var _this = this;
        this.destroySelf = function() {
          _this.destroy();
        };
        this.listener = listener;
        this.target = target;
        this.once = once;
        this.broadcast = boradcast;
        this.hasDestroyed = false;
      }
      ListenerBinding.prototype.execute = function() {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) params[_i] = arguments[_i];
        if (!this.hasDestroyed) {
          var result = this.listener.apply(this.target, params);
          this.once && this.destroy();
          return result;
        }
        return null;
      };
      ListenerBinding.prototype.destroy = function() {
        this.listener = null;
        this.target = null;
        this.once = null;
        this.broadcast = null;
        this.hasDestroyed = true;
      };
      return ListenerBinding;
    }();
    exports.ListenerBinding = ListenerBinding;
    cc._RF.pop();
  }, {} ],
  BroadcastCenter: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "c1631mjt99N+bqKIUwCcgeG", "BroadcastCenter");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.BroadcastCenter = exports.BuildingData = void 0;
    var BroadCast_1 = require("../Utils/BroadCast");
    var BuildingData = function() {
      function BuildingData() {}
      return BuildingData;
    }();
    exports.BuildingData = BuildingData;
    var BroadcastCenter = function() {
      function BroadcastCenter() {}
      BroadcastCenter.buildingState = new BroadCast_1.Broadcast();
      return BroadcastCenter;
    }();
    exports.BroadcastCenter = BroadcastCenter;
    BroadcastCenter.buildingState.on(function(data) {
      console.log(data.id, data.state);
    }, this);
    BroadcastCenter.buildingState.dispatch({
      id: 1,
      state: "success"
    });
    cc._RF.pop();
  }, {
    "../Utils/BroadCast": "BroadCast"
  } ],
  BuildGrid: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "3395dyamwJBwo7n/NhvwQge", "BuildGrid");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.BuildGridTyoe = void 0;
    const RoleMgr_1 = require("../Manager/RoleMgr");
    const {ccclass: ccclass, property: property} = cc._decorator;
    var BuildGridTyoe;
    (function(BuildGridTyoe) {
      BuildGridTyoe[BuildGridTyoe["None"] = 0] = "None";
      BuildGridTyoe[BuildGridTyoe["BUildIng"] = 1] = "BUildIng";
      BuildGridTyoe[BuildGridTyoe["BuildOver"] = 2] = "BuildOver";
    })(BuildGridTyoe = exports.BuildGridTyoe || (exports.BuildGridTyoe = {}));
    let BuildGrid = class BuildGrid extends cc.Component {
      constructor() {
        super(...arguments);
        this.succ = null;
        this.warn = null;
        this.icon = null;
        this.buildType = BuildGridTyoe.None;
        this.home = null;
        this.gridData = null;
      }
      onEnable() {
        this.initUI();
      }
      initUI() {
        let node = new cc.Node("icon");
        node.active = false;
        this.icon = node.addComponent(cc.Sprite);
        this.node.addChild(node);
        this.home || (this.home = RoleMgr_1.default.ins.home);
      }
      rightAni(icon) {
        this.succ.active = true;
        this.warn.active = false;
        this.icon.spriteFrame = icon.spriteFrame;
        this.icon.node.active = true;
        this.buildType = BuildGridTyoe.BUildIng;
      }
      warnAni() {
        this.succ.active = false;
        this.warn.active = true;
      }
      reset(isHdIcon = true) {
        this.succ.active = false;
        this.warn.active = false;
        this.icon.node.active = false;
        if (this.buildType === BuildGridTyoe.BuildOver) return;
        if (isHdIcon) this.buildType = BuildGridTyoe.None; else if (this.gridData) {
          this.buildType = BuildGridTyoe.BuildOver;
          const index = this.node.parent.children.indexOf(this.node);
          this.gridData["index"] = index;
          this.home.addDecorate(this.gridData);
        }
      }
    };
    __decorate([ property(cc.Node) ], BuildGrid.prototype, "succ", void 0);
    __decorate([ property(cc.Node) ], BuildGrid.prototype, "warn", void 0);
    BuildGrid = __decorate([ ccclass ], BuildGrid);
    exports.default = BuildGrid;
    cc._RF.pop();
  }, {
    "../Manager/RoleMgr": "RoleMgr"
  } ],
  BuildItem: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "ea244A1eYxBrYNONi3zFvzm", "BuildItem");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const lodash_1 = require("lodash");
    const ListItem_1 = require("../../Common/Components/ListItem");
    const CommonUtils_1 = require("../../Common/Utils/CommonUtils");
    const GlobalData_1 = require("../../Config/GlobalData");
    const TableKey_1 = require("../../Config/TableKey");
    const Game_1 = require("../../Logic/Game");
    const {ccclass: ccclass, property: property, disallowMultiple: disallowMultiple} = cc._decorator;
    let BuildItem = class BuildItem extends ListItem_1.default {
      constructor() {
        super(...arguments);
        this.itemVal = null;
        this.type = "";
        this.build = null;
        this.itemData = null;
        this._storeData = null;
      }
      start() {}
      initUi(data, type, build) {
        console.log("data is ", data);
        this.itemData = data;
        this.build = build;
        this.type = type;
        this.updateVal();
        this.node.width = this.node.height = 130;
        CommonUtils_1.CommonUtils.setItemSpriteFrame(this.icon, `${GlobalData_1.GlobalData.tablePath}${data["ID"]}`);
        this.registerEvent();
      }
      updateVal() {
        let arr = lodash_1.filter(this.storeData.decorates, item => item.ID === this.itemData["ID"]);
        const val = this.itemData.count - arr.length;
        this.itemVal.string = `+${val}`;
        return val;
      }
      initDrag() {
        this.node.getComponent(cc.Sprite).enabled = false;
        this.itemVal.node.parent.active = false;
        this.icon.node.active = true;
        this.node.active = false;
      }
      registerEvent() {
        this.node.on(cc.Node.EventType.TOUCH_START, this.touchStart, this);
        this.node.on(cc.Node.EventType.TOUCH_MOVE, this.build.dragMove.bind(this.build), this);
        this.node.on(cc.Node.EventType.TOUCH_END, this.build.dragEnd.bind(this.build), this);
        this.node.on(cc.Node.EventType.TOUCH_CANCEL, this.build.dragEnd.bind(this.build), this);
      }
      unRegisterEvent() {
        this.node.off(cc.Node.EventType.TOUCH_START, this.touchStart, this);
        if (!this.build) return;
        this.node.off(cc.Node.EventType.TOUCH_MOVE, this.build.dragMove.bind(this.build), this);
        this.node.off(cc.Node.EventType.TOUCH_END, this.build.dragEnd.bind(this.build), this);
        this.node.off(cc.Node.EventType.TOUCH_CANCEL, this.build.dragEnd.bind(this.build), this);
      }
      get storeData() {
        return Game_1.default.dbMgr.query(TableKey_1.TableKey.SHOP, {
          uid: GlobalData_1.GlobalData.userId
        });
      }
      touchStart(event) {
        this.build.dragNode(event, this);
      }
      onDestroy() {
        super.onDestroy();
        this.unRegisterEvent();
      }
      onClickThis() {
        super.onClickThis();
        console.log("RawItem onClickThis");
      }
    };
    __decorate([ property(cc.Label) ], BuildItem.prototype, "itemVal", void 0);
    BuildItem = __decorate([ ccclass ], BuildItem);
    exports.default = BuildItem;
    cc._RF.pop();
  }, {
    "../../Common/Components/ListItem": "ListItem",
    "../../Common/Utils/CommonUtils": "CommonUtils",
    "../../Config/GlobalData": "GlobalData",
    "../../Config/TableKey": "TableKey",
    "../../Logic/Game": "Game",
    lodash: 1
  } ],
  BuildTypeItem: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "a0d91AX8AJHEKjLhEmtPT93", "BuildTypeItem");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const {ccclass: ccclass, property: property} = cc._decorator;
    let BuildTypeItem = class BuildTypeItem extends cc.Component {
      constructor() {
        super(...arguments);
        this.icon = null;
        this.title = null;
        this.selTile = null;
        this.itemData = null;
        this._isSelected = false;
      }
      onLoad() {}
      start() {}
      onEnable() {}
      onDisable() {
        this.unRegisterEvent();
      }
      registerEvent() {
        this.node.on(cc.Node.EventType.TOUCH_END, this.clickTypeNode, this);
      }
      unRegisterEvent() {
        this.node.off(cc.Node.EventType.TOUCH_END, this.clickTypeNode, this);
      }
      initData(data, isSel) {
        this.itemData = data;
        this.title.string = this.selTile.string = data.val;
        this.isSelected = isSel;
        this.registerEvent();
      }
      get isSelected() {
        return this._isSelected;
      }
      set isSelected(val) {
        this._isSelected = val;
        this.icon.node.parent.active = val;
      }
      clickTypeNode(e) {}
    };
    __decorate([ property({
      type: cc.Sprite,
      tooltip: false
    }) ], BuildTypeItem.prototype, "icon", void 0);
    __decorate([ property({
      type: cc.Label,
      tooltip: false
    }) ], BuildTypeItem.prototype, "title", void 0);
    __decorate([ property({
      type: cc.Label,
      tooltip: false
    }) ], BuildTypeItem.prototype, "selTile", void 0);
    BuildTypeItem = __decorate([ ccclass ], BuildTypeItem);
    exports.default = BuildTypeItem;
    cc._RF.pop();
  }, {} ],
  ButtonPlus: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "3eaf8iLxgtDEKVcEmFvrbqy", "ButtonPlus");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var SoundMgr_1 = require("../../UIFrame/SoundMgr");
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, executeInEditMode = _a.executeInEditMode, menu = _a.menu, help = _a.help, inspector = _a.inspector;
    var ButtonPlus = function(_super) {
      __extends(ButtonPlus, _super);
      function ButtonPlus() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.audioUrl = "";
        _this.openContinuous = true;
        _this.continuousTime = 1;
        _this.continuous = false;
        _this._continuousTimer = null;
        _this.openLongPress = false;
        _this.longPressTime = 1;
        _this.longPressFlag = false;
        _this.longPressTimer = null;
        return _this;
      }
      ButtonPlus.prototype.onEnable = function() {
        this.continuous = false;
        _super.prototype.onEnable.call(this);
        true;
      };
      ButtonPlus.prototype.onDisable = function() {
        if (this._continuousTimer) {
          clearTimeout(this._continuousTimer);
          this._continuousTimer = null;
        }
        if (this.longPressTimer) {
          clearTimeout(this.longPressTimer);
          this.longPressTimer = null;
        }
        _super.prototype.onDisable.call(this);
      };
      ButtonPlus.prototype._onTouchBegan = function(event) {
        if (!this.interactable || !this.enabledInHierarchy) return;
        if (this.openLongPress && !this.longPressFlag) {
          this.longPressTimer && clearTimeout(this.longPressTimer);
          this.longPressTimer = setTimeout(function() {
            if (this["_pressed"]) {
              this.node.emit("longclickStart", this);
              this.longPressFlag = true;
            }
          }.bind(this), 1e3 * this.longPressTime);
        }
        this["_pressed"] = true;
        this["_updateState"]();
        event.stopPropagation();
      };
      ButtonPlus.prototype._onTouchEnded = function(event) {
        if (!this.interactable || !this.enabledInHierarchy) return;
        if (this["_pressed"] && this.longPressFlag) {
          this.node.emit("longclickEnd", this);
          this.longPressFlag = false;
        } else if (this["_pressed"] && !this.continuous) {
          this.continuous = !!this.openContinuous;
          cc.Component.EventHandler.emitEvents(this.clickEvents, event);
          this.node.emit("click", event);
          SoundMgr_1.default.inst.playEffect(this.audioUrl);
          this.openContinuous && (this._continuousTimer = setTimeout(function() {
            this.continuous = false;
          }.bind(this), 1e3 * this.continuousTime));
        }
        this["_pressed"] = false;
        this["_updateState"]();
        event.stopPropagation();
      };
      ButtonPlus.prototype._onTouchCancel = function() {
        if (!this.interactable || !this.enabledInHierarchy) return;
        if (this["_pressed"] && this.longPressFlag) {
          this.node.emit("longclickEnd", this);
          this.longPressFlag = false;
        }
        this["_pressed"] = false;
        this["_updateState"]();
      };
      ButtonPlus.prototype.addClick = function(callback, target) {
        this.node.off("click");
        this.node.on("click", callback, target);
      };
      ButtonPlus.prototype.addLongClick = function(startFunc, endFunc, target) {
        this.node.off("longclickStart");
        this.node.off("longclickEnd");
        this.node.on("longclickStart", startFunc, target);
        this.node.on("longclickEnd", endFunc, target);
      };
      __decorate([ property({
        tooltip: "\u97f3\u6548\u8def\u5f84",
        type: "",
        multiline: true,
        formerlySerializedAs: "_N$string"
      }) ], ButtonPlus.prototype, "audioUrl", void 0);
      __decorate([ property({
        tooltip: "\u5c4f\u853d\u8fde\u7eed\u70b9\u51fb"
      }) ], ButtonPlus.prototype, "openContinuous", void 0);
      __decorate([ property({
        tooltip: "\u5c4f\u853d\u65f6\u95f4, \u5355\u4f4d:\u79d2"
      }) ], ButtonPlus.prototype, "continuousTime", void 0);
      __decorate([ property({
        tooltip: "\u662f\u5426\u5f00\u542f\u957f\u6309\u4e8b\u4ef6"
      }) ], ButtonPlus.prototype, "openLongPress", void 0);
      __decorate([ property({
        tooltip: "\u957f\u6309\u65f6\u95f4"
      }) ], ButtonPlus.prototype, "longPressTime", void 0);
      ButtonPlus = __decorate([ ccclass, menu("i18n:MAIN_MENU.component.ui/ButtonPlus"), executeInEditMode, help("i18n:COMPONENT.help_url.button"), inspector("packages://buttonplus/inspector.js") ], ButtonPlus);
      return ButtonPlus;
    }(cc.Button);
    exports.default = ButtonPlus;
    cc._RF.pop();
  }, {
    "../../UIFrame/SoundMgr": "SoundMgr"
  } ],
  CacheUtils: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "f7caav8yMdOrZNrAy/SIOIW", "CacheUtils");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var ResMgr_1 = require("../../UIFrame/ResMgr");
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
    var CacheUtils = function(_super) {
      __extends(CacheUtils, _super);
      function CacheUtils() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.com = null;
        _this.passTime = 0;
        return _this;
      }
      CacheUtils.prototype.onLoad = function() {
        this.com = this.getComponent(cc.Label);
      };
      CacheUtils.prototype.start = function() {
        var _this = this;
        this.node.on(cc.Node.EventType.TOUCH_MOVE, function(e) {
          _this.node.x += e.getDeltaX();
          _this.node.y += e.getDeltaY();
        }, this);
      };
      CacheUtils.prototype.update = function(dt) {
        this.passTime += dt;
        if (this.passTime > 1) {
          this.passTime = 0;
          this.com.string = ResMgr_1.default.inst.computeTextureCache();
        }
      };
      CacheUtils = __decorate([ ccclass ], CacheUtils);
      return CacheUtils;
    }(cc.Component);
    exports.default = CacheUtils;
    cc._RF.pop();
  }, {
    "../../UIFrame/ResMgr": "ResMgr"
  } ],
  CameraCapture: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "29803DQKJdC2KvHyjig9y8N", "CameraCapture");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var CocosHelper_1 = require("../../UIFrame/CocosHelper");
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
    var CameraCapture = function(_super) {
      __extends(CameraCapture, _super);
      function CameraCapture() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.captureNode = null;
        _this.camera = null;
        return _this;
      }
      CameraCapture_1 = CameraCapture;
      CameraCapture.prototype.onLoad = function() {
        CameraCapture_1.inst = this;
        this.camera = this.getComponent(cc.Camera);
        this.camera || (this.camera = this.addComponent(cc.Camera));
        this.node.active = false;
      };
      CameraCapture.prototype.start = function() {};
      CameraCapture.prototype.captureTexture = function() {
        this.node.active = true;
        this.captureNode.active = false;
        var data = CocosHelper_1.default.captureScreen(this.camera, this.captureNode);
        this.captureNode.active = true;
        this.node.active = false;
        return data;
      };
      var CameraCapture_1;
      CameraCapture.inst = null;
      __decorate([ property(cc.Node) ], CameraCapture.prototype, "captureNode", void 0);
      CameraCapture = CameraCapture_1 = __decorate([ ccclass ], CameraCapture);
      return CameraCapture;
    }(cc.Component);
    exports.default = CameraCapture;
    cc._RF.pop();
  }, {
    "../../UIFrame/CocosHelper": "CocosHelper"
  } ],
  ClassHelper: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "8a6f5OHp8dBpb72DtfAMWuK", "ClassHelper");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.GetClassByName = exports.RigisterClass = void 0;
    var ClassMap = cc.js.createMap();
    var RigisterClass = function(name) {
      return function(target) {
        ClassMap[name] = target;
      };
    };
    exports.RigisterClass = RigisterClass;
    var GetClassByName = function(name) {
      return ClassMap[name];
    };
    exports.GetClassByName = GetClassByName;
    cc._RF.pop();
  }, {} ],
  CocosHelper: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "d6791Dm+YVK/qXMfQo5ktVd", "CocosHelper");
    "use strict";
    var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.LoadProgress = void 0;
    const lodash_1 = require("lodash");
    const Logger_1 = require("../Common/Log/Logger");
    class LoadProgress {}
    exports.LoadProgress = LoadProgress;
    class CocosHelper {
      static callInNextTick() {
        return __awaiter(this, void 0, void 0, function*() {
          return new Promise((resolve, reject) => {
            setTimeout(() => {
              resolve(true);
            }, 0);
          });
        });
      }
      static runRepeatTweenSync(target, repeat, ...tweens) {
        return __awaiter(this, void 0, void 0, function*() {
          return new Promise((resolve, reject) => {
            let selfTween = cc.tween(target);
            for (const tmpTween of tweens) selfTween = selfTween.then(tmpTween);
            repeat < 0 ? cc.tween(target).repeatForever(selfTween).start() : cc.tween(target).repeat(repeat, selfTween).call(() => {
              resolve(true);
            }).start();
          });
        });
      }
      static runTweenSync(target, ...tweens) {
        return __awaiter(this, void 0, void 0, function*() {
          return new Promise((resolve, reject) => {
            let selfTween = cc.tween(target);
            for (const tmpTween of tweens) selfTween = selfTween.then(tmpTween);
            selfTween.call(() => {
              resolve();
            }).start();
          });
        });
      }
      stopTween(target) {
        cc.Tween.stopAllByTarget(target);
      }
      stopTweenByTag(tag) {
        cc.Tween.stopAllByTag(tag);
      }
      static runActionSync(node, ...actions) {
        return __awaiter(this, void 0, void 0, function*() {
          if (!actions || actions.length <= 0) return;
          return new Promise((resolve, reject) => {
            actions.push(cc.callFunc(() => {
              resolve(true);
            }));
            node.runAction(cc.sequence(actions));
          });
        });
      }
      static runAnimSync(node, animName) {
        return __awaiter(this, void 0, void 0, function*() {
          let anim = node.getComponent(cc.Animation);
          if (!anim) return;
          let clip = null;
          if (animName) {
            let clips = anim.getClips();
            if ("number" === typeof animName) clip = clips[animName]; else if ("string" === typeof animName) for (let i = 0; i < clips.length; i++) if (clips[i].name === animName) {
              clip = clips[i];
              break;
            }
          } else clip = anim.defaultClip;
          if (!clip) return;
          yield CocosHelper.sleepSync(clip.duration);
        });
      }
      static loadResThrowErrorSync(url, type, onProgress) {
        return null;
      }
      static loadRes(url, type, callback) {
        if (this._loadingMap[url]) {
          this._loadingMap[url].push(callback);
          return;
        }
        this._loadingMap[url] = [ callback ];
        this.loadResSync(url, type).then(data => {
          let arr = this._loadingMap[url];
          for (const func of arr) func(data);
          this._loadingMap[url] = null;
          delete this._loadingMap[url];
        });
      }
      static loadResSync(url, type, onProgress) {
        return new Promise((resolve, reject) => {
          onProgress || (onProgress = this._onProgress);
          cc.resources.load(url, type, onProgress, (err, asset) => {
            if (err) {
              cc.error(`${url} [\u8d44\u6e90\u52a0\u8f7d] \u9519\u8bef ${err}`);
              resolve(null);
            } else resolve(asset);
          });
        });
      }
      static preLoadResSync(url, type, onProgress) {
        return new Promise((resolve, reject) => {
          onProgress || (onProgress = this._onProgress);
          cc.resources.preload(url, type, onProgress, (err, asset) => {
            if (err) {
              cc.error(`${url} [\u8d44\u6e90\u52a0\u8f7d] \u9519\u8bef ${err}`);
              resolve(null);
            } else resolve(asset);
          });
        });
      }
      static replaceComponent(node, componentName, newComponent) {
        try {
          let temp = newComponent["_disallowMultiple"];
          newComponent["_disallowMultiple"] = false;
          node.addComponent(newComponent);
          newComponent["_disallowMultiple"] = temp;
          for (let key in node.getComponent(componentName)) (node.getComponent(componentName)[key] instanceof cc.Object || node.getComponent(componentName)[key] instanceof Array) && "node" !== key && (node.getComponent(newComponent)[key] = node.getComponent(componentName)[key]);
          lodash_1.remove(node["_components"], node.getComponent(componentName));
        } catch (error) {
          Logger_1.Logger.logBusiness("error ========", error.message);
        }
      }
      static _onProgress(completedCount, totalCount, item) {
        CocosHelper.loadProgress.completedCount = completedCount;
        CocosHelper.loadProgress.totalCount = totalCount;
        CocosHelper.loadProgress.item = item;
        CocosHelper.loadProgress.cb && CocosHelper.loadProgress.cb(completedCount, totalCount, item);
      }
      static findChildInNode(nodeName, rootNode) {
        if (rootNode.name == nodeName) return rootNode;
        for (let i = 0; i < rootNode.childrenCount; i++) {
          let node = this.findChildInNode(nodeName, rootNode.children[i]);
          if (node) return node;
        }
        return null;
      }
      static getComponentName(com) {
        let arr = com.name.match(/<.*>$/);
        if (arr && arr.length > 0) return arr[0].slice(1, -1);
        return com.name;
      }
      static loadBundleSync(url, options) {
        return new Promise((resolve, reject) => {
          cc.assetManager.loadBundle(url, options, (err, bundle) => {
            if (err) {
              cc.error(`\u52a0\u8f7dbundle\u5931\u8d25, url: ${url}, err:${err}`);
              resolve(null);
            } else resolve(bundle);
          });
        });
      }
      static loadAssetFromBundleSync(bundleName, url) {
        let bundle = cc.assetManager.getBundle(bundleName);
        if (!bundle) {
          cc.error(`\u52a0\u8f7dbundle\u4e2d\u7684\u8d44\u6e90\u5931\u8d25, \u672a\u627e\u5230bundle, bundleUrl:${bundleName}`);
          return null;
        }
        return new Promise((resolve, reject) => {
          bundle.load(url, (err, asset) => {
            if (err) {
              cc.error(`\u52a0\u8f7dbundle\u4e2d\u7684\u8d44\u6e90\u5931\u8d25, \u672a\u627e\u5230asset, url:${url}, err:${err}`);
              resolve(null);
            } else resolve(asset);
          });
        });
      }
      static loadAssetSync(url) {
        return new Promise((resolve, reject) => {
          cc.resources.load(url, (err, assets) => {
            if (err) {
              this.addRef(assets);
              resolve(assets);
            } else {
              cc.error(`\u52a0\u8f7dasset\u5931\u8d25, url:${url}, err: ${err}`);
              resolve(null);
            }
          });
        });
      }
      static releaseAsset(assets) {
        this.decRes(assets);
      }
      static addRef(assets) {
        if (assets instanceof Array) for (const a of assets) a.addRef(); else assets.addRef();
      }
      static decRes(assets) {
        if (assets instanceof Array) for (const a of assets) a.decRef(); else assets.decRef();
      }
      static captureScreen(camera, prop) {
        let newTexture = new cc.RenderTexture();
        let oldTexture = camera.targetTexture;
        let rect = cc.rect(0, 0, cc.visibleRect.width, cc.visibleRect.height);
        prop && (rect = prop instanceof cc.Node ? prop.getBoundingBoxToWorld() : prop);
        newTexture.initWithSize(cc.visibleRect.width, cc.visibleRect.height, cc.game._renderContext.STENCIL_INDEX8);
        camera.targetTexture = newTexture;
        camera.render();
        camera.targetTexture = oldTexture;
        let buffer = new ArrayBuffer(rect.width * rect.height * 4);
        let data = new Uint8Array(buffer);
        newTexture.readPixels(data, rect.x, rect.y, rect.width, rect.height);
        return data;
      }
    }
    exports.default = CocosHelper;
    CocosHelper.loadProgress = new LoadProgress();
    CocosHelper.sleepSync = function(dur) {
      return new Promise((resolve, reject) => {
        cc.Canvas.instance.scheduleOnce(() => {
          resolve(true);
        }, dur);
      });
    };
    CocosHelper._loadingMap = {};
    cc._RF.pop();
  }, {
    "../Common/Log/Logger": "Logger",
    lodash: 1
  } ],
  Coffee: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "071a9kn30BEsouzuJRkjaZl", "Coffee");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const CommonUtils_1 = require("../Common/Utils/CommonUtils");
    const GlobalData_1 = require("../Config/GlobalData");
    const MessageInfo_1 = require("../Config/MessageInfo");
    const CocosHelper_1 = require("../UIFrame/CocosHelper");
    const UIToast1_1 = require("../UIScript/toast/UIToast1");
    const RoleMgr_1 = require("./Manager/RoleMgr");
    const {ccclass: ccclass, property: property} = cc._decorator;
    let Coffee = class Coffee extends cc.Component {
      constructor() {
        super(...arguments);
        this.tumbler_b = null;
        this.tumbler_f = null;
        this.coffee = null;
        this.coffeeMaterial = null;
        this.desk = null;
        this.topAnimaStep = .1;
        this.topAnimaSpeed = .1;
        this.initWaveHeight = .1;
        this.tempWaveHeight = .9;
      }
      start() {
        this.init();
      }
      initData(desk) {
        this.desk = desk;
      }
      init() {
        this.node.active = false;
        this.node.position = cc.v3(0, 61);
        this.node.angle = 8;
        this.initWaveHeight = .1;
        this.tempWaveHeight = .9;
        this.coffee.setMaterial(0, this.coffeeMaterial);
        this.coffeeMaterial = this.coffee.getMaterial(0);
        this.coffeeMaterial.setProperty("isWave", .3);
        this.coffeeMaterial.setProperty("waveHeight", this.tempWaveHeight);
      }
      changeCoffer(makeRecipe) {
        if (makeRecipe) {
          CommonUtils_1.CommonUtils.setItemSpriteFrame(this.coffee, `${GlobalData_1.GlobalData.coffeeTypePath}${makeRecipe.ID}`);
          CommonUtils_1.CommonUtils.setItemSpriteFrame(this.tumbler_b, `${GlobalData_1.GlobalData.tumblerePath}${makeRecipe["tumbler_b"]}`);
          CommonUtils_1.CommonUtils.setItemSpriteFrame(this.tumbler_f, `${GlobalData_1.GlobalData.tumblerePath}${makeRecipe["tumbler_f"]}`);
        }
      }
      runTopUp() {
        this.coffeeMaterial.setProperty("isWave", .4);
        this.coffeeMaterial.setProperty("waveHeight", this.tempWaveHeight);
        this.desk.view.Scroll.node.pauseSystemEvents(true);
        this.desk.view.Menu.pauseSystemEvents(true);
        this.schedule(this.topUpAnima, this.topAnimaSpeed);
      }
      topUpAnima() {
        return __awaiter(this, void 0, void 0, function*() {
          this.tempWaveHeight -= .08;
          if (this.tempWaveHeight > .3) this.coffeeMaterial.setProperty("waveHeight", this.tempWaveHeight); else {
            this.coffeeMaterial.setProperty("isWave", .2);
            this.tempWaveHeight = this.initWaveHeight;
            this.unschedule(this.topUpAnima);
            this.desk.view.Scroll.node.resumeSystemEvents(true);
            this.desk.view.Menu.resumeSystemEvents(true);
            UIToast1_1.default.open({
              info: MessageInfo_1.MessageInfo.makeSucc
            });
            this.resetDeskBtn();
            yield CocosHelper_1.default.runTweenSync(this.node, cc.tween().by(.5, {
              position: cc.v3(-this.node.parent.position.x, 0)
            }));
          }
        });
      }
      resetDeskBtn() {
        const pos = this.desk.tempRestormPos.clone();
        this.desk.view.Reform.position = pos;
        this.desk.view.Menu.active = false;
        RoleMgr_1.default.ins.firstRole ? this.desk.view.Ok.active = true : this.desk.view.Reform.position = cc.v3(0, pos.y, pos.z);
        this.desk.view.Reform.active = true;
      }
    };
    __decorate([ property(cc.Sprite) ], Coffee.prototype, "tumbler_b", void 0);
    __decorate([ property(cc.Sprite) ], Coffee.prototype, "tumbler_f", void 0);
    __decorate([ property(cc.Sprite) ], Coffee.prototype, "coffee", void 0);
    __decorate([ property(cc.Material) ], Coffee.prototype, "coffeeMaterial", void 0);
    Coffee = __decorate([ ccclass ], Coffee);
    exports.default = Coffee;
    cc._RF.pop();
  }, {
    "../Common/Utils/CommonUtils": "CommonUtils",
    "../Config/GlobalData": "GlobalData",
    "../Config/MessageInfo": "MessageInfo",
    "../UIFrame/CocosHelper": "CocosHelper",
    "../UIScript/toast/UIToast1": "UIToast1",
    "./Manager/RoleMgr": "RoleMgr"
  } ],
  CoinFlyToWallet: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "6dee99TpiFFUriHS1xOtoKO", "CoinFlyToWallet");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CoinFlyToWallet = void 0;
    const {ccclass: ccclass, property: property} = cc._decorator;
    let CoinFlyToWallet = class CoinFlyToWallet extends cc.Component {
      constructor() {
        super(...arguments);
        this.isRandomToggle = true;
        this.minNumEditBox = 10;
        this.maxNumEditBox = 25;
        this.radiusNumEditBox = 130;
        this.viewWinSize = new cc.Size(0, 0);
        this.startNodeUIPos = new cc.Vec3();
        this.endNodeUIPos = new cc.Vec3();
        this.isCoinRandomGenerate = true;
      }
      onLoad() {
        this.coinPool = new cc.NodePool();
        this.viewWinSize = cc.view.getVisibleSize();
        this.initCoinPool();
        this.isRandomToggle = this.isCoinRandomGenerate;
        this.startNode.on(cc.Node.EventType.TOUCH_MOVE, this.onNodeMoveEvent, this);
        this.endNode.on(cc.Node.EventType.TOUCH_MOVE, this.onNodeMoveEvent, this);
      }
      initCoinPool(count = 20) {
        for (let i = 0; i < count; i++) {
          let coin = cc.instantiate(this.coinPrefab);
          this.coinPool.put(coin);
        }
      }
      playAnim(callback) {
        const minNum = this.minNumEditBox || 10;
        const maxNum = this.maxNumEditBox || 25;
        const diffNum = maxNum - minNum;
        const radiusNum = this.radiusNumEditBox || 130;
        let randomCount = Math.random() * diffNum + minNum;
        let startPos = this.startNode.getPosition();
        let endPos = this.endNode.getPosition();
        this.playCoinFlyAnim(randomCount, cc.v3(startPos), cc.v3(endPos), radiusNum, callback);
      }
      playCoinFlyAnim(count, stPos, edPos, r = 130, callback) {
        const poolSize = this.coinPool.size();
        const reCreateCoinCount = poolSize > count ? 0 : count - poolSize;
        this.initCoinPool(reCreateCoinCount);
        let points = this.getCirclePoints(r, stPos, count);
        let coinNodeList = points.map(pos => {
          let coin = this.coinPool.get();
          coin.setPosition(stPos);
          cc.find("Canvas").addChild(coin);
          const tempPos = pos.clone();
          return {
            node: coin,
            stPos: stPos,
            mdPos: pos,
            edPos: edPos,
            dis: tempPos.subtract(edPos).len()
          };
        });
        coinNodeList = coinNodeList.sort((a, b) => {
          if (a.dis - b.dis > 0) return 1;
          if (a.dis - b.dis < 0) return -1;
          return 0;
        });
        coinNodeList.forEach((item, idx) => {
          cc.tween(item.node).stop();
          item.node.setPosition(item.stPos);
          cc.tween(item.node).to(.3, {
            position: item.mdPos
          }).delay(.01 * idx).to(.5, {
            position: item.edPos
          }).call(() => {
            this.coinPool.put(item.node);
            idx + 1 === coinNodeList.length && callback();
          }).start();
        });
      }
      getCirclePoints(r, pos, count, randomScope = 60) {
        let points = [];
        let radians = Math.PI / 180 * Math.round(360 / count);
        for (let i = 0; i < count; i++) {
          let x = pos.x + r * Math.sin(radians * i);
          let y = pos.y + r * Math.cos(radians * i);
          this.isCoinRandomGenerate ? points.unshift(new cc.Vec3(x + Math.random() * randomScope, y + Math.random() * randomScope, 0)) : points.unshift(new cc.Vec3(x, y, 0));
        }
        return points;
      }
      onNodeMoveEvent(evt) {
        let localPos = evt.getUILocation();
        let target = evt.target;
        let setPosX = localPos.x - this.viewWinSize.width / 2;
        let setPosY = localPos.y - this.viewWinSize.height / 2;
        target.setPosition(setPosX, setPosY, 0);
      }
      onToggleEvent(evt) {
        this.isCoinRandomGenerate = this.isRandomToggle;
      }
    };
    __decorate([ property(cc.Node) ], CoinFlyToWallet.prototype, "startNode", void 0);
    __decorate([ property(cc.Node) ], CoinFlyToWallet.prototype, "endNode", void 0);
    __decorate([ property(cc.Prefab) ], CoinFlyToWallet.prototype, "coinPrefab", void 0);
    __decorate([ property(cc.Boolean) ], CoinFlyToWallet.prototype, "isRandomToggle", void 0);
    __decorate([ property(cc.Integer) ], CoinFlyToWallet.prototype, "minNumEditBox", void 0);
    __decorate([ property(cc.Integer) ], CoinFlyToWallet.prototype, "maxNumEditBox", void 0);
    __decorate([ property(cc.Integer) ], CoinFlyToWallet.prototype, "radiusNumEditBox", void 0);
    CoinFlyToWallet = __decorate([ ccclass("CoinFlyToWallet") ], CoinFlyToWallet);
    exports.CoinFlyToWallet = CoinFlyToWallet;
    cc._RF.pop();
  }, {} ],
  CommonUtils: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "9814d/85SFDfo1f4MmYfH4s", "CommonUtils");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.CommonUtils = void 0;
    const CocosHelper_1 = require("../../UIFrame/CocosHelper");
    const MatchUtils_1 = require("./MatchUtils");
    let kDefaultRandomGenerator = {
      nextInt: (start, endAndNotIncluded) => Math.floor(Math.random() * (endAndNotIncluded - start)) + start,
      next01: () => Math.random()
    };
    class CommonUtils {
      static isArray(target) {
        return "function" === typeof Array.isArray ? Array.isArray(target) : "[object Array]" === Object.prototype.toString.call(target);
      }
      static foramtDate(dateObj, format) {
        var date = {
          "M+": dateObj.getMonth() + 1,
          "d+": dateObj.getDate(),
          "h+": dateObj.getHours(),
          "m+": dateObj.getMinutes(),
          "s+": dateObj.getSeconds(),
          "q+": Math.floor((dateObj.getMonth() + 3) / 3),
          "S+": dateObj.getMilliseconds()
        };
        /(y+)/i.test(format) && (format = format.replace(RegExp.$1, (dateObj.getFullYear() + "").substr(4 - RegExp.$1.length)));
        for (var k in date) new RegExp("(" + k + ")").test(format) && (format = format.replace(RegExp.$1, ("00" + date[k]).substr(("" + date[k]).length)));
        return format;
      }
      static getElemClamped(arr, index) {
        return arr[Math.max(0, Math.min(arr.length - 1, index))];
      }
      static randomIntClosedRange(min, max) {
        return Math.floor(Math.random() * (max - min + .9999) + min);
      }
      static indexOf(val, arr) {
        for (let i = 0; i < arr.length; i++) if (arr[i] == val) return i;
        return -1;
      }
      static indexOfArr(arr, ...values) {
        let paramCount = values.length;
        let found = false;
        for (let i = 0; i <= arr.length - paramCount; i += paramCount) {
          found = true;
          for (let j = 0; j < paramCount; j++) if (arr[i + j] !== values[j]) {
            found = false;
            break;
          }
          if (found) return i;
        }
        return -1;
      }
      static floatEqual(left, right, epsilon = 1e-6) {
        return Math.abs(left - right) < epsilon;
      }
      static formatTimeInterval(seconds, alwaysShowMinutes = false, alwaysShowHours = false) {
        alwaysShowMinutes = alwaysShowHours || alwaysShowMinutes;
        let ret = "";
        let hour = Math.floor(seconds / 3600);
        seconds %= 3600;
        let minute = Math.floor(seconds / 60);
        seconds = Math.floor(seconds % 60);
        if (alwaysShowHours || hour > 0) {
          hour < 10 && (ret += "0");
          ret += hour + ":";
        }
        if (alwaysShowMinutes || minute > 0 || hour > 0) {
          minute < 10 && (ret += "0");
          ret += minute + ":";
        }
        seconds < 10 && (ret += "0");
        ret += seconds;
        return ret;
      }
      static alignNumber(input, divider) {
        input -= Math.floor(input / divider) * divider;
        return input;
      }
      static formatNumber(num) {
        var str = "" + Math.floor(num);
        var newStr = "";
        var count = 0;
        if (-1 == str.indexOf(".")) {
          for (var i = str.length - 1; i >= 0; i--) {
            newStr = count % 3 == 0 && 0 != count ? str.charAt(i) + "," + newStr : str.charAt(i) + newStr;
            count++;
          }
          str = newStr;
          return str;
        }
        for (var i = str.indexOf(".") - 1; i >= 0; i--) {
          newStr = count % 3 == 0 && 0 != count ? str.charAt(i) + "," + newStr : str.charAt(i) + newStr;
          count++;
        }
        str = newStr + (str + "00").substr((str + "00").indexOf("."), 3);
        return str;
      }
      static updateLabelSize(label) {
        label["_updateRenderData"](true);
      }
      static lerp(begin, end, factor) {
        return begin + (end - begin) * factor;
      }
      static shuffle(container, randGenerator = kDefaultRandomGenerator, start = 0, count = -1) {
        randGenerator = randGenerator || kDefaultRandomGenerator;
        count < 0 && (count = container.length - start);
        for (let i = 0; i < count; i++) {
          let idx = randGenerator.nextInt(start, start + count - i);
          let temp = container[idx];
          container[idx] = container[count - i - 1 + start];
          container[count - i - 1 + start] = temp;
        }
      }
      static setItemSpriteFrame(sprite, url, successCB = null) {
        sprite["spriteFrameName"] = url;
        CocosHelper_1.default.loadResSync(url, cc.SpriteFrame).then(spriteFrame => {
          if (sprite.isValid && sprite["spriteFrameName"] == url) {
            sprite.spriteFrame = spriteFrame;
            successCB && successCB(sprite);
          }
        });
      }
      static addSimpleClick(target, cb) {
        let targetNode = target;
        let lastTouchPos = null;
        targetNode.on(cc.Node.EventType.TOUCH_START, e => {
          lastTouchPos = e.getLocation();
        }, this);
        targetNode.on(cc.Node.EventType.TOUCH_END, e => {
          if (lastTouchPos) {
            let delta = lastTouchPos.subSelf(e.getLocation()).mag();
            delta < 3 && cb();
          }
        }, this);
      }
      static isGoodNumber(num) {
        return "number" === typeof num && !Number.isNaN(num);
      }
      static getVisibleRect() {
        let visibleRect = cc.view.getViewportRect();
        visibleRect = cc.rect(visibleRect.origin.x / -cc.view.getScaleX(), visibleRect.origin.y / -cc.view.getScaleY(), (visibleRect.size.width + 2 * visibleRect.origin.x) / cc.view.getScaleX(), (visibleRect.size.height + 2 * visibleRect.origin.y) / cc.view.getScaleY());
        return visibleRect;
      }
      static httpGet(url, cb) {
        let xhr = cc.loader.getXMLHttpRequest();
        xhr.onreadystatechange = function() {
          if (4 === xhr.readyState && 200 == xhr.status) {
            let respone = xhr.responseText;
            let rsp = JSON.parse(respone);
            cb(rsp);
          } else 4 === xhr.readyState && 401 == xhr.status && cb({
            ret: 1
          });
        };
        xhr.withCredentials = true;
        xhr.open("GET", url, true);
        xhr.withCredentials = false;
        xhr.setRequestHeader("Access-Control-Allow-Origin", "*");
        xhr.setRequestHeader("Access-Control-Allow-Methods", "GET, POST");
        xhr.setRequestHeader("Access-Control-Allow-Headers", "x-requested-with,content-type,authorization");
        xhr.setRequestHeader("Content-Type", "application/json");
        xhr.timeout = 8e3;
        xhr.send();
      }
      static randomGaussian(avg, variant, randGenerator = kDefaultRandomGenerator) {
        randGenerator = randGenerator || kDefaultRandomGenerator;
        let x1 = randGenerator.next01();
        let x2 = randGenerator.next01();
        let standard = Math.sqrt(-2 * Math.log(x1)) * Math.cos(2 * Math.PI * x2);
        return standard * variant + avg;
      }
      static deepCopy(dst, src) {
        for (let field in src) this._deepCopyFields(dst, src, field);
      }
      static constructObjectMap(obj) {
        let map = new Map();
        for (let key in obj) {
          let val = obj[key];
          "object" === typeof val ? map.set(key, this.constructObjectMap(val)) : map.set(key, val);
        }
        return map;
      }
      static _deepCopyFields(dst, src, field) {
        let value = src[field];
        if ("number" == typeof value || "string" == typeof value) dst[field] = value; else if (this.isArray[value]) {
          let dstArr = dst[field] = [];
          for (let i = 0; i < value.length; i++) this._deepCopyFields(dstArr, value, i);
        } else if (null == value) dst[field] = null; else if ("object" == typeof value) {
          let dstObj = new value.constructor();
          for (let field in src) this._deepCopyFields(dstObj, value, field);
        }
      }
      static formatNumberToEng(value) {
        if (value < 1 && value > 0) return "1";
        value = Math.floor(value);
        var exp = Math.floor(CommonUtils.getExponent(value));
        if (exp < 13) {
          if (exp < 4) return value + "";
          var unitIt = Math.floor(exp / CommonUtils.constNum);
          var rem = exp % CommonUtils.constNum;
          var numStr = String(value / Math.pow(10, unitIt * CommonUtils.constNum)).substr(0, CommonUtils.constNum + rem);
          return numStr + CommonUtils.getUnit(exp);
        }
        var _num = value / Math.pow(10, exp);
        return _num.toFixed(3) + "e" + exp;
      }
      static getExponent(value) {
        var exp = 0;
        while (value >= 10) {
          exp++;
          value /= 10;
        }
        return exp;
      }
      static getUnit(exp) {
        var unitIt = Math.floor(exp / CommonUtils.constNum);
        if (exp < 13) return CommonUtils.unitArr[unitIt];
        var unitIt = Math.floor(exp / CommonUtils.constNum);
        return "e" + unitIt * CommonUtils.constNum;
      }
      static formatEngNumber(number, decimals = 2) {
        var str;
        var num;
        number = number;
        if (number >= 1e6) {
          num = number / 1e6;
          str = (.001 * Math.floor(num / .001)).toFixed(decimals);
          return this.formatEndingZero(str) + "M";
        }
        if (number >= 1e3) {
          num = number / 1e3;
          str = (.001 * Math.floor(num / .001)).toFixed(decimals);
          return this.formatEndingZero(str) + "K";
        }
        return number + "";
      }
      static formatEndingZero(c) {
        if (-1 != c.indexOf(".")) {
          if (this.endWith(c, "00")) return c.substring(0, c.length - 3);
          if (this.endWith(c, "0")) return c.substring(0, c.length - 1);
        }
        return c;
      }
      static endWith(c, suffix) {
        return suffix == c.substring(c.length - suffix.length);
      }
      static makeMaxWidthLabel(label, width) {
        let obj = {};
        obj["__proto__"] = label;
        Object.defineProperty(obj, "string", {
          configurable: true,
          enumerable: true,
          get: () => label.string,
          set(str) {
            label.overflow = cc.Label.Overflow.NONE;
            label.string = str;
            label["_updateRenderData"](true);
            if (label.node.width > width) {
              label.overflow = cc.Label.Overflow.RESIZE_HEIGHT;
              label.node.setContentSize(width, 1);
              label.string = str;
            }
          }
        });
        return obj;
      }
      static climeUserName(name, showLen = 14) {
        let len = name.length;
        while (this.strlen(name) > showLen) name = name.substring(0, name.length - 1);
        name.length != len && (name += "...");
        return name;
      }
      static strlen(str) {
        let len = 0;
        for (let i = 0; i < str.length; i++) {
          let c = str.charCodeAt(i);
          c >= 1 && c <= 126 || 65376 <= c && c <= 65439 ? len++ : len += 2;
        }
        return len;
      }
      static shuffleArr(arr) {
        let _swap = (a, b) => {
          let tmp = arr[a];
          arr[a] = arr[b];
          arr[b] = tmp;
        };
        let len = arr.length;
        for (let i = 0; i < len; i++) {
          let idx = Math.floor(Math.random() * (len - i));
          _swap(idx, len - i - 1);
        }
        return arr;
      }
      static binarySearch(arr, target, findFlag = false) {
        let start = 0, end = arr.length - 1;
        while (end - start > 1) {
          var idx = Math.floor((start + end) / 2);
          if (target < arr[idx]) end = idx; else {
            if (!(target > arr[idx])) return idx;
            start = idx;
          }
        }
        if (findFlag) {
          if (start == arr.length - 1) return arr.length;
          return end;
        }
        if (0 == end) return -1;
        return start;
      }
      static isInTriangle(point, triA, triB, triC) {
        let AB = triB.sub(triA), AC = triC.sub(triA), BC = triC.sub(triB), AD = point.sub(triA), BD = point.sub(triB);
        return AB.cross(AC) >= 0 ^ AB.cross(AD) < 0 && AB.cross(AC) >= 0 ^ AC.cross(AD) >= 0 && BC.cross(AB) > 0 ^ BC.cross(BD) >= 0;
      }
      static isInPolygon(checkPoint, polygonPoints) {
        let counter = 0, i, xinters;
        let p1, p2;
        let pointCount = polygonPoints.length;
        p1 = polygonPoints[0];
        for (i = 1; i <= pointCount; i++) {
          p2 = polygonPoints[i % pointCount];
          if (checkPoint.x > Math.min(p1.x, p2.x) && checkPoint.x <= Math.max(p1.x, p2.x) && checkPoint.y <= Math.max(p1.y, p2.y) && p1.x != p2.x) {
            xinters = (checkPoint.x - p1.x) * (p2.y - p1.y) / (p2.x - p1.x) + p1.y;
            (p1.y == p2.y || checkPoint.y <= xinters) && counter++;
          }
          p1 = p2;
        }
        return 0 !== (1 & counter);
      }
      static splitePolygon(points) {
        if (points.length <= 3) return [ 0, 1, 2 ];
        let pointMap = {};
        for (let i = 0; i < points.length; i++) {
          let p = points[i];
          pointMap[`${p.x}-${p.y}`] = i;
        }
        const getIdx = p => pointMap[`${p.x}-${p.y}`];
        points = points.concat([]);
        let idxs = [];
        let index = 0;
        while (points.length > 3) {
          let p1 = points[index % points.length], p2 = points[(index + 1) % points.length], p3 = points[(index + 2) % points.length];
          let splitPoint = (index + 1) % points.length;
          let v1 = p2.sub(p1);
          let v2 = p3.sub(p2);
          if (v1.cross(v2) < 0) {
            index = (index + 1) % points.length;
            continue;
          }
          let hasPoint = false;
          for (const p of points) if (p != p1 && p != p2 && p != p3 && this.isInTriangle(p, p1, p2, p3)) {
            hasPoint = true;
            break;
          }
          if (hasPoint) {
            index = (index + 1) % points.length;
            continue;
          }
          idxs.push(getIdx(p1), getIdx(p2), getIdx(p3));
          points.splice(splitPoint, 1);
        }
        for (const p of points) idxs.push(getIdx(p));
        return idxs;
      }
      static computeUv(points, width, height) {
        let uvs = [];
        for (const p of points) {
          let x = MatchUtils_1.MathUtils.clamp(0, 1, (p.x + width / 2) / width);
          let y = MatchUtils_1.MathUtils.clamp(0, 1, 1 - (p.y + height / 2) / height);
          uvs.push(cc.v2(x, y));
        }
        return uvs;
      }
      static tweenFloat(from, to, duration, onUpdate, onComplete, autoStart = true) {
        let o = {
          _value: from
        };
        Object.defineProperty(o, "value", {
          get: () => o._value,
          set: v => {
            o._value = v;
            onUpdate && onUpdate(o._value);
          }
        });
        let tween = cc.tween(o).to(duration, {
          value: to
        }).call(onComplete);
        autoStart && tween.start();
        return tween;
      }
      static tweenVec2(from, to, duration, onUpdate, onComplete, autoStart = true) {
        let o = {
          _value: from
        };
        Object.defineProperty(o, "value", {
          get: () => o._value,
          set: v => {
            o._value = v;
            onUpdate && onUpdate(o._value);
          }
        });
        let tween = cc.tween(o).to(duration, {
          value: to
        }).call(onComplete);
        autoStart && tween.start();
        return tween;
      }
      static checkIconSize(curNode, maxNum) {
        let width = curNode.width;
        let height = curNode.height;
        let isLorP = width >= height;
        let scale;
        if (isLorP) {
          if (width == maxNum) return;
          scale = maxNum / width;
        } else {
          if (height == maxNum) return;
          scale = maxNum / height;
        }
        curNode.setScale(scale);
      }
    }
    exports.CommonUtils = CommonUtils;
    CommonUtils.unitArr = [ "", "K", "M", "B" ];
    CommonUtils.constNum = 3;
    cc._RF.pop();
  }, {
    "../../UIFrame/CocosHelper": "CocosHelper",
    "./MatchUtils": "MatchUtils"
  } ],
  ConfigMgr: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "99faeZt2e5AobpvQuyUBgaI", "ConfigMgr");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = this && this.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (1 & t[0]) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, "function" === typeof Symbol && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([ n, v ]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = 2 & op[0] ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 
          0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          (y = 0, t) && (op = [ 2 & op[0], t.value ]);
          switch (op[0]) {
           case 0:
           case 1:
            t = op;
            break;

           case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

           case 5:
            _.label++;
            y = op[1];
            op = [ 0 ];
            continue;

           case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;

           default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (6 === op[0] || 2 === op[0])) {
              _ = 0;
              continue;
            }
            if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (6 === op[0] && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop();
            _.trys.pop();
            continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [ 6, e ];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (5 & op[0]) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var BaseMgr_1 = require("./BaseMgr");
    var ConfigMgr = function(_super) {
      __extends(ConfigMgr, _super);
      function ConfigMgr() {
        return null !== _super && _super.apply(this, arguments) || this;
      }
      ConfigMgr.prototype.loadConfigs = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            return [ 2 ];
          });
        });
      };
      ConfigMgr.prototype.onConfigChange = function() {
        this.game.playerMgr.onConfigChange();
      };
      return ConfigMgr;
    }(BaseMgr_1.BaseMgr);
    exports.default = ConfigMgr;
    cc._RF.pop();
  }, {
    "./BaseMgr": "BaseMgr"
  } ],
  DataMgr: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "8c3adSPr7ZNM6RdYn85yXla", "DataMgr");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const lodash_1 = require("lodash");
    const StorageManager_1 = require("../../Common/Storage/StorageManager");
    const GlobalData_1 = require("../../Config/GlobalData");
    const BaseMgr_1 = require("./BaseMgr");
    class DataMgr extends BaseMgr_1.BaseMgr {
      constructor(game) {
        super(game);
        this.storageMgr = null;
        this._gameData = new Map();
        this.storageMgr = new StorageManager_1.StorageManager();
        this.storageMgr.init(GlobalData_1.GlobalData.encrypKey, GlobalData_1.GlobalData.encrypIv);
      }
      query(table, where) {
        let list = this.queryList(table);
        if (where) {
          let index = lodash_1.findIndex(list, where);
          list = list[index];
        }
        return list;
      }
      queryList(table) {
        let list = this._gameData.get(table);
        if (!list) {
          const json = this.storageMgr.get(table);
          if (json) {
            list = JSON.parse(json);
            this._gameData.set(table, list);
          }
        }
        list || (list = []);
        return list;
      }
      insert(table, data) {
        let list = this.queryList(table);
        if (data && data.uid) {
          let findData = lodash_1.find(list, item => item.uid === data.uid);
          if (!findData) {
            list.push(data);
            this.save(table, list);
          }
        }
      }
      insert2(table, data) {
        let list = this.queryList(table);
        if (data) {
          let findData = lodash_1.find(list, item => item === data);
          if (!findData) {
            list.push(data);
            this.save(table, list);
          }
        }
      }
      insertInitData(table, arr) {
        for (let data of arr) this.insert(table, data);
      }
      update(table, data, where) {
        let list = this.queryList(table);
        if (list) {
          let index = lodash_1.findIndex(list, where);
          if (index > -1) {
            lodash_1.merge(list[index], data);
            this.save(table, list);
          }
        }
      }
      delete(table, where) {
        let list = this.queryList(table);
        if (list) {
          if (where) {
            let index = lodash_1.findIndex(list, where);
            index > -1 && list.splice(index, 1);
          } else list = [];
          this.save(table, list);
        }
      }
      save(table, list) {
        this.storageMgr.set(table, list);
        this._gameData.set(table, list);
      }
    }
    exports.default = DataMgr;
    cc._RF.pop();
  }, {
    "../../Common/Storage/StorageManager": "StorageManager",
    "../../Config/GlobalData": "GlobalData",
    "./BaseMgr": "BaseMgr",
    lodash: 1
  } ],
  DebugWindowUtils: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "84e75b8tBhNjY7KyBAgOsH/", "DebugWindowUtils");
    "use strict";
    var __spreadArrays = this && this.__spreadArrays || function() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, 
      k++) r[k] = a[j];
      return r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    function hookCtor(func) {
      return function() {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) params[_i] = arguments[_i];
        var result = func.call.apply(func, __spreadArrays([ this ], params)) || this;
        func["___ins"] = result;
        return result;
      };
    }
    var DebugWindowUtil = function() {
      function DebugWindowUtil() {}
      DebugWindowUtil.getModuleName = function(modules) {
        if ("string" !== typeof modules) return modules;
        return modules.split("/").pop().split(".")[0];
      };
      DebugWindowUtil.init = function() {
        var require = "undefined" !== typeof __modular ? __modular : {};
        if (!require || !require.modules) return;
        var installedModules = require.modules;
        var allExports = {};
        function addExports(k, obj, modName) {
          var name = k;
          obj && obj.name && (name = obj.name);
          if (allExports[k]) return addExports(k + modName, obj, modName);
          var wraped = obj;
          allExports[name] = wraped;
          return wraped;
        }
        for (var k in installedModules) {
          var module = installedModules[k];
          var file = module.file;
          var exports = module.module ? module.module.exports : {};
          var modName = this.getModuleName(file);
          for (var k_1 in exports) {
            if ("__esModule" === k_1) continue;
            if ("default" === k_1) {
              exports[k_1] = addExports(modName, exports[k_1], modName);
              exports[modName] || (exports[modName] = exports[k_1]);
            } else exports[k_1] = addExports(k_1, exports[k_1], modName);
          }
          window[modName + "_mod"] = exports;
        }
        for (var k in allExports) {
          if (window[k]) continue;
          window[k] = allExports[k];
        }
      };
      return DebugWindowUtil;
    }();
    exports.default = DebugWindowUtil;
    cc._RF.pop();
  }, {} ],
  DrawBorad: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "5d19bkVv4BM774fPMww+bzv", "DrawBorad");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var DrawingBoard_1 = require("../Utils/DrawingBoard");
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
    var DrawBorad = function(_super) {
      __extends(DrawBorad, _super);
      function DrawBorad() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.ndBroad = null;
        _this._drawingBroad = null;
        _this._texture = new cc.Texture2D();
        _this._sprite = null;
        _this.broadYMax = -1;
        _this.broadXMin = -1;
        _this._touching = false;
        return _this;
      }
      DrawBorad.prototype.onLoad = function() {
        this.ndBroad || (this.ndBroad = this.node);
        this._sprite = this.ndBroad.getComponent(cc.Sprite);
        this._sprite || this.ndBroad.addComponent(cc.Sprite);
        this._drawingBroad = new DrawingBoard_1.default(this.ndBroad.width, this.ndBroad.height);
        this._drawingBroad.setColor(0, 0, 0, 255);
        this._drawingBroad.setLineWidth(5);
        this._touching = false;
        var worldPos = this.ndBroad.convertToWorldSpaceAR(cc.v2(0, 0));
        this.broadYMax = worldPos.y + this.ndBroad.height / 2;
        this.broadXMin = worldPos.x - this.ndBroad.width / 2;
        this.ndBroad.on(cc.Node.EventType.TOUCH_START, this.touchStart, this);
        this.ndBroad.on(cc.Node.EventType.TOUCH_MOVE, this.touchMove, this);
        this.ndBroad.on(cc.Node.EventType.TOUCH_CANCEL, this.touchCancel, this);
        this.ndBroad.on(cc.Node.EventType.TOUCH_END, this.touchEnd, this);
      };
      DrawBorad.prototype.start = function() {};
      DrawBorad.prototype.setData = function(data) {
        this._drawingBroad.setData(data);
        this.updateTexture(this._drawingBroad.getData(), this.ndBroad.width, this.ndBroad.height);
      };
      DrawBorad.prototype.touchStart = function(e) {
        if (this._touching) return;
        this._touching = true;
        var worldPos = e.getLocation();
        this._drawingBroad.moveTo(worldPos.x - this.broadXMin, this.getRealY(worldPos.y));
      };
      DrawBorad.prototype.touchMove = function(e) {
        if (!this._touching) return;
        var worldPos = e.getLocation();
        this._drawingBroad.lineTo(worldPos.x - this.broadXMin, this.getRealY(worldPos.y));
        this.updateTexture(this._drawingBroad.getData(), this.ndBroad.width, this.ndBroad.height);
      };
      DrawBorad.prototype.touchCancel = function(e) {
        this._touching = false;
      };
      DrawBorad.prototype.touchEnd = function(e) {
        this._touching = false;
      };
      DrawBorad.prototype.onDestroy = function() {
        this.ndBroad.off(cc.Node.EventType.TOUCH_START, this.touchStart, this);
        this.ndBroad.off(cc.Node.EventType.TOUCH_MOVE, this.touchMove, this);
        this.ndBroad.off(cc.Node.EventType.TOUCH_CANCEL, this.touchCancel, this);
        this.ndBroad.off(cc.Node.EventType.TOUCH_END, this.touchEnd, this);
      };
      DrawBorad.prototype.setColor = function(r, g, b, a) {
        this._drawingBroad.setColor(r, g, b, a);
      };
      DrawBorad.prototype.setLineWidth = function(width) {
        this._drawingBroad.setLineWidth(width);
      };
      DrawBorad.prototype.setPen = function() {
        this.setColor(0, 0, 0, 255);
        this.setLineWidth(5);
      };
      DrawBorad.prototype.setReaser = function() {
        this.setColor(0, 0, 0, 0);
        this.setLineWidth(20);
      };
      DrawBorad.prototype.getTexture = function() {
        return this._texture;
      };
      DrawBorad.prototype.updateTexture = function(data, width, height) {
        this._texture.initWithData(data, cc.Texture2D.PixelFormat.RGBA8888, width, height);
        this._sprite.spriteFrame.setTexture(this._texture);
        this._sprite.markForRender(true);
      };
      DrawBorad.prototype.getRealY = function(y) {
        if (this._sprite.spriteFrame["_flipY"]) return this.broadYMax - (cc.visibleRect.height - y);
        return this.broadYMax - y;
      };
      __decorate([ property(cc.Node) ], DrawBorad.prototype, "ndBroad", void 0);
      DrawBorad = __decorate([ ccclass ], DrawBorad);
      return DrawBorad;
    }(cc.Component);
    exports.default = DrawBorad;
    cc._RF.pop();
  }, {
    "../Utils/DrawingBoard": "DrawingBoard"
  } ],
  DrawerMgr: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "02d628dfS1JVIWSTnS72y1D", "DrawerMgr");
    "use strict";
    var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = this && this.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (1 & t[0]) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, "function" === typeof Symbol && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([ n, v ]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = 2 & op[0] ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 
          0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          (y = 0, t) && (op = [ 2 & op[0], t.value ]);
          switch (op[0]) {
           case 0:
           case 1:
            t = op;
            break;

           case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

           case 5:
            _.label++;
            y = op[1];
            op = [ 0 ];
            continue;

           case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;

           default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (6 === op[0] || 2 === op[0])) {
              _ = 0;
              continue;
            }
            if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (6 === op[0] && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop();
            _.trys.pop();
            continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [ 6, e ];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (5 & op[0]) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var SysDefine_1 = require("./config/SysDefine");
    var Struct_1 = require("./Struct");
    var UIManager_1 = require("./UIManager");
    var DrawerMgr = function() {
      function DrawerMgr() {}
      DrawerMgr.prototype.open = function(form, params, formData) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              form = Struct_1.GetForm(form, SysDefine_1.FormType.Fixed);
              return [ 4, UIManager_1.default.getInstance().openForm(form, params, formData) ];

             case 1:
              return [ 2, _a.sent() ];
            }
          });
        });
      };
      DrawerMgr.prototype.close = function(form, params, formData) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              form = Struct_1.GetForm(form, SysDefine_1.FormType.Fixed);
              return [ 4, UIManager_1.default.getInstance().closeForm(form, params, formData) ];

             case 1:
              return [ 2, _a.sent() ];
            }
          });
        });
      };
      return DrawerMgr;
    }();
    exports.default = new DrawerMgr();
    cc._RF.pop();
  }, {
    "./Struct": "Struct",
    "./UIManager": "UIManager",
    "./config/SysDefine": "SysDefine"
  } ],
  DrawingBoard: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "54b2dNYr/FCsJ51TWLTWJoT", "DrawingBoard");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var DrawingBoard = function() {
      function DrawingBoard(width, height, data) {
        this.init(width, height, data);
      }
      Object.defineProperty(DrawingBoard.prototype, "width", {
        get: function() {
          return this._witdh;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(DrawingBoard.prototype, "height", {
        get: function() {
          return this._height;
        },
        enumerable: false,
        configurable: true
      });
      DrawingBoard.prototype.init = function(width, height, data) {
        this.tempColor = this.tempR = this.tempG = this.tempB = this.tempA = 0;
        this.curColor = 0;
        this._witdh = Math.round(width);
        this._height = Math.round(height);
        this.initPointColor();
        this.initPixelColor();
        this.initLineData();
        !data || this.setData(data);
      };
      DrawingBoard.prototype.initPointColor = function() {
        this.pointColor || (this.pointColor = []);
        for (var x = 0; x < this.width; ++x) {
          this.pointColor[x] || (this.pointColor[x] = []);
          for (var y = 0; y < this.height; ++y) this.pointColor[x][y] = 0;
        }
        this.colorCount = {};
        this.colorCount[0] = this.width * this.height;
      };
      DrawingBoard.prototype.initPixelColor = function() {
        this.buffer = new ArrayBuffer(this.width * this.height * 4);
        this.pixelColor = new Uint8Array(this.buffer);
        this.pixelColor.fill(0);
      };
      DrawingBoard.prototype.reset = function() {
        this.resetPointColor();
        this.resetPixelColor();
      };
      DrawingBoard.prototype.resetPointColor = function() {
        for (var x = this.width - 1; x >= 0; --x) for (var y = this.height - 1; y >= 0; --y) this.pointColor[x][y] = 0;
        for (var key in this.colorCount) this.colorCount[key] = 0;
      };
      DrawingBoard.prototype.resetPixelColor = function() {
        this.pixelColor.fill(0);
      };
      DrawingBoard.prototype.setData = function(data) {
        var pixelData = new Uint8Array(data);
        if (pixelData.length != this.width * this.height * 4) {
          console.warn("\u753b\u677f\u8bbe\u7f6e\u6570\u636e\u5931\u8d25\uff0c\u6570\u636e\u957f\u5ea6\u4e0e\u753b\u677f\u5927\u5c0f\u4e0d\u4e00\u81f4\u3002");
          pixelData = pixelData.subarray(0, this.width * this.height * 4);
        }
        this.setPixelColorByRGBA(pixelData);
        this.setPointColorByRGBA(pixelData);
      };
      DrawingBoard.prototype.setPixelColorByRGBA = function(data) {
        this.pixelColor.set(data);
      };
      DrawingBoard.prototype.setPointColorByRGBA = function(data) {
        this.colorCount = {};
        for (var y = 0; y < this.height; ++y) {
          var i = y * this.width * 4;
          for (var x = 0; x < this.width; ++x) {
            var color = this.convertToNumber(data[i++], data[i++], data[i++], data[i++]);
            this.pointColor[x][y] = color;
            this.colorCount[color] ? this.colorCount[color] += 1 : this.colorCount[color] = 1;
          }
        }
      };
      DrawingBoard.prototype.copyData = function(data) {
        void 0 === data && (data = []);
        for (var i = 0, count = this.pixelColor.length; i < count; ++i) data[i] = this.pixelColor[i];
        return data;
      };
      DrawingBoard.prototype.getData = function() {
        return this.pixelColor;
      };
      DrawingBoard.prototype.getBuffer = function() {
        return this.buffer;
      };
      DrawingBoard.prototype.getColorCount = function(r, g, b, a) {
        void 0 === a && (a = 255);
        var c = this.convertToNumber(r, g, b, a);
        return this.colorCount[c];
      };
      DrawingBoard.prototype.setColor = function(r, g, b, a) {
        void 0 === a && (a = 255);
        this.curColor = this.convertToNumber(r, g, b, a);
        this.colorCount[this.curColor] || (this.colorCount[this.curColor] = 0);
        this.tempColor = this.curColor;
        this.tempR = r;
        this.tempG = g;
        this.tempB = b;
        this.tempA = a;
      };
      DrawingBoard.prototype.clear = function() {
        this.reset();
      };
      DrawingBoard.prototype.initLineData = function() {
        this.previousLineEndPos = new Vec2();
        this.previousLineEndPosT = new Vec2();
        this.previousLineEndPosB = new Vec2();
        this.previousLineCircleEnd = true;
        this.previousLineWidth = 1;
      };
      DrawingBoard.prototype.moveTo = function(x, y) {
        x = Math.round(x);
        y = Math.round(y);
        this.previousLineEndPos.set(x, y);
        this.previousLineEndPosT.set(x, y);
        this.previousLineEndPosB.set(x, y);
      };
      DrawingBoard.prototype.setLineWidth = function(w) {
        this.previousLineWidth = w;
      };
      DrawingBoard.prototype.setLineCircleEnd = function(b) {
        this.previousLineCircleEnd = b;
      };
      DrawingBoard.prototype.line = function(x1, y1, x2, y2) {
        x1 = Math.round(x1);
        x2 = Math.round(x2);
        y1 = Math.round(y1);
        y2 = Math.round(y2);
        if (x1 == x2 && y1 == y2) return;
        var width = this.previousLineWidth;
        var circleEnd = this.previousLineCircleEnd;
        this.previousLineEndPos.set(x2, y2);
        var offsetX = 0;
        var offsetY = 0;
        var rateK = 1;
        if (x1 == x2) offsetX = Math.round(.5 * width); else if (y1 == y2) offsetY = Math.round(.5 * width); else {
          var k = (y2 - y1) / (x2 - x1);
          rateK = Math.sqrt(k * k + 1);
          offsetY = .5 * width / rateK;
          offsetX = Math.round(offsetY * k);
          offsetY = Math.round(offsetY);
        }
        this.previousLineEndPosT.set(x2 - offsetX, y2 + offsetY);
        this.previousLineEndPosB.set(x2 + offsetX, y2 - offsetY);
        var p1 = new Vec2(x1, y1);
        var p2 = new Vec2(x2, y2);
        if (x1 > x2) {
          p1.x = x2;
          p1.y = y2;
          p2.x = x1;
          p2.y = y1;
        }
        this._drawLine(p1, p2, width, offsetX, offsetY, rateK);
        if (circleEnd) {
          this._drawCircle(x1, y1, .5 * width);
          this._drawCircle(x2, y2, .5 * width);
        }
      };
      DrawingBoard.prototype.lineTo = function(x, y) {
        x = Math.round(x);
        y = Math.round(y);
        if (this.previousLineEndPos.x == x && this.previousLineEndPos.y == y) return;
        var width = this.previousLineWidth;
        var circleEnd = this.previousLineCircleEnd;
        var x1 = this.previousLineEndPos.x;
        var y1 = this.previousLineEndPos.y;
        var x2 = x;
        var y2 = y;
        if (x1 > x2) {
          x1 = x2;
          y1 = y2;
          x2 = this.previousLineEndPos.x;
          y2 = this.previousLineEndPos.y;
        }
        var offsetX = 0;
        var offsetY = 0;
        var rateK = 1;
        if (x1 == x2) offsetX = Math.round(.5 * width); else if (y1 == y2) offsetY = Math.round(.5 * width); else {
          var k = (y2 - y1) / (x2 - x1);
          rateK = Math.sqrt(k * k + 1);
          offsetY = .5 * width / rateK;
          offsetX = Math.round(offsetY * k);
          offsetY = Math.round(offsetY);
        }
        if (circleEnd) {
          this._drawCircle(x1, y1, .5 * width);
          this._drawCircle(x2, y2, .5 * width);
        } else if (this.previousLineEndPos.x != this.previousLineEndPosT.x || this.previousLineEndPos.y != this.previousLineEndPosT.y) {
          var p1 = new Vec2(this.previousLineEndPos.x - offsetX, this.previousLineEndPos.y + offsetY);
          var p2 = new Vec2(this.previousLineEndPos.x + offsetX, this.previousLineEndPos.y - offsetY);
          this._drawTriangle([ p1, p2, this.previousLineEndPosT ]);
          this._drawTriangle([ p1, p2, this.previousLineEndPosB ]);
        }
        this._drawLine(new Vec2(x1, y1), new Vec2(x2, y2), width, offsetX, offsetY, rateK);
        this.previousLineEndPos.set(x, y);
        this.previousLineEndPosT.set(x - offsetX, y + offsetY);
        this.previousLineEndPosB.set(x + offsetX, y - offsetY);
      };
      DrawingBoard.prototype._drawLine = function(p1, p2, width, offsetX, offsetY, slopeRate) {
        if (p1.y == p2.y) {
          var x = p1.x < p2.x ? p1.x : p2.x;
          this._drawRect(new Vec2(x, Math.round(p1.y - .5 * width)), Math.abs(p1.x - p2.x), width);
        } else if (p1.x == p2.x) {
          var y = p1.y < p2.y ? p1.y : p2.y;
          this._drawRect(new Vec2(Math.round(p1.x - .5 * width), y), width, Math.abs(p1.y - p2.y));
        } else {
          var inverseK = (p1.x - p2.x) / (p1.y - p2.y);
          var p1t = new Vec2(p1.x - offsetX, p1.y + offsetY);
          var p1b = new Vec2(p1.x + offsetX, p1.y - offsetY);
          var p2t = new Vec2(p2.x - offsetX, p2.y + offsetY);
          var p2b = new Vec2(p2.x + offsetX, p2.y - offsetY);
          var p1c = new Vec2();
          var p2c = new Vec2();
          var height = Math.round(width * slopeRate);
          if (p2.y > p1.y) if (p1b.x < p2t.x) {
            p1c.x = p1b.x;
            p1c.y = p1b.y + height;
            p2c.x = p2t.x;
            p2c.y = p2t.y - height;
            this._drawVerticalTriangle(p1c, p1b, p1t);
            this._drawParallelogram(p1b, p2c, height);
            this._drawVerticalTriangle(p2t, p2c, p2b);
          } else {
            p1c.x = p1b.x;
            p1c.y = Math.round(p2t.y - (p1c.x - p2t.x) * inverseK);
            p2c.x = p2t.x;
            p2c.y = Math.round(p1b.y + (p1b.x - p2c.x) * inverseK);
            this._drawVerticalTriangle(p2t, p2c, p1t);
            this._drawParallelogram(p2c, p1b, p2t.y - p2c.y);
            this._drawVerticalTriangle(p1c, p1b, p2b);
          } else if (p1t.x < p2b.x) {
            p1c.x = p1t.x;
            p1c.y = p1t.y - height;
            p2c.x = p2b.x;
            p2c.y = p2b.y + height;
            this._drawVerticalTriangle(p1t, p1c, p1b);
            this._drawParallelogram(p1c, p2b, height);
            this._drawVerticalTriangle(p2c, p2b, p2t);
          } else {
            p1c.x = p1t.x;
            p1c.y = Math.round(p2b.y - (p1c.x - p2b.x) * inverseK);
            p2c.x = p2b.x;
            p2c.y = Math.round(p1t.y + (p1t.x - p2c.x) * inverseK);
            this._drawVerticalTriangle(p2c, p2b, p1b);
            this._drawParallelogram(p2b, p1c, p1t.y - p1c.y);
            this._drawVerticalTriangle(p1t, p1c, p2t);
          }
        }
      };
      DrawingBoard.prototype.rect = function(x, y, w, h) {
        this._drawRect(new Vec2(x, y), w, h);
      };
      DrawingBoard.prototype._drawRect = function(p, w, h) {
        var minX = this.clampX(p.x);
        var maxX = this.clampX(p.x + w);
        var minY = this.clampY(p.y);
        var maxY = this.clampY(p.y + h);
        for (var y = minY; y <= maxY; ++y) this._drawRowPixel(minX, maxX, y);
      };
      DrawingBoard.prototype._drawParallelogram = function(p1, p2, height) {
        if (p1.x == p2.x) return;
        var k = (p2.y - p1.y) / (p2.x - p1.x);
        var minX = this._minX(p1.x);
        var maxX = this._maxX(p2.x);
        for (var x = minX; x <= maxX; ++x) {
          var minY = p1.y + Math.round((x - p1.x) * k);
          var maxY = minY + height;
          minY = this._minY(minY);
          maxY = this._maxY(maxY);
          this._drawColPixel(minY, maxY, x);
        }
      };
      DrawingBoard.prototype.triangle = function(x1, y1, x2, y2, x3, y3) {
        var pList = [];
        pList.push(new Vec2(x1, y1));
        pList.push(new Vec2(x2, y2));
        pList.push(new Vec2(x3, y3));
        this._drawTriangle(pList);
      };
      DrawingBoard.prototype._drawTriangle = function(pList) {
        pList.sort(function(a, b) {
          return a.x - b.x;
        });
        var p1 = pList[0];
        var p2 = pList[1];
        var p3 = pList[2];
        if (p1.x == p2.x) {
          if (p1.x == p3.x) return;
          if (p1.y < p2.y) {
            p1 = pList[1];
            p2 = pList[0];
          }
          this._drawVerticalTriangle(p1, p2, p3);
          return;
        }
        var k = (p3.y - p1.y) / (p3.x - p1.x);
        var p4 = new Vec2(p2.x, Math.round(p1.y + (p2.x - p1.x) * k));
        if (p4.y == p2.y) return;
        if (p4.y < p2.y) {
          this._drawVerticalTriangle(p2, p4, p1);
          this._drawVerticalTriangle(p2, p4, p3);
        } else {
          this._drawVerticalTriangle(p4, p2, p1);
          this._drawVerticalTriangle(p4, p2, p3);
        }
      };
      DrawingBoard.prototype._drawVerticalTriangle = function(p1, p2, p3) {
        if (p3.x == p1.x) return;
        var k1 = (p3.y - p1.y) / (p3.x - p1.x);
        var k2 = (p3.y - p2.y) / (p3.x - p2.x);
        var maxX = p3.x, minX = p1.x;
        if (maxX < minX) {
          maxX = p1.x;
          minX = p3.x;
        }
        minX = this._minX(minX);
        maxX = this._maxX(maxX);
        for (var x = minX; x <= maxX; ++x) {
          var maxY = this.clampY(Math.round(p1.y + (x - p1.x) * k1));
          var minY = this.clampY(Math.round(p2.y + (x - p2.x) * k2));
          this._drawColPixel(minY, maxY, x);
        }
      };
      DrawingBoard.prototype.circle = function(x, y, radius) {
        x = Math.round(x);
        y = Math.round(y);
        this._drawCircle(x, y, radius);
      };
      DrawingBoard.prototype._drawCircle = function(x, y, radius) {
        radius = Math.round(radius);
        if (0 == radius) return;
        var dis = radius * radius;
        var minY = this.clampY(y - radius);
        var maxY = this.clampY(y + radius);
        for (var j = minY; j <= maxY; ++j) {
          var r = j - y;
          r = Math.round(Math.sqrt(dis - r * r));
          var minX = this.clampX(x - r);
          var maxX = this.clampX(x + r);
          this._drawRowPixel(minX, maxX, j);
        }
      };
      DrawingBoard.prototype._minX = function(x) {
        return x >= 0 ? x : 0;
      };
      DrawingBoard.prototype._maxX = function(x) {
        return x < this.width ? x : this.width - 1;
      };
      DrawingBoard.prototype._minY = function(y) {
        return y >= 0 ? y : 0;
      };
      DrawingBoard.prototype._maxY = function(y) {
        return y < this.height ? y : this.height - 1;
      };
      DrawingBoard.prototype.clampX = function(x) {
        if (x < 0) return 0;
        if (x >= this.width) return this.width - 1;
        return x;
      };
      DrawingBoard.prototype.clampY = function(y) {
        if (y < 0) return 0;
        if (y >= this.height) return this.height - 1;
        return y;
      };
      DrawingBoard.prototype._drawPixel = function(x, y) {
        if (this.pointColor[x][y] == this.tempColor) return;
        var index = 4 * (y * this.width + x);
        this.pixelColor[index] = this.tempR;
        this.pixelColor[index + 1] = this.tempG;
        this.pixelColor[index + 2] = this.tempB;
        this.pixelColor[index + 3] = this.tempA;
        var c = this.pointColor[x][y];
        this.colorCount[c]--;
        this.colorCount[this.tempColor]++;
        this.pointColor[x][y] = this.tempColor;
      };
      DrawingBoard.prototype._drawRowPixel = function(startX, endX, y) {
        var index = 4 * (y * this.width + startX);
        for (var x = startX; x <= endX; ++x) {
          if (this.pointColor[x][y] != this.tempColor) {
            this.pixelColor[index] = this.tempR;
            this.pixelColor[index + 1] = this.tempG;
            this.pixelColor[index + 2] = this.tempB;
            this.pixelColor[index + 3] = this.tempA;
            var c = this.pointColor[x][y];
            this.colorCount[c]--;
            this.colorCount[this.tempColor]++;
            this.pointColor[x][y] = this.tempColor;
          }
          index += 4;
        }
      };
      DrawingBoard.prototype._drawColPixel = function(startY, endY, x) {
        var index = 4 * (startY * this.width + x);
        for (var y = startY; y <= endY; ++y) {
          if (this.pointColor[x][y] != this.tempColor) {
            this.pixelColor[index] = this.tempR;
            this.pixelColor[index + 1] = this.tempG;
            this.pixelColor[index + 2] = this.tempB;
            this.pixelColor[index + 3] = this.tempA;
            var c = this.pointColor[x][y];
            this.colorCount[c]--;
            this.colorCount[this.tempColor]++;
            this.pointColor[x][y] = this.tempColor;
          }
          index += 4 * this.width;
        }
      };
      DrawingBoard.prototype.convertToNumber = function(r, g, b, a) {
        void 0 === a && (a = 255);
        return (254 & r) << 23 | g << 16 | b << 8 | a;
      };
      DrawingBoard.prototype.convertToRGBA = function(color) {
        return {
          r: (4009754624 & color) >> 23,
          g: (16711680 & color) >> 16,
          b: (65280 & color) >> 8,
          a: 255 & color
        };
      };
      return DrawingBoard;
    }();
    exports.default = DrawingBoard;
    var Vec2 = function() {
      function Vec2(x, y) {
        void 0 === x && (x = 0);
        void 0 === y && (y = 0);
        this.x = x;
        this.y = y;
      }
      Vec2.prototype.set = function(p, y) {
        if ("number" === typeof p) {
          this.x = p;
          this.y = y;
        } else {
          this.x = p.x;
          this.y = p.y;
        }
      };
      return Vec2;
    }();
    cc._RF.pop();
  }, {} ],
  Dungeon: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "363928pIAdEs76ndgV1E6km", "Dungeon");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Dungeon = exports.GridType = void 0;
    var MatchUtils_1 = require("./MatchUtils");
    var GridType;
    (function(GridType) {
      GridType[GridType["None"] = 0] = "None";
      GridType[GridType["Floor"] = 1] = "Floor";
      GridType[GridType["Wall"] = 2] = "Wall";
      GridType[GridType["OpenDoor"] = 3] = "OpenDoor";
      GridType[GridType["CloseDoor"] = 4] = "CloseDoor";
    })(GridType = exports.GridType || (exports.GridType = {}));
    var DirType;
    (function(DirType) {
      DirType[DirType["None"] = 0] = "None";
      DirType[DirType["Left"] = 1] = "Left";
      DirType[DirType["Right"] = 2] = "Right";
      DirType[DirType["Up"] = 3] = "Up";
      DirType[DirType["Down"] = 4] = "Down";
      DirType[DirType["All"] = 5] = "All";
    })(DirType || (DirType = {}));
    var ALL_DIR_TYPES = [ DirType.Left, DirType.Right, DirType.Up, DirType.Down ];
    var Dungeon = function() {
      function Dungeon(width, height) {
        this.numRoomTries = 50;
        this.extraConnectorChance = 20;
        this.roomExtraSize = 0;
        this.windingPercent = 50;
        this.width = 51;
        this.height = 51;
        this.rooms = [];
        this.map = [];
        this.regions = [];
        this.currentRegion = 0;
        this.width = width;
        this.height = height;
        for (var i = 0; i < width * height; i++) {
          this.map[i] = GridType.None;
          this.regions[i] = 0;
        }
      }
      Dungeon.prototype.generate = function() {
        this.initMap();
        this.addRooms();
        this.fillMaze();
        this.connectRegions();
        this.removeDeadEnds();
        return this.map;
      };
      Dungeon.prototype.initMap = function() {
        for (var i = 0; i < this.width * this.height; i++) {
          this.map[i] = GridType.Wall;
          this.regions[i] = 0;
        }
      };
      Dungeon.prototype.addRooms = function() {
        for (var i = 0; i < this.numRoomTries; i++) {
          var size = 2 * MatchUtils_1.MathUtils.limitInteger(1, 3 + this.roomExtraSize) + 1;
          var rectangularity = 2 * MatchUtils_1.MathUtils.limitInteger(0, 1 + Math.floor(size / 2));
          var w = size, h = size;
          0 === MatchUtils_1.MathUtils.limitInteger(0, 1) ? w += rectangularity : h += rectangularity;
          var x = 2 * MatchUtils_1.MathUtils.limitInteger(0, Math.floor((this.width - w) / 2)) + 1;
          var y = 2 * MatchUtils_1.MathUtils.limitInteger(0, Math.floor((this.height - h) / 2)) + 1;
          var room = new cc.Rect(x, y, w, h);
          var overlaps = false;
          for (var _i = 0, _a = this.rooms; _i < _a.length; _i++) {
            var r = _a[_i];
            if (room.intersects(r)) {
              overlaps = true;
              break;
            }
          }
          if (overlaps) continue;
          this.currentRegion++;
          this._initRoomGrid(room);
          this.rooms.push(room);
        }
      };
      Dungeon.prototype._initRoomGrid = function(room) {
        var tmpVec2 = cc.v2(0, 0);
        for (var i = room.x; i < room.width + room.x; i++) for (var j = room.y; j < room.height + room.y; j++) {
          tmpVec2.x = i;
          tmpVec2.y = j;
          this.carveGrid(tmpVec2, GridType.Floor);
        }
      };
      Dungeon.prototype.fillMaze = function() {
        for (var y = 1; y < this.height; y += 2) for (var x = 1; x < this.width; x += 2) {
          var grid = cc.v2(x, y);
          if (this.getGridType(grid) !== GridType.Wall) continue;
          this._growMaze(grid);
        }
      };
      Dungeon.prototype._growMaze = function(start) {
        var cells = [];
        var lastDir = DirType.None;
        this.currentRegion++;
        this.carveGrid(start, GridType.Floor);
        cells.push(start);
        while (null !== cells && 0 !== cells.length) {
          var cell = cells[cells.length - 1];
          var unmadeCells = [];
          for (var _i = 0, ALL_DIR_TYPES_1 = ALL_DIR_TYPES; _i < ALL_DIR_TYPES_1.length; _i++) {
            var dir_1 = ALL_DIR_TYPES_1[_i];
            this.canCarve(cell, dir_1) && unmadeCells.push(dir_1);
          }
          if (unmadeCells.length <= 0) {
            cells.pop();
            lastDir = DirType.None;
            continue;
          }
          var dir = DirType.None;
          dir = -1 !== unmadeCells.indexOf(lastDir) && MatchUtils_1.MathUtils.limitInteger(0, 100) > this.windingPercent ? lastDir : MatchUtils_1.MathUtils.randomArray(unmadeCells);
          this.carveGrid(cell.add(this.getDirGridOffset(dir)), GridType.Floor);
          this.carveGrid(cell.add(this.getDirGridOffset(dir).mul(2)), GridType.Floor);
          cells.push(cell.add(this.getDirGridOffset(dir).mul(2)));
          lastDir = dir;
        }
      };
      Dungeon.prototype.connectRegions = function() {
        var _this = this;
        var connectorRegions = {};
        var tmpVec2 = cc.v2(0, 0);
        for (var i = 1; i < this.width - 1; i++) for (var j = 1; j < this.height - 1; j++) {
          tmpVec2.x = i;
          tmpVec2.y = j;
          if (this.getGridType(tmpVec2) !== GridType.Wall) continue;
          var regions = [];
          for (var _i = 0, ALL_DIR_TYPES_2 = ALL_DIR_TYPES; _i < ALL_DIR_TYPES_2.length; _i++) {
            var dir = ALL_DIR_TYPES_2[_i];
            var grid = tmpVec2.add(this.getDirGridOffset(dir));
            var region = this.regions[grid.y * this.width + grid.x];
            0 !== region && -1 == regions.indexOf(region) && regions.push(region);
          }
          if (regions.length < 2) continue;
          connectorRegions[j * this.width + i] = regions;
        }
        var connectors = [];
        var keys = Object.keys(connectorRegions);
        for (var _a = 0, keys_1 = keys; _a < keys_1.length; _a++) {
          var key = keys_1[_a];
          connectors.push(this.getGridByIdx(parseInt(key)));
        }
        var merged = {};
        var openRegions = new Set();
        for (var i = 0; i <= this.currentRegion; i++) {
          merged[i] = i;
          openRegions.add(i);
        }
        var count = 0;
        var _loop_1 = function() {
          count++;
          var connector = MatchUtils_1.MathUtils.randomArray(connectors);
          this_1.addJunction(connector);
          var regions = connectorRegions[connector.y * this_1.width + connector.x].map(function(v) {
            return merged[v];
          });
          var dest = regions[0];
          regions.shift();
          var sources = regions;
          for (var i = 0; i <= this_1.currentRegion; i++) -1 !== sources.indexOf(merged[i]) && (merged[i] = dest);
          for (var _i = 0, sources_1 = sources; _i < sources_1.length; _i++) {
            var s = sources_1[_i];
            openRegions.has(s) && openRegions.delete(s);
          }
          connectors.filter(function(v) {
            return !_this.isRemove(merged, connectorRegions, connector, v);
          });
        };
        var this_1 = this;
        while (openRegions.size > 1 && count < 50) _loop_1();
      };
      Dungeon.prototype.addJunction = function(grid) {
        MatchUtils_1.MathUtils.limitInteger(0, 4) ? this.setGridType(grid, MatchUtils_1.MathUtils.limitInteger(0, 3) ? GridType.OpenDoor : GridType.Floor) : this.setGridType(grid, GridType.CloseDoor);
      };
      Dungeon.prototype.isRemove = function(merged, connectRegions, connector, grid) {
        if (connector.sub(grid).len() < 2) return true;
        var regions = connectRegions[grid.y * this.width + grid.x].map(function(v) {
          return merged[v];
        });
        var set = new Set(regions);
        if (set.size > 1) return false;
        return true;
      };
      Dungeon.prototype.removeDeadEnds = function() {
        var done = false;
        var tmpVec2 = cc.v2(0, 0);
        var count = 0;
        while (!done && count < 500) {
          count++;
          done = true;
          for (var i = 1; i < this.width - 1; i++) for (var j = 1; j < this.height - 1; j++) {
            tmpVec2.x = i;
            tmpVec2.y = j;
            if (this.getGridType(tmpVec2) === GridType.Wall) continue;
            var exists = 0;
            for (var _i = 0, ALL_DIR_TYPES_3 = ALL_DIR_TYPES; _i < ALL_DIR_TYPES_3.length; _i++) {
              var dir = ALL_DIR_TYPES_3[_i];
              var grid = tmpVec2.add(this.getDirGridOffset(dir));
              this.map[grid.y * this.width + grid.x] !== GridType.Wall && exists++;
            }
            if (1 !== exists) continue;
            done = false;
            this.regions[j * this.height + i] = 0;
            this.map[j * this.height + i] = GridType.Wall;
          }
        }
      };
      Dungeon.prototype.instanceMap = function() {};
      Dungeon.prototype.getGridByIdx = function(idx) {
        var y = Math.floor(idx / this.width);
        var x = idx - y * this.width;
        return cc.v2(x, y);
      };
      Dungeon.prototype.carveGrid = function(grid, type) {
        if (!this.checkGrid(grid)) return;
        this.setGridType(grid, type);
        this.regions[grid.y * this.width + grid.x] = this.currentRegion;
      };
      Dungeon.prototype.setGridType = function(grid, type) {
        this.map[grid.y * this.width + grid.x] = type;
      };
      Dungeon.prototype.checkGrid = function(grid) {
        if (grid.x <= 0 || grid.x >= this.width - 1 || grid.y <= 0 || grid.y >= this.height - 1) {
          console.log(" set grid type error: ", grid);
          return false;
        }
        return true;
      };
      Dungeon.prototype.getGridType = function(grid) {
        return this.map[grid.y * this.width + grid.x];
      };
      Dungeon.prototype.canCarve = function(grid, dir) {
        var dirGrid = this.getDirGridOffset(dir);
        var nextGrid = grid.add(dirGrid.mul(3));
        if (nextGrid.x < 0 || nextGrid.x >= this.width || nextGrid.y < 0 || nextGrid.y >= this.height) return false;
        nextGrid = grid.add(dirGrid.mul(2));
        return this.getGridType(nextGrid) === GridType.Wall;
      };
      Dungeon.prototype.getDirGridOffset = function(dir) {
        var dirGrid = cc.v2(0, 0);
        switch (dir) {
         case DirType.Left:
          dirGrid.x = -1;
          break;

         case DirType.Right:
          dirGrid.x = 1;
          break;

         case DirType.Up:
          dirGrid.y = 1;
          break;

         case DirType.Down:
          dirGrid.y = -1;
        }
        return dirGrid;
      };
      return Dungeon;
    }();
    exports.Dungeon = Dungeon;
    cc._RF.pop();
  }, {
    "./MatchUtils": "MatchUtils"
  } ],
  EncryptUtil: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "5b686X10udAg4AzE425DxCm", "EncryptUtil");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.EncryptUtil = void 0;
    var CryptoES = require("crypto-js");
    var EncryptUtil = function() {
      function EncryptUtil() {}
      EncryptUtil.md5 = function(msg) {
        return CryptoES.MD5(msg).toString();
      };
      EncryptUtil.initCrypto = function(key, iv) {
        this.key = key;
        this.iv = CryptoES.enc.Hex.parse(iv);
      };
      EncryptUtil.aesEncrypt = function(msg, key, iv) {
        return CryptoES.AES.encrypt(msg, this.key, {
          iv: this.iv,
          format: this.JsonFormatter
        }).toString();
      };
      EncryptUtil.aesDecrypt = function(str, key, iv) {
        var decrypted = CryptoES.AES.decrypt(str, this.key, {
          iv: this.iv,
          format: this.JsonFormatter
        });
        return decrypted.toString(CryptoES.enc.Utf8);
      };
      EncryptUtil.key = null;
      EncryptUtil.iv = null;
      EncryptUtil.JsonFormatter = {
        stringify: function(cipherParams) {
          var jsonObj = {
            ct: cipherParams.ciphertext.toString(CryptoES.enc.Base64)
          };
          cipherParams.iv && (jsonObj.iv = cipherParams.iv.toString());
          cipherParams.salt && (jsonObj.s = cipherParams.salt.toString());
          return JSON.stringify(jsonObj);
        },
        parse: function(jsonStr) {
          var jsonObj = JSON.parse(jsonStr);
          var cipherParams = CryptoES.lib.CipherParams.create({
            ciphertext: CryptoES.enc.Base64.parse(jsonObj.ct)
          });
          jsonObj.iv && (cipherParams.iv = CryptoES.enc.Hex.parse(jsonObj.iv));
          jsonObj.s && (cipherParams.salt = CryptoES.enc.Hex.parse(jsonObj.s));
          return cipherParams;
        }
      };
      return EncryptUtil;
    }();
    exports.EncryptUtil = EncryptUtil;
    cc._RF.pop();
  }, {
    "crypto-js": "crypto-js"
  } ],
  EnumUtils: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "c0967gbR3dMcbkSIeGpt59T", "EnumUtils");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.EnumUtils = void 0;
    var EnumUtils = function() {
      function EnumUtils() {}
      EnumUtils.getNamesAndValues = function(e) {
        return this.getNames(e).map(function(_name) {
          return {
            name: _name,
            value: e[_name]
          };
        });
      };
      EnumUtils.getNames = function(e) {
        return this.getObjectValues(e).filter(function(v) {
          return "string" === typeof v;
        });
      };
      EnumUtils.getValues = function(e) {
        return this.getObjectValues(e).filter(function(v) {
          return "number" === typeof v;
        });
      };
      EnumUtils.getObjectValues = function(e) {
        return Object.keys(e).map(function(k) {
          return e[k];
        });
      };
      return EnumUtils;
    }();
    exports.EnumUtils = EnumUtils;
    cc._RF.pop();
  }, {} ],
  EventBox: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "5df38Ja1shKOa98TL3GuQ66", "EventBox");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var EventBox = function() {
      function EventBox() {
        this.eventMap = new Map();
        this.eventTargetsLock = null;
        this.removeCountOnLock = 0;
      }
      EventBox.prototype.on = function(event, context, method, once) {
        void 0 === once && (once = false);
        var eventTargets = this.eventMap.get(event);
        if (eventTargets) {
          var eventTarget = {
            context: context,
            method: method,
            isValid: true,
            once: once
          };
          eventTargets.push(eventTarget);
        } else {
          var eventTarget = {
            context: context,
            method: method,
            isValid: true,
            once: once
          };
          this.eventMap.set(event, [ eventTarget ]);
        }
      };
      EventBox.prototype.once = function(event, context, method) {
        this.on(event, context, method, true);
      };
      EventBox.prototype.off = function(event, context, method) {
        var eventTargets = this.eventMap.get(event);
        if (eventTargets) {
          if (event && !context && !method && eventTargets.length > 0) if (eventTargets == this.eventTargetsLock) for (var _i = 0, eventTargets_1 = eventTargets; _i < eventTargets_1.length; _i++) {
            var eventTarget = eventTargets_1[_i];
            eventTarget.isValid = false;
            this.removeCountOnLock++;
          } else eventTargets.splice(0, eventTargets.length);
          if (event && context && !method) for (var i = eventTargets.length - 1; i >= 0; i--) {
            var eventTarget = eventTargets[i];
            eventTarget.context == context && (eventTargets == this.eventTargetsLock ? (eventTarget.isValid = false, 
            this.removeCountOnLock++) : eventTargets.splice(i, 1));
          }
          if (event && context && method) for (var i = eventTargets.length - 1; i >= 0; i--) {
            var eventTarget = eventTargets[i];
            eventTarget.context == context && eventTarget.method == method && (eventTargets == this.eventTargetsLock ? (eventTarget.isValid = false, 
            this.removeCountOnLock++) : eventTargets.splice(i, 1));
          }
        }
      };
      EventBox.prototype.emit = function(event, args) {
        var eventTargets = this.eventMap.get(event);
        if (eventTargets) {
          this.eventTargetsLock = eventTargets;
          for (var _i = 0, eventTargets_2 = eventTargets; _i < eventTargets_2.length; _i++) {
            var eventTarget = eventTargets_2[_i];
            try {
              eventTarget.method.apply(eventTarget.context, args);
            } catch (e) {}
            if (eventTarget.once) {
              eventTarget.isValid = false;
              this.removeCountOnLock++;
            }
          }
          this.eventTargetsLock = null;
          if (this.removeCountOnLock > 0) {
            for (var i = eventTargets.length - 1; i >= 0; i--) eventTargets[i].isValid || eventTargets.splice(i, 1);
            this.removeCountOnLock = 0;
          }
        }
      };
      return EventBox;
    }();
    exports.default = EventBox;
    cc._RF.pop();
  }, {} ],
  EventCenter: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "5457exhkz1HWKJ6Z7OS0E1z", "EventCenter");
    "use strict";
    var __spreadArrays = this && this.__spreadArrays || function() {
      for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
      for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, 
      k++) r[k] = a[j];
      return r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.EventCenter = exports.EventInfo = void 0;
    var Pool_1 = require("../Common/Utils/Pool");
    var EventInfo = function() {
      function EventInfo() {}
      EventInfo.prototype.free = function() {
        this.callback = null;
        this.target = null;
        this.once = false;
      };
      EventInfo.prototype.init = function(callback, target, once) {
        this.callback = callback;
        this.target = target;
        this.once = once;
      };
      return EventInfo;
    }();
    exports.EventInfo = EventInfo;
    var RemoveCommand = function() {
      function RemoveCommand(eventName, callback, targetId) {
        this.eventName = eventName;
        this.callback = callback;
        this.targetId = targetId;
      }
      return RemoveCommand;
    }();
    var idSeed = 1;
    var EventCenter = function() {
      function EventCenter() {}
      EventCenter.on = function(eventName, callback, target, once) {
        void 0 === target && (target = void 0);
        void 0 === once && (once = false);
        target = target || this;
        var targetId = target["uuid"] || target["id"];
        void 0 === targetId && (target["uuid"] = targetId = "" + idSeed++);
        this.onById(eventName, targetId, target, callback, once);
      };
      EventCenter.once = function(eventName, callback, target) {
        void 0 === target && (target = void 0);
        this.on(eventName, callback, target, true);
      };
      EventCenter.onById = function(eventName, targetId, target, cb, once) {
        var collection = this._listeners[eventName];
        collection || (collection = this._listeners[eventName] = {});
        var events = collection[targetId];
        events || (events = collection[targetId] = []);
        var eventInfo = this._eventPool.alloc();
        eventInfo.init(cb, target, once);
        events.push(eventInfo);
      };
      EventCenter.off = function(eventName, callback, target) {
        void 0 === target && (target = void 0);
        target = target || this;
        var targetId = target["uuid"] || target["id"];
        if (!targetId) return false;
        this.offById(eventName, callback, targetId);
      };
      EventCenter.targetOff = function(target) {
        target = target || this;
        var targetId = target["uuid"] || target["id"];
        if (!targetId) return;
        for (var event in this._listeners) {
          var collection = this._listeners[event];
          void 0 !== collection[targetId] && delete collection[targetId];
        }
      };
      EventCenter.offById = function(eventName, callback, targetId) {
        if (this._dispatching > 0) {
          var cmd = new RemoveCommand(eventName, callback, targetId);
          this._removeCommands.push(cmd);
        } else this.doOff(eventName, callback, targetId);
      };
      EventCenter.doOff = function(eventName, callback, targetId) {
        var collection = this._listeners[eventName];
        if (!collection) return;
        var events = collection[targetId];
        if (!events) return;
        for (var i = events.length - 1; i >= 0; i--) events[i].callback === callback && events.splice(i, 1);
        if (0 === events.length) {
          collection[targetId] = null;
          delete collection[targetId];
        }
      };
      EventCenter.doRemoveCommands = function() {
        if (0 !== this._dispatching) return;
        for (var _i = 0, _a = this._removeCommands; _i < _a.length; _i++) {
          var cmd = _a[_i];
          this.doOff(cmd.eventName, cmd.callback, cmd.targetId);
        }
        this._removeCommands.length = 0;
      };
      EventCenter.emit = function(eventName) {
        var _a;
        var param = [];
        for (var _i = 1; _i < arguments.length; _i++) param[_i - 1] = arguments[_i];
        var collection = this._listeners[eventName];
        if (!collection) return false;
        this._dispatching++;
        for (var targetId in collection) for (var _b = 0, _c = collection[targetId]; _b < _c.length; _b++) {
          var eventInfo = _c[_b];
          (_a = eventInfo.callback).call.apply(_a, __spreadArrays([ eventInfo.target ], param));
          if (eventInfo.once) {
            var cmd = new RemoveCommand(eventName, eventInfo.callback, targetId);
            this._removeCommands.push(cmd);
          }
        }
        this._dispatching--;
        this.doRemoveCommands();
      };
      EventCenter._listeners = cc.js.createMap();
      EventCenter._dispatching = 0;
      EventCenter._removeCommands = [];
      EventCenter._eventPool = new Pool_1.Pool(function() {
        return new EventInfo();
      }, 10);
      return EventCenter;
    }();
    exports.EventCenter = EventCenter;
    cc._RF.pop();
  }, {
    "../Common/Utils/Pool": "Pool"
  } ],
  EventType: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "3a2ce/BnWtAGous8Nu/ZYEZ", "EventType");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.EventType = void 0;
    var EventType;
    (function(EventType) {
      EventType["GameShow"] = "GameShow";
      EventType["GameHide"] = "GameHide";
      EventType["WindowClosed"] = "WindowClosed";
      EventType["FormClosed"] = "FormClosed";
    })(EventType = exports.EventType || (exports.EventType = {}));
    cc._RF.pop();
  }, {} ],
  FixedMgr: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "727dau44q5IioBgMTJwEQJ0", "FixedMgr");
    "use strict";
    var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = this && this.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (1 & t[0]) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, "function" === typeof Symbol && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([ n, v ]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = 2 & op[0] ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 
          0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          (y = 0, t) && (op = [ 2 & op[0], t.value ]);
          switch (op[0]) {
           case 0:
           case 1:
            t = op;
            break;

           case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

           case 5:
            _.label++;
            y = op[1];
            op = [ 0 ];
            continue;

           case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;

           default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (6 === op[0] || 2 === op[0])) {
              _ = 0;
              continue;
            }
            if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (6 === op[0] && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop();
            _.trys.pop();
            continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [ 6, e ];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (5 & op[0]) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var SysDefine_1 = require("./config/SysDefine");
    var Struct_1 = require("./Struct");
    var UIManager_1 = require("./UIManager");
    var FixedMgr = function() {
      function FixedMgr() {}
      FixedMgr.prototype.open = function(form, params, formData) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              form = Struct_1.GetForm(form, SysDefine_1.FormType.Fixed);
              return [ 4, UIManager_1.default.getInstance().openForm(form, params, formData) ];

             case 1:
              return [ 2, _a.sent() ];
            }
          });
        });
      };
      FixedMgr.prototype.close = function(form, params, formData) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              form = Struct_1.GetForm(form, SysDefine_1.FormType.Fixed);
              return [ 4, UIManager_1.default.getInstance().closeForm(form, params, formData) ];

             case 1:
              return [ 2, _a.sent() ];
            }
          });
        });
      };
      return FixedMgr;
    }();
    exports.default = new FixedMgr();
    cc._RF.pop();
  }, {
    "./Struct": "Struct",
    "./UIManager": "UIManager",
    "./config/SysDefine": "SysDefine"
  } ],
  FormMgr: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "9a773PrZ4hPdb2eNyT8WZyH", "FormMgr");
    "use strict";
    var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const SysDefine_1 = require("./config/SysDefine");
    const DrawerMgr_1 = require("./DrawerMgr");
    const FixedMgr_1 = require("./FixedMgr");
    const SceneMgr_1 = require("./SceneMgr");
    const TipsMgr_1 = require("./TipsMgr");
    const ToastMgr_1 = require("./ToastMgr");
    const UIManager_1 = require("./UIManager");
    const WindowMgr_1 = require("./WindowMgr");
    class FormMgr {
      open(form, param, formData) {
        return __awaiter(this, void 0, void 0, function*() {
          switch (form.type) {
           case SysDefine_1.FormType.Screen:
            return yield SceneMgr_1.default.open(form, param, formData);

           case SysDefine_1.FormType.Window:
            return yield WindowMgr_1.default.open(form, param, formData);

           case SysDefine_1.FormType.Fixed:
            return yield FixedMgr_1.default.open(form, param, formData);

           case SysDefine_1.FormType.Drawer:
            return yield DrawerMgr_1.default.open(form, param, formData);

           case SysDefine_1.FormType.Tips:
            return yield TipsMgr_1.default.open(form, param, formData);

           case SysDefine_1.FormType.Toast:
            return yield ToastMgr_1.default.open(form, param, formData);

           default:
            cc.error(`\u672a\u77e5\u7c7b\u578b\u7684\u7a97\u4f53: ${form.type}`);
            return null;
          }
        });
      }
      close(form, param, formData) {
        return __awaiter(this, void 0, void 0, function*() {
          switch (form.type) {
           case SysDefine_1.FormType.Screen:
            return yield SceneMgr_1.default.close(form, param, formData);

           case SysDefine_1.FormType.Window:
            return yield WindowMgr_1.default.close(form, param, formData);

           case SysDefine_1.FormType.Drawer:
            return yield DrawerMgr_1.default.close(form, param, formData);

           case SysDefine_1.FormType.Fixed:
            return yield FixedMgr_1.default.close(form, param, formData);

           case SysDefine_1.FormType.Tips:
            return yield TipsMgr_1.default.close(form, param, formData);

           case SysDefine_1.FormType.Toast:
            cc.warn("UIToast \u76ee\u524d\u4e0d\u80fd\u901a\u8fc7\u8fd9\u79cd\u65b9\u5f0f\u5173\u95ed, \u8bf7\u4f7f\u7528 ToastMgr.close()");
            break;

           default:
            cc.error(`\u672a\u77e5\u7c7b\u578b\u7684\u7a97\u4f53: ${form.type}`);
            return false;
          }
        });
      }
      backScene(params, formData) {
        return __awaiter(this, void 0, void 0, function*() {
          return SceneMgr_1.default.back(params, formData);
        });
      }
      closeAllWindows() {
        return __awaiter(this, void 0, void 0, function*() {
          yield WindowMgr_1.default.closeAll();
        });
      }
      load(form) {
        return __awaiter(this, void 0, void 0, function*() {
          yield UIManager_1.default.getInstance().loadUIForm(form.prefabUrl);
        });
      }
    }
    exports.default = new FormMgr();
    cc._RF.pop();
  }, {
    "./DrawerMgr": "DrawerMgr",
    "./FixedMgr": "FixedMgr",
    "./SceneMgr": "SceneMgr",
    "./TipsMgr": "TipsMgr",
    "./ToastMgr": "ToastMgr",
    "./UIManager": "UIManager",
    "./WindowMgr": "WindowMgr",
    "./config/SysDefine": "SysDefine"
  } ],
  GPDrag: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "5181dEjiW1Hyq4VdL35aHS4", "GPDrag");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.GPDrag = exports.EasingString = exports.DragBackHomeType = exports.FloatType = void 0;
    var GPWorkFlow_1 = require("./Components/GPWorkFlow");
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
    var FloatType;
    (function(FloatType) {
      FloatType[FloatType["None"] = 0] = "None";
      FloatType[FloatType["MoveToTop"] = 1] = "MoveToTop";
      FloatType[FloatType["MoveToTopLayer"] = 2] = "MoveToTopLayer";
    })(FloatType = exports.FloatType || (exports.FloatType = {}));
    var DragBackHomeType;
    (function(DragBackHomeType) {
      DragBackHomeType[DragBackHomeType["SetPosition"] = 0] = "SetPosition";
      DragBackHomeType[DragBackHomeType["Tween"] = 1] = "Tween";
    })(DragBackHomeType = exports.DragBackHomeType || (exports.DragBackHomeType = {}));
    var EasingString;
    (function(EasingString) {
      EasingString[EasingString["linear"] = 0] = "linear";
      EasingString[EasingString["smooth"] = 1] = "smooth";
      EasingString[EasingString["fade"] = 2] = "fade";
      EasingString[EasingString["constant"] = 3] = "constant";
      EasingString[EasingString["quadIn"] = 4] = "quadIn";
      EasingString[EasingString["quadOut"] = 5] = "quadOut";
      EasingString[EasingString["quadInOut"] = 6] = "quadInOut";
      EasingString[EasingString["quadOutIn"] = 7] = "quadOutIn";
      EasingString[EasingString["cubicIn"] = 8] = "cubicIn";
      EasingString[EasingString["cubicOut"] = 9] = "cubicOut";
      EasingString[EasingString["cubicInOut"] = 10] = "cubicInOut";
      EasingString[EasingString["cubicOutIn"] = 11] = "cubicOutIn";
      EasingString[EasingString["quartIn"] = 12] = "quartIn";
      EasingString[EasingString["quartOut"] = 13] = "quartOut";
      EasingString[EasingString["quartInOut"] = 14] = "quartInOut";
      EasingString[EasingString["quartOutIn"] = 15] = "quartOutIn";
      EasingString[EasingString["quintIn"] = 16] = "quintIn";
      EasingString[EasingString["quintOut"] = 17] = "quintOut";
      EasingString[EasingString["quintInOut"] = 18] = "quintInOut";
      EasingString[EasingString["quintOutIn"] = 19] = "quintOutIn";
      EasingString[EasingString["sineIn"] = 20] = "sineIn";
      EasingString[EasingString["sineOut"] = 21] = "sineOut";
      EasingString[EasingString["sineInOut"] = 22] = "sineInOut";
      EasingString[EasingString["sineOutIn"] = 23] = "sineOutIn";
      EasingString[EasingString["expoIn"] = 24] = "expoIn";
      EasingString[EasingString["expoOut"] = 25] = "expoOut";
      EasingString[EasingString["expoInOut"] = 26] = "expoInOut";
      EasingString[EasingString["expoOutIn"] = 27] = "expoOutIn";
      EasingString[EasingString["circIn"] = 28] = "circIn";
      EasingString[EasingString["circOut"] = 29] = "circOut";
      EasingString[EasingString["circInOut"] = 30] = "circInOut";
      EasingString[EasingString["circOutIn"] = 31] = "circOutIn";
      EasingString[EasingString["elasticIn"] = 32] = "elasticIn";
      EasingString[EasingString["elasticOut"] = 33] = "elasticOut";
      EasingString[EasingString["elasticInOut"] = 34] = "elasticInOut";
      EasingString[EasingString["elasticOutIn"] = 35] = "elasticOutIn";
      EasingString[EasingString["backIn"] = 36] = "backIn";
      EasingString[EasingString["backOut"] = 37] = "backOut";
      EasingString[EasingString["backInOut"] = 38] = "backInOut";
      EasingString[EasingString["backOutIn"] = 39] = "backOutIn";
      EasingString[EasingString["bounceIn"] = 40] = "bounceIn";
      EasingString[EasingString["bounceOut"] = 41] = "bounceOut";
      EasingString[EasingString["bounceInOut"] = 42] = "bounceInOut";
      EasingString[EasingString["bounceOutIn"] = 43] = "bounceOutIn";
    })(EasingString = exports.EasingString || (exports.EasingString = {}));
    var GPDrag = function(_super) {
      __extends(GPDrag, _super);
      function GPDrag() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.touchOffsetSensitive = true;
        _this.backHomeWhenFailed = true;
        _this.backHomeType = DragBackHomeType.SetPosition;
        _this.backTweenTime = 1;
        _this.backTweenEasing = EasingString.linear;
        _this.floatType = FloatType.None;
        _this.backToOriZ = true;
        _this.dragStartPos = new cc.Vec2(0, 0);
        _this.dragOffset = new cc.Vec2(0, 0);
        _this.succeedCheck = null;
        _this.succeedCallback = null;
        _this.backHomeWorkFlow = new GPWorkFlow_1.GPWorkFlow();
        return _this;
      }
      GPDrag.prototype.start = function() {
        var _this = this;
        this.node.on(cc.Node.EventType.TOUCH_START, this.OnDragStart, this);
        this.node.on(cc.Node.EventType.TOUCH_MOVE, this.OnDragMove, this);
        this.node.on(cc.Node.EventType.TOUCH_END, this.OnDragEnd, this);
        this.node.on(cc.Node.EventType.TOUCH_CANCEL, this.OnDragEnd, this);
        var moveNode = new GPWorkFlow_1.GPWorkFlowNode();
        this.backHomeWorkFlow.headNode = moveNode;
        var self = this;
        moveNode.OnStart = function(wfNode) {
          var p = new cc.Vec3(self.dragStartPos.x, self.dragStartPos.y, 0);
          switch (_this.backHomeType) {
           case DragBackHomeType.SetPosition:
            self.node.setPosition(p);
            wfNode.done();
            break;

           case DragBackHomeType.Tween:
            self.backTween && self.backTween.stop();
            var easing = EasingString[self.backTweenEasing];
            self.backTween = cc.tween(self.node).to(self.backTweenTime, {
              position: p
            }, {
              easing: easing
            }).call(function() {
              wfNode.done();
            }).start();
          }
        };
        var arrivedNode = new GPWorkFlow_1.GPWorkFlowNode();
        moveNode.nextNode = arrivedNode;
        arrivedNode.OnStart = function(wfNode) {
          self.OnArrivedHome();
          wfNode.done();
        };
      };
      GPDrag.prototype.OnDragStart = function(e) {
        console.log("drag start");
        this.dragStartPos.set(cc.v2(this.node.position.x, this.node.position.y));
        var touchPoint = e.getLocation();
        cc.Vec2.subtract(this.dragOffset, this.dragStartPos, touchPoint);
        switch (this.floatType) {
         case FloatType.MoveToTop:
          this.zOrder = this.node.getSiblingIndex();
          this.node.setSiblingIndex(Infinity);
          break;

         case FloatType.MoveToTopLayer:
          this.zOrder = this.node.getSiblingIndex();
          this.srcParent = this.node.parent;
          this.node.parent = this.topLayerNode;
        }
      };
      GPDrag.prototype.OnDragMove = function(e) {
        var p = e.getLocation();
        this.touchOffsetSensitive ? this.node.setPosition(new cc.Vec3(p.x + this.dragOffset.x, p.y + this.dragOffset.y, 0)) : this.node.setPosition(new cc.Vec3(p.x, 0, p.y));
      };
      GPDrag.prototype.OnDragEnd = function(e) {
        this.succeedCheck && this.succeedCheck(e) ? this.succeedCallback && this.succeedCallback(e) : this.backHomeWhenFailed && this.backHomeWorkFlow.start();
      };
      GPDrag.prototype.OnArrivedHome = function() {
        if (this.backToOriZ) switch (this.floatType) {
         case FloatType.MoveToTop:
          this.node.setSiblingIndex(this.zOrder);
          break;

         case FloatType.MoveToTopLayer:
          this.node.parent = this.srcParent;
          this.node.setSiblingIndex(this.zOrder);
        }
      };
      GPDrag.prototype.onDestroy = function() {
        this.node.off(cc.Node.EventType.TOUCH_START, this.OnDragStart, this);
        this.node.off(cc.Node.EventType.TOUCH_MOVE, this.OnDragMove, this);
        this.node.off(cc.Node.EventType.TOUCH_END, this.OnDragEnd, this);
        this.node.off(cc.Node.EventType.TOUCH_CANCEL, this.OnDragEnd, this);
      };
      GPDrag.prototype.update = function(dt) {
        this.backHomeWorkFlow.update(dt);
      };
      __decorate([ property({
        tooltip: "\u89e6\u78b0\u70b9\u504f\u79fb\u91cf\u654f\u611f"
      }) ], GPDrag.prototype, "touchOffsetSensitive", void 0);
      __decorate([ property({
        tooltip: "\u5931\u8d25\u65f6\u56de\u5230\u8d77\u59cb\u4f4d\u7f6e"
      }) ], GPDrag.prototype, "backHomeWhenFailed", void 0);
      __decorate([ property({
        type: cc.Enum(DragBackHomeType),
        tooltip: "\u56de\u5bb6\u7684\u65b9\u5f0f",
        visible: function() {
          return this.backHomeWhenFailed;
        }
      }) ], GPDrag.prototype, "backHomeType", void 0);
      __decorate([ property({
        type: cc.Float,
        visible: function() {
          return this.backHomeWhenFailed && this.backHomeType == DragBackHomeType.Tween;
        }
      }) ], GPDrag.prototype, "backTweenTime", void 0);
      __decorate([ property({
        type: cc.Enum(EasingString),
        tooltip: "\u7f13\u52a8\u7c7b\u578b",
        visible: function() {
          return this.backHomeWhenFailed && this.backHomeType == DragBackHomeType.Tween;
        }
      }) ], GPDrag.prototype, "backTweenEasing", void 0);
      __decorate([ property({
        type: cc.Enum(FloatType),
        tooltip: "\u4e0a\u6d6e\u7c7b\u578b"
      }) ], GPDrag.prototype, "floatType", void 0);
      __decorate([ property({
        type: cc.Node,
        visible: function() {
          return this.floatType == FloatType.MoveToTopLayer;
        }
      }) ], GPDrag.prototype, "topLayerNode", void 0);
      __decorate([ property({
        tooltip: "\u677e\u5f00\u540e\u8fd4\u56de\u539f\u6765\u7684\u5c42\u7ea7",
        visible: function() {
          return this.floatType != FloatType.None;
        }
      }) ], GPDrag.prototype, "backToOriZ", void 0);
      GPDrag = __decorate([ ccclass("GPDrag") ], GPDrag);
      return GPDrag;
    }(cc.Component);
    exports.GPDrag = GPDrag;
    cc._RF.pop();
  }, {
    "./Components/GPWorkFlow": "GPWorkFlow"
  } ],
  GPWorkFlow: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "00ae3DUSlREBqJ4jLF4bVlj", "GPWorkFlow");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.GPWorkFlow = exports.GPWorkFlowNode = void 0;
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
    var GPWorkFlowNode = function() {
      function GPWorkFlowNode() {
        this.nextNodes = new Array();
        this._nextIdx = -1;
      }
      Object.defineProperty(GPWorkFlowNode.prototype, "nextNode", {
        get: function() {
          return this.nextNodes.length > 0 ? this.nextNodes[0] : null;
        },
        set: function(_nextNode) {
          0 == this.nextNodes.length ? this.nextNodes.push(_nextNode) : this.nextNodes[0] = _nextNode;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(GPWorkFlowNode.prototype, "nextIdx", {
        get: function() {
          return this._nextIdx;
        },
        enumerable: false,
        configurable: true
      });
      GPWorkFlowNode.prototype.done = function(nexIdx) {
        void 0 === nexIdx && (nexIdx = 0);
        this._nextIdx = nexIdx;
        this.OnEnd && this.OnEnd(this);
      };
      GPWorkFlowNode.prototype.isDone = function() {
        return this._nextIdx >= 0;
      };
      GPWorkFlowNode.prototype.refresh = function() {
        this._nextIdx = -1;
        for (var i = 0; i < this.nextNodes.length; i++) this.nextNodes[i].refresh();
      };
      GPWorkFlowNode.prototype.start = function() {
        this.OnStart && this.OnStart(this);
      };
      GPWorkFlowNode.prototype.update = function(deltaTime) {
        this.OnUpdate && this.OnUpdate(this, deltaTime);
      };
      GPWorkFlowNode.prototype.hasNext = function() {
        return this.nextNodes.length > 0;
      };
      return GPWorkFlowNode;
    }();
    exports.GPWorkFlowNode = GPWorkFlowNode;
    var GPWorkFlow = function() {
      function GPWorkFlow() {}
      GPWorkFlow.prototype.start = function() {
        this.headNode && this.headNode.refresh();
        this.curNode = this.headNode;
        this.curNode.start();
      };
      GPWorkFlow.prototype.update = function(deltaTime) {
        if (null != this.curNode) {
          this.curNode.update(deltaTime);
          if (this.curNode.isDone()) if (this.curNode.hasNext()) {
            this.curNode = this.curNode.nextNodes[this.curNode.nextIdx];
            this.curNode.start();
          } else this.curNode = null;
        }
      };
      GPWorkFlow.prototype.insertHeadNode = function(wfNode) {
        var tmp = this.headNode;
        this.headNode = wfNode;
        wfNode.nextNode = tmp;
      };
      return GPWorkFlow;
    }();
    exports.GPWorkFlow = GPWorkFlow;
    cc._RF.pop();
  }, {} ],
  GameConfig: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "f46b13WB51JHaffBN5ie56i", "GameConfig");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var GameConfig = function() {
      function GameConfig() {}
      Object.defineProperty(GameConfig, "debugUserId", {
        get: function() {
          return this._debugUserId;
        },
        enumerable: false,
        configurable: true
      });
      GameConfig.gameId = "";
      GameConfig.version = "0.0.1";
      GameConfig._debugUserId = "";
      return GameConfig;
    }();
    exports.default = GameConfig;
    cc._RF.pop();
  }, {} ],
  Game: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "30ba5eNytVM3pckqs/AGbqm", "Game");
    "use strict";
    var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = this && this.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (1 & t[0]) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, "function" === typeof Symbol && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([ n, v ]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = 2 & op[0] ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 
          0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          (y = 0, t) && (op = [ 2 & op[0], t.value ]);
          switch (op[0]) {
           case 0:
           case 1:
            t = op;
            break;

           case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

           case 5:
            _.label++;
            y = op[1];
            op = [ 0 ];
            continue;

           case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;

           default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (6 === op[0] || 2 === op[0])) {
              _ = 0;
              continue;
            }
            if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (6 === op[0] && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop();
            _.trys.pop();
            continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [ 6, e ];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (5 & op[0]) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Game = void 0;
    var ConfigMgr_1 = require("./Manager/ConfigMgr");
    var DataMgr_1 = require("./Manager/DataMgr");
    var PlayerMgr_1 = require("./Manager/PlayerMgr");
    var Game = function() {
      function Game() {
        this.inited = false;
        this.configMgr = null;
        this.playerMgr = null;
        this.dbMgr = null;
      }
      Game.prototype.init = function(uiRoot) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              this.configMgr = new ConfigMgr_1.default(this);
              this.playerMgr = new PlayerMgr_1.default(this);
              this.dbMgr = new DataMgr_1.default(this);
              return [ 4, this.configMgr.loadConfigs() ];

             case 1:
              _a.sent();
              this.inited = true;
              return [ 2 ];
            }
          });
        });
      };
      Game.prototype.onGameShow = function() {};
      Game.prototype.onGameHide = function() {};
      Game.prototype.update = function(dt) {
        if (!this.inited) return;
      };
      return Game;
    }();
    exports.Game = Game;
    var GameMgr = new Game();
    exports.default = GameMgr;
    cc._RF.pop();
  }, {
    "./Manager/ConfigMgr": "ConfigMgr",
    "./Manager/DataMgr": "DataMgr",
    "./Manager/PlayerMgr": "PlayerMgr"
  } ],
  GlobalData: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "ffa9djWp4hFqooiKPOq5qJN", "GlobalData");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.GlobalData = void 0;
    class GlobalData {}
    exports.GlobalData = GlobalData;
    GlobalData.gameData = {
      roleMoveSpeed: 300,
      rolePlaySpeed: 50,
      waitMaxNumber: 10,
      waitingSpeedY: 70,
      roleCreateTime: 10,
      iceRandom: .5,
      drinkTime: 5
    };
    GlobalData.forceUpdateTable = true;
    GlobalData.tableData = [];
    GlobalData.encrypKey = "xyylyyrmm1htlhyl";
    GlobalData.encrypIv = "bkwzsyzy2qcywwbd";
    GlobalData.tablePath = "img/table/";
    GlobalData.rawPath = "img/raw/";
    GlobalData.coffeeTypePath = "img/coffee/";
    GlobalData.tumblerePath = "img/tumbler/";
    GlobalData.rolePath = "animation/";
    GlobalData.roleImgPath = "img/role/";
    GlobalData.userId = 1;
    cc._RF.pop();
  }, {} ],
  GlobalHelper: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "97861Bw45RARLIDvaYH8CIV", "GlobalHelper");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var GlobalHelper = function() {
      function GlobalHelper() {}
      GlobalHelper.Register = function(name, inst) {
        GlobalHelper[name] = inst;
      };
      GlobalHelper.Get = function(name) {
        return GlobalHelper._globalMap.hasOwnProperty(name) ? GlobalHelper._globalMap[name] : void 0;
      };
      GlobalHelper._globalMap = {};
      return GlobalHelper;
    }();
    exports.default = GlobalHelper;
    window["GlobalHelper"] = GlobalHelper;
    cc._RF.pop();
  }, {} ],
  GridScrollList: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "1cacdUiKzNJIJRK/5ihZG1M", "GridScrollList");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.GridScrollList = void 0;
    var ScrollViewHelper_1 = require("../../Common/Components/ScrollViewHelper");
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
    var RowDirection;
    (function(RowDirection) {
      RowDirection[RowDirection["LeftToRight"] = 0] = "LeftToRight";
      RowDirection[RowDirection["TopToBottom"] = 1] = "TopToBottom";
    })(RowDirection || (RowDirection = {}));
    var GridScrollList = function(_super) {
      __extends(GridScrollList, _super);
      function GridScrollList() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.allProxy = [];
        _this.scrollHelper = null;
        _this.rowDirection = RowDirection.LeftToRight;
        _this.colSpace = 10;
        _this.rowSpace = 10;
        _this.colCount = 3;
        _this.margin = 10;
        return _this;
      }
      GridScrollList.prototype.doLayout = function() {
        this._layoutItems();
      };
      GridScrollList.prototype._layoutItems = function() {
        this.scrollHelper.clearData();
        var data = this.allProxy;
        var elemSize = data.length ? data[0].region.size : cc.size(0, 0);
        var xSpace = this.colSpace;
        var ySpace = this.rowSpace;
        var colCount = this.colCount;
        var viewSize = this.scrollHelper.scrollView.node.getContentSize();
        if (this.rowDirection == RowDirection.TopToBottom) {
          var temp = viewSize.width;
          viewSize.width = viewSize.height;
          viewSize.height = temp;
          temp = elemSize.width;
          elemSize.width = elemSize.height;
          elemSize.height = temp;
        }
        var yMargin = this.margin;
        var xMargin = (viewSize.width - (colCount * elemSize.width + (colCount - 1) * xSpace)) / 2;
        var x = xMargin;
        var y = -yMargin + ySpace + elemSize.height;
        var dy = -ySpace - elemSize.height;
        var dx = xSpace + elemSize.width;
        if (this.rowDirection == RowDirection.TopToBottom) {
          dy = ySpace + elemSize.height;
          dx = -xSpace - elemSize.width;
          y = yMargin - dy;
        }
        for (var i = 0; i < data.length; i++) {
          x += dx;
          if (i % colCount == 0) {
            y += dy;
            x = xMargin;
          }
          var proxy = data[i];
          this.rowDirection == RowDirection.LeftToRight ? proxy.region.origin = cc.v2(x, y - elemSize.height) : proxy.region.origin = cc.v2(y, x - elemSize.height);
          this.scrollHelper.addData(proxy);
        }
        this.rowDirection == RowDirection.LeftToRight ? this.scrollHelper.scrollView.content.setContentSize(viewSize.width, -y + elemSize.height + yMargin) : this.scrollHelper.scrollView.content.setContentSize(y + elemSize.height + yMargin, viewSize.width);
      };
      __decorate([ property(ScrollViewHelper_1.ScrollViewHelper) ], GridScrollList.prototype, "scrollHelper", void 0);
      __decorate([ property({
        type: cc.Enum(RowDirection)
      }) ], GridScrollList.prototype, "rowDirection", void 0);
      __decorate([ property() ], GridScrollList.prototype, "colSpace", void 0);
      __decorate([ property() ], GridScrollList.prototype, "rowSpace", void 0);
      __decorate([ property() ], GridScrollList.prototype, "colCount", void 0);
      __decorate([ property() ], GridScrollList.prototype, "margin", void 0);
      GridScrollList = __decorate([ ccclass ], GridScrollList);
      return GridScrollList;
    }(cc.Component);
    exports.GridScrollList = GridScrollList;
    cc._RF.pop();
  }, {
    "../../Common/Components/ScrollViewHelper": "ScrollViewHelper"
  } ],
  InitGameData: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "bb7acucUWtA56vH8VXGYLU7", "InitGameData");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.InitGameData = void 0;
    class InitGameData {}
    exports.InitGameData = InitGameData;
    InitGameData.RawMaterial = [ {
      ID: 2001,
      name: "\u6c34",
      price: 0,
      intro: "\u4e00\u4efd\u7eaf\u51c0\u6c34\uff0c\u4e07\u7269\u7684\u8d77\u6e90\uff0c\u4e0d\u53ef\u51fa\u552e",
      type: "item_raw",
      sell: 0,
      count: 3
    }, {
      ID: 2002,
      name: "\u5496\u5561\u8c46",
      price: 0,
      intro: "\u70d8\u7119\u597d\u7684\u5496\u5561\u8c46\uff0c\u4e0d\u53ef\u51fa\u552e",
      type: "item_raw",
      sell: 0,
      count: 3
    }, {
      ID: 2003,
      name: "\u51b0",
      price: 0,
      intro: "\u628a\u90a3\u4e2a\u7eaf\u51c0\u6c34\u653e\u8fdb\u5236\u51b0\u673a\u91cc\u5f97\u6765\u7684\uff0c\u4e0d\u53ef\u51fa\u552e",
      type: "item_raw",
      sell: 0,
      count: 3
    } ];
    InitGameData.UserData = [ {
      ID: 1001,
      name: "\u9ed8\u8ba4\u7528\u6237\u540d",
      gold: 1e3,
      loginTime: 0,
      isUpdateVarietyCount: 0
    } ];
    InitGameData.StoreData = [ {
      ID: 1001,
      name: "\u5496\u5561\u5e97",
      level: 1,
      star: 0,
      price: 0,
      efficiency: "",
      limit: "",
      makeEffic: 7,
      makeMax: 3,
      decorates: []
    } ];
    InitGameData.RecipeList = [ {
      ID: 1001,
      name: "%s\u6c34",
      name_e: "water",
      raw1: 2001,
      raw2: "",
      raw3: "",
      raw4: "",
      raw5: "",
      raw6: "",
      coldDrink: true,
      price: 2,
      resPath: 1001,
      cupType: 1,
      tumbler_f: "glass10",
      tumbler_b: "glass11",
      intro: "\u4e00\u676f\u6c34",
      type: "formula",
      subType: "cofee",
      unlock: "lock"
    }, {
      ID: 1002,
      name: "\u610f\u5f0f\u6d53\u7f29\u5496\u5561",
      name_e: "Espresso",
      raw1: 2002,
      raw2: "",
      raw3: "",
      raw4: "",
      raw5: "",
      raw6: "",
      coldDrink: "",
      price: 3,
      resPath: 1002,
      cupType: 3,
      tumbler_f: "glass30",
      tumbler_b: "glass31",
      intro: "\u7ecf\u5178\u7684\u6d53\u7f29\u5496\u5561\uff0c\u5982\u679c\u76f4\u996e\u5efa\u8bae\u52a0\u7cd6",
      type: "formula",
      subType: "cofee",
      unlock: "lock"
    }, {
      ID: 1003,
      name: "%s\u7f8e\u5f0f\u5496\u5561",
      name_e: "Americano",
      raw1: 2001,
      raw2: 2002,
      raw3: "",
      raw4: "",
      raw5: "",
      raw6: "",
      coldDrink: true,
      price: 4,
      resPath: 1003,
      cupType: 1,
      tumbler_f: "glass10",
      tumbler_b: "glass11",
      intro: "\u7ecf\u5178\u597d\u559d\uff01",
      type: "formula",
      subType: "cofee",
      unlock: "lock"
    }, {
      ID: 1004,
      name: "%s\u62ff\u94c1\u5496\u5561",
      name_e: "latte",
      raw1: 2004,
      raw2: 2002,
      raw3: "",
      raw4: "",
      raw5: "",
      raw6: "",
      coldDrink: true,
      price: 5,
      resPath: 1004,
      cupType: 1,
      tumbler_f: "glass10",
      tumbler_b: "glass11",
      intro: "\u7ecf\u5178\u7684\u62ff\u94c1\u5496\u5561\uff0c\u5728\u5f88\u591a\u5730\u65b9\u90fd\u662f\u62db\u724c",
      type: "formula",
      subType: "cofee",
      unlock: "lock"
    }, {
      ID: 1005,
      name: "\u6469\u5361\u5496\u5561",
      name_e: "Mocha",
      raw1: 2004,
      raw2: 2002,
      raw3: 2005,
      raw4: "",
      raw5: "",
      raw6: "",
      coldDrink: "",
      price: 9,
      resPath: 1005,
      cupType: 2,
      tumbler_f: "glass20",
      tumbler_b: "glass21",
      intro: "\u4e00\u79cd\u53e4\u8001\u7684\u5496\u5561",
      type: "formula",
      subType: "cofee",
      unlock: "lock"
    }, {
      ID: 1006,
      name: "\u70ed\u5de7\u514b\u529b",
      name_e: "Hot_chocolate",
      raw1: 2005,
      raw2: 2004,
      raw3: "",
      raw4: "",
      raw5: "",
      raw6: "",
      coldDrink: "",
      price: 6,
      resPath: 1006,
      cupType: 2,
      tumbler_f: "glass20",
      tumbler_b: "glass21",
      intro: "\u788e\u788e\u7684\u5de7\u514b\u529b\u52a0\u4e0a\u725b\u5976\u540e\u4e00\u8d77\u52a0\u70ed\u5f62\u6210\u4e86\u8fd9\u79cd\u5947\u5999\u4e1d\u6ed1\u7684\u996e\u54c1",
      type: "formula",
      subType: "cofee",
      unlock: "lock"
    }, {
      ID: 1007,
      name: "%s\u6930\u6c41",
      name_e: "Coconut",
      raw1: 2006,
      raw2: "",
      raw3: "",
      raw4: "",
      raw5: "",
      raw6: "",
      coldDrink: true,
      price: 5,
      resPath: 1007,
      cupType: 1,
      tumbler_f: "glass10",
      tumbler_b: "glass11",
      intro: "\u6930\u5b50~\u597d\u559d\u7684\u6930\u5b50~\n\u800c\u4e14\u7edd\u5bf9\u6ca1\u6709\u5151\u6c34",
      type: "formula",
      subType: "cofee",
      unlock: "lock"
    }, {
      ID: 1008,
      name: "\u6930\u6c41%s\u62ff\u94c1",
      name_e: "Coconut_latte",
      raw1: 2006,
      raw2: 2004,
      raw3: 2002,
      raw4: "",
      raw5: "",
      raw6: "",
      coldDrink: true,
      price: 10,
      resPath: 1008,
      cupType: 1,
      tumbler_f: "glass10",
      tumbler_b: "glass11",
      intro: "\u52a0\u5165\u4e86\u5976\u6cb9\u7684\u62ff\u94c1\u5496\u5561\uff0c\u8ba9\u53e3\u611f\u53d8\u5f97\u66f4\u52a0\u6e05\u723d",
      type: "formula",
      subType: "cofee",
      unlock: "lock"
    }, {
      ID: 1009,
      name: "\u5976\u6cb9%s\u62ff\u94c1",
      name_e: "Cream_latte",
      raw1: 2002,
      raw2: 2004,
      raw3: 2007,
      raw4: "",
      raw5: "",
      raw6: "",
      coldDrink: true,
      price: 13,
      resPath: 1009,
      cupType: 1,
      tumbler_f: "glass10",
      tumbler_b: "glass11",
      intro: "\u52a0\u5165\u4e86\u5976\u6cb9\u7684\u62ff\u94c1\u5496\u5561\uff0c\u8ba9\u53e3\u611f\u53d8\u5f97\u66f4\u52a0\u7ec6\u817b\u9999\u751c",
      type: "formula",
      subType: "cofee",
      unlock: "lock"
    }, {
      ID: 1010,
      name: "\u5976\u6cb9\u5de7\u514b\u529b",
      name_e: "Cream_chocolate",
      raw1: 2005,
      raw2: 2004,
      raw3: 2007,
      raw4: "",
      raw5: "",
      raw6: "",
      coldDrink: "",
      price: 14,
      resPath: 1010,
      cupType: 2,
      tumbler_f: "glass20",
      tumbler_b: "glass21",
      intro: "\u5947\u5999\u7684\u5e78\u798f\u6ce1\u6ce1",
      type: "formula",
      subType: "cofee",
      unlock: "lock"
    }, {
      ID: 1011,
      name: "\u7126\u7cd6\u7f8e\u5f0f",
      name_e: "Caramel_Americano",
      raw1: 2008,
      raw2: 2001,
      raw3: 2002,
      raw4: "",
      raw5: "",
      raw6: "",
      coldDrink: "",
      price: 12,
      resPath: 1011,
      cupType: 1,
      tumbler_f: "glass10",
      tumbler_b: "glass11",
      intro: "\u50cf\u8dc3\u52a8\u7740\u7684\u706b\u7cbe\u7075",
      type: "formula",
      subType: "cofee",
      unlock: "lock"
    }, {
      ID: 1012,
      name: "\u7126\u7cd6\u739b\u5947\u6735",
      name_e: "Caramel_macchiato",
      raw1: 2008,
      raw2: 2004,
      raw3: 2002,
      raw4: "",
      raw5: "",
      raw6: "",
      coldDrink: "",
      price: 12,
      resPath: 1012,
      cupType: 2,
      tumbler_f: "glass20",
      tumbler_b: "glass21",
      intro: "\u751c\u871c\u7684\u5370\u8bb0",
      type: "formula",
      subType: "cofee",
      unlock: "lock"
    } ];
    InitGameData.barData = [ {
      level: 1,
      star: 0,
      price: 0,
      efficiency: "",
      limit: "",
      makeEffic: 7,
      makeMax: 3
    }, {
      level: 2,
      star: 5,
      price: 1500,
      efficiency: 1,
      limit: 1,
      makeEffic: 6,
      makeMax: 4
    }, {
      level: 3,
      star: 12,
      price: 2300,
      efficiency: .5,
      limit: 0,
      makeEffic: 5.5,
      makeMax: 4
    }, {
      level: 4,
      star: 30,
      price: 4200,
      efficiency: .3,
      limit: 1,
      makeEffic: 5.2,
      makeMax: 5
    }, {
      level: 5,
      star: 38,
      price: 6800,
      efficiency: .2,
      limit: 1,
      makeEffic: 5,
      makeMax: 6
    }, {
      level: 6,
      star: 60,
      price: 7900,
      efficiency: 0,
      limit: 1,
      makeEffic: 5,
      makeMax: 7
    } ];
    InitGameData.Ornaments = [];
    InitGameData.Table = [ {
      ID: 3001,
      name: "\u6728\u684c",
      price: 0,
      intro: "\u7528\u6728\u677f\u5236\u6210\u7684\u666e\u901a\u684c\u5b50",
      type: 1,
      offseter: "",
      rank: 1,
      area: 1,
      resPath: "img/table/",
      count: 1,
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": ""
    } ];
    InitGameData.Role = [ {
      ID: "001",
      name: "zanghu"
    }, {
      ID: "002",
      name: "cat"
    }, {
      ID: "003",
      name: "ciwei"
    } ];
    cc._RF.pop();
  }, {} ],
  Joystick: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "f4f39PJ1X1HeJ5ebUDPNPNG", "Joystick");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.JoystickType = exports.SpeedType = exports.DirectionType = exports.instance = void 0;
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
    exports.instance = new cc.EventTarget();
    var DirectionType;
    (function(DirectionType) {
      DirectionType[DirectionType["FOUR"] = 0] = "FOUR";
      DirectionType[DirectionType["EIGHT"] = 1] = "EIGHT";
      DirectionType[DirectionType["ALL"] = 2] = "ALL";
    })(DirectionType = exports.DirectionType || (exports.DirectionType = {}));
    var SpeedType;
    (function(SpeedType) {
      SpeedType[SpeedType["STOP"] = 0] = "STOP";
      SpeedType[SpeedType["NORMAL"] = 1] = "NORMAL";
      SpeedType[SpeedType["FAST"] = 2] = "FAST";
    })(SpeedType = exports.SpeedType || (exports.SpeedType = {}));
    var JoystickType;
    (function(JoystickType) {
      JoystickType[JoystickType["FIXED"] = 0] = "FIXED";
      JoystickType[JoystickType["FOLLOW"] = 1] = "FOLLOW";
    })(JoystickType = exports.JoystickType || (exports.JoystickType = {}));
    var Joystick = function(_super) {
      __extends(Joystick, _super);
      function Joystick() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.dot = null;
        _this.ring = null;
        _this.joystickType = JoystickType.FIXED;
        _this.directionType = DirectionType.ALL;
        _this._stickPos = null;
        _this._touchLocation = null;
        _this._radius = 0;
        return _this;
      }
      Joystick.prototype.onLoad = function() {
        this._radius = this.ring.width / 2;
        this._initTouchEvent();
        this.joystickType === JoystickType.FOLLOW && (this.node.opacity = 0);
      };
      Joystick.prototype.onEnable = function() {
        exports.instance.on("set_joystick_type", this._onSetJoystickType, this);
      };
      Joystick.prototype.onDisable = function() {
        exports.instance.off("set_joystick_type", this._onSetJoystickType, this);
      };
      Joystick.prototype._onSetJoystickType = function(type) {
        this.joystickType = type;
        this.node.opacity = type === JoystickType.FIXED ? 255 : 0;
      };
      Joystick.prototype._initTouchEvent = function() {
        this.node.on(cc.Node.EventType.TOUCH_START, this._touchStartEvent, this);
        this.node.on(cc.Node.EventType.TOUCH_MOVE, this._touchMoveEvent, this);
        this.node.on(cc.Node.EventType.TOUCH_END, this._touchEndEvent, this);
        this.node.on(cc.Node.EventType.TOUCH_CANCEL, this._touchEndEvent, this);
      };
      Joystick.prototype._touchStartEvent = function(event) {
        exports.instance.emit(cc.Node.EventType.TOUCH_START, event);
        var touchPos = this.node.convertToNodeSpaceAR(event.getLocation());
        if (this.joystickType === JoystickType.FIXED) {
          this._stickPos = this.ring.getPosition();
          var distance = touchPos.sub(this.ring.getPosition()).mag();
          this._radius > distance && this.dot.setPosition(touchPos);
        } else if (this.joystickType === JoystickType.FOLLOW) {
          this._stickPos = touchPos;
          this.node.opacity = 255;
          this._touchLocation = event.getLocation();
          this.ring.setPosition(touchPos);
          this.dot.setPosition(touchPos);
        }
      };
      Joystick.prototype._touchMoveEvent = function(event) {
        if (this.joystickType === JoystickType.FOLLOW && this._touchLocation === event.getLocation()) return false;
        var touchPos = this.ring.convertToNodeSpaceAR(event.getLocation());
        var distance = touchPos.mag();
        var posX = this._stickPos.x + touchPos.x;
        var posY = this._stickPos.y + touchPos.y;
        var p = cc.v2(posX, posY).sub(this.ring.getPosition()).normalize();
        var speedType;
        if (this._radius > distance) {
          this.dot.setPosition(cc.v2(posX, posY));
          speedType = SpeedType.NORMAL;
        } else {
          var x = this._stickPos.x + p.x * this._radius;
          var y = this._stickPos.y + p.y * this._radius;
          this.dot.setPosition(cc.v2(x, y));
          speedType = SpeedType.FAST;
        }
        exports.instance.emit(cc.Node.EventType.TOUCH_MOVE, event, {
          speedType: speedType,
          moveDistance: p
        });
      };
      Joystick.prototype._touchEndEvent = function(event) {
        this.dot.setPosition(this.ring.getPosition());
        this.joystickType === JoystickType.FOLLOW && (this.node.opacity = 0);
        exports.instance.emit(cc.Node.EventType.TOUCH_END, event, {
          speedType: SpeedType.STOP
        });
      };
      __decorate([ property({
        type: cc.Node,
        displayName: "Dot",
        tooltip: "\u6447\u6746\u64cd\u7eb5\u70b9"
      }) ], Joystick.prototype, "dot", void 0);
      __decorate([ property({
        type: cc.Node,
        displayName: "Ring",
        tooltip: "\u6447\u6746\u80cc\u666f\u8282\u70b9"
      }) ], Joystick.prototype, "ring", void 0);
      __decorate([ property({
        type: cc.Enum(JoystickType),
        displayName: "Touch Type",
        tooltip: "\u89e6\u6478\u7c7b\u578b"
      }) ], Joystick.prototype, "joystickType", void 0);
      __decorate([ property({
        type: cc.Enum(DirectionType),
        displayName: "Direction Type",
        tooltip: "\u65b9\u5411\u7c7b\u578b"
      }) ], Joystick.prototype, "directionType", void 0);
      __decorate([ property({
        type: cc.Node,
        tooltip: "\u6447\u6746\u6240\u5728\u4f4d\u7f6e"
      }) ], Joystick.prototype, "_stickPos", void 0);
      __decorate([ property({
        type: cc.Node,
        tooltip: "\u89e6\u6478\u4f4d\u7f6e"
      }) ], Joystick.prototype, "_touchLocation", void 0);
      __decorate([ property({
        tooltip: "\u534a\u5f84"
      }) ], Joystick.prototype, "_radius", void 0);
      Joystick = __decorate([ ccclass ], Joystick);
      return Joystick;
    }(cc.Component);
    exports.default = Joystick;
    cc._RF.pop();
  }, {} ],
  KawaseBlur: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "bc261DWSZZNW4xSy/P01RJV", "KawaseBlur");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
    var KawaseBlur = function(_super) {
      __extends(KawaseBlur, _super);
      function KawaseBlur() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.sprite = null;
        _this.material = null;
        _this.renderTexture = null;
        return _this;
      }
      KawaseBlur.prototype.start = function() {
        var sprite = this.sprite, node = this.sprite.node;
        sprite.srcBlendFactor = cc.macro.BlendFactor.ONE;
        var material = this.material;
        material.setProperty("resolution", cc.v2(node.width, node.height));
        var srcRT = new cc.RenderTexture(), dstRT = new cc.RenderTexture();
        this.getRenderTexture(node, srcRT);
        this.renderWithMaterial(srcRT, dstRT, material);
        this.renderWithMaterial(dstRT, srcRT, material);
        this.renderWithMaterial(srcRT, dstRT, material);
        this.renderWithMaterial(dstRT, srcRT, material);
        this.renderWithMaterial(srcRT, dstRT, material);
        this.renderTexture = dstRT;
        sprite.spriteFrame = new cc.SpriteFrame(this.renderTexture);
        srcRT.destroy();
      };
      KawaseBlur.prototype.onDestroy = function() {
        this.renderTexture && this.renderTexture.destroy();
      };
      KawaseBlur.prototype.getRenderTexture = function(node, out) {
        if (!cc.isValid(node)) return null;
        out && out instanceof cc.RenderTexture || (out = new cc.RenderTexture());
        var width = Math.floor(node.width), height = Math.floor(node.height);
        out.initWithSize(width, height);
        var cameraNode = new cc.Node();
        cameraNode.parent = node;
        var camera = cameraNode.addComponent(cc.Camera);
        camera.clearFlags |= cc.Camera.ClearFlags.COLOR;
        camera.backgroundColor = cc.color(0, 0, 0, 0);
        camera.zoomRatio = cc.winSize.height / height;
        camera.targetTexture = out;
        camera.render(node);
        cameraNode.destroy();
        return out;
      };
      KawaseBlur.prototype.renderWithMaterial = function(srcRT, dstRT, material) {
        if (dstRT instanceof cc.Material) {
          material = dstRT;
          dstRT = new cc.RenderTexture();
        }
        var tempNode = new cc.Node();
        tempNode.setParent(cc.Canvas.instance.node);
        var tempSprite = tempNode.addComponent(cc.Sprite);
        tempSprite.sizeMode = cc.Sprite.SizeMode.RAW;
        tempSprite.trim = false;
        tempSprite.spriteFrame = new cc.SpriteFrame(srcRT);
        var width = srcRT.width, height = srcRT.height;
        dstRT.initWithSize(width, height);
        material instanceof cc.Material && tempSprite.setMaterial(0, material);
        var cameraNode = new cc.Node();
        cameraNode.setParent(tempNode);
        var camera = cameraNode.addComponent(cc.Camera);
        camera.clearFlags |= cc.Camera.ClearFlags.COLOR;
        camera.backgroundColor = cc.color(0, 0, 0, 0);
        camera.zoomRatio = cc.winSize.height / height;
        camera.targetTexture = dstRT;
        camera.render(tempNode);
        cameraNode.destroy();
        tempNode.destroy();
        return dstRT;
      };
      __decorate([ property({
        type: cc.Sprite,
        tooltip: false
      }) ], KawaseBlur.prototype, "sprite", void 0);
      __decorate([ property({
        type: cc.Material,
        tooltip: false
      }) ], KawaseBlur.prototype, "material", void 0);
      KawaseBlur = __decorate([ ccclass ], KawaseBlur);
      return KawaseBlur;
    }(cc.Component);
    exports.default = KawaseBlur;
    cc._RF.pop();
  }, {} ],
  LRUCache: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "2516dDnewNJ2I/vyZM6Z9rJ", "LRUCache");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.LRUCache = void 0;
    var Pool_1 = require("./Pool");
    var LRUNode = function() {
      function LRUNode(value, next) {
        this.value = value;
        this.next = next;
      }
      LRUNode.prototype.use = function(value, next) {
        this.value = value;
        this.next = next;
      };
      LRUNode.prototype.free = function() {
        this.value = "";
        this.next = null;
      };
      return LRUNode;
    }();
    var LRUCache = function() {
      function LRUCache(maxSize) {
        this.nodePool = new Pool_1.Pool(function() {
          return new LRUNode("", null);
        }, 3);
        this.maxSize = maxSize;
        this.head = new LRUNode("head", null);
        this.size = 0;
      }
      LRUCache.prototype.remove = function(value) {
        var node = this.has(value);
        node && this.removeNode(node);
      };
      LRUCache.prototype.put = function(value) {
        if (this.size <= 0) {
          this.last = this.nodePool.alloc(value, null);
          this.last.prev = this.head;
          this.head.next = this.last;
          this.size = 1;
          return;
        }
        var node = this.has(value);
        if (!node) {
          node = this.nodePool.alloc(value, null);
          this.addHead(node);
          return;
        }
        if (node == this.head.next) return;
        this.removeNode(node);
        this.addHead(node);
      };
      LRUCache.prototype.needDelete = function() {
        return this.size > this.maxSize;
      };
      LRUCache.prototype.deleteLastNode = function() {
        var value = this.last.value;
        this.removeNode(this.last);
        return value;
      };
      LRUCache.prototype.removeNode = function(node) {
        node.prev.next = node.next;
        node.next ? node.next.prev = node.prev : this.last = node.prev;
        node.prev = null;
        node.next = null;
        this.nodePool.free(node);
        this.size--;
      };
      LRUCache.prototype.addHead = function(node) {
        node.next = this.head.next;
        node.next && (node.next.prev = node);
        this.head.next = node;
        node.prev = this.head;
        this.size++;
      };
      LRUCache.prototype.has = function(value) {
        var next = this.head.next;
        var count = 0;
        while (next) {
          if (next.value == value) return next;
          next = next.next;
          count++;
          if (count > this.maxSize) break;
        }
        return null;
      };
      LRUCache.prototype.toString = function() {
        var str = "";
        var next = this.head.next;
        return str;
      };
      return LRUCache;
    }();
    exports.LRUCache = LRUCache;
    cc._RF.pop();
  }, {
    "./Pool": "Pool"
  } ],
  LightStruct: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "c719fETXCJI04htRCnD+NLA", "LightStruct");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Intersection = void 0;
    var Intersection = function() {
      function Intersection(x, y, len, angle) {
        this.x = x;
        this.y = y;
        this.len = len;
        this.angle = angle;
      }
      return Intersection;
    }();
    exports.Intersection = Intersection;
    cc._RF.pop();
  }, {} ],
  LightUtils: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "cd1b9xWLxVAN7fJCCK/oCfF", "LightUtils");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var LightUtils = function() {
      function LightUtils() {}
      LightUtils.getIntersections = function(light, polygons) {
        var rayStart = light;
        var rayEnds = this.getRayEnds(polygons);
        var intersects = [];
        for (var _i = 0, rayEnds_1 = rayEnds; _i < rayEnds_1.length; _i++) {
          var rayEnd = rayEnds_1[_i];
          var l = this.getNormal(rayEnd.sub(rayStart));
          for (var i = -1; i <= 1; i++) {
            var tmpRayEnd = rayEnd.add(l.mul(.001 * i));
            var intersect = this.getIntersection(polygons, rayStart, tmpRayEnd);
            if (!intersect) continue;
            intersect.angle = Math.atan2(tmpRayEnd.y - rayStart.y, tmpRayEnd.x - rayStart.x);
            intersects.push(intersect);
          }
        }
        intersects = intersects.sort(function(a, b) {
          return a.angle - b.angle;
        });
        return intersects;
      };
      LightUtils.getNormal = function(line) {
        var l = line.normalize();
        var tmp = l.x;
        l.x = l.y;
        l.y = -tmp;
        return l;
      };
      LightUtils.getRayEnds = function(polygons) {
        var rayEnds = [];
        for (var i = 0; i < polygons.length; i++) {
          var seg = polygons[i];
          for (var j = 0; j < seg.length; j++) rayEnds.push(seg[j]);
        }
        return rayEnds;
      };
      LightUtils.getIntersection = function(polygons, rayStart, rayEnd) {
        var closestIntersect = null;
        for (var i = 0; i < polygons.length; i++) {
          var seg = polygons[i];
          for (var j = 0; j < seg.length; j++) {
            var intersect = this._doGetIntersection(rayStart, rayEnd, seg[j], j === seg.length - 1 ? seg[0] : seg[j + 1]);
            if (!intersect) continue;
            (!closestIntersect || intersect.len < closestIntersect.len) && (closestIntersect = intersect);
          }
        }
        return closestIntersect;
      };
      LightUtils.getIntersectionByAngle = function(startAngle, angleRange, light, polygons) {
        var endAngle = startAngle + angleRange;
        startAngle *= .017453;
        endAngle *= .017453;
        var rayEnd1 = cc.v2(Math.cos(startAngle), Math.sin(startAngle)).add(light);
        var rayEnd2 = cc.v2(Math.cos(endAngle), Math.sin(endAngle)).add(light);
        var intersect1 = this.getIntersection(polygons, light, rayEnd1);
        intersect1.angle = startAngle;
        var intersect2 = this.getIntersection(polygons, light, rayEnd2);
        intersect2.angle = endAngle;
        var intersects = this.getIntersections(light, polygons);
        var start = this.binarySearchIntersects(intersects, startAngle, true);
        var end = this.binarySearchIntersects(intersects, endAngle, false);
        intersects = intersects.slice(start, end + 1);
        intersects.unshift({
          x: light.x,
          y: light.y,
          len: 0
        }, intersect1);
        intersects.push(intersect2);
        return intersects;
      };
      LightUtils.binarySearchIntersects = function(arr, angle, findFlag) {
        void 0 === findFlag && (findFlag = false);
        var start = 0, end = arr.length - 1;
        while (end - start > 1) {
          var idx = Math.floor((start + end) / 2);
          if (angle < arr[idx].angle) end = idx; else {
            if (!(angle > arr[idx].angle)) return idx;
            start = idx;
          }
        }
        return findFlag ? end : start;
      };
      LightUtils._doGetIntersection = function(ray1, ray2, seg1, seg2) {
        var r_px = ray1.x;
        var r_py = ray1.y;
        var r_dx = ray2.x - ray1.x;
        var r_dy = ray2.y - ray1.y;
        var s_px = seg1.x;
        var s_py = seg1.y;
        var s_dx = seg2.x - seg1.x;
        var s_dy = seg2.y - seg1.y;
        var r_mag = r_dx * r_dx + r_dy * r_dy;
        var s_mag = s_dx * s_dx + s_dy * s_dy;
        if (r_dx / r_mag == s_dx / s_mag && r_dy / r_mag == s_dy / s_mag) return null;
        var T2 = (r_dx * (s_py - r_py) + r_dy * (r_px - s_px)) / (s_dx * r_dy - s_dy * r_dx);
        var T1 = (s_px + s_dx * T2 - r_px) / r_dx;
        if (T1 < 0) return null;
        if (T2 < 0 || T2 > 1) return null;
        return {
          x: r_px + r_dx * T1,
          y: r_py + r_dy * T1,
          len: T1
        };
      };
      return LightUtils;
    }();
    exports.default = LightUtils;
    cc._RF.pop();
  }, {} ],
  Light: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "68edfvWcX9CWav9zMp303o6", "Light");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.LightType = void 0;
    var QuadTree_1 = require("../Components/QuadTree");
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
    var LightType;
    (function(LightType) {
      LightType[LightType["Round"] = 0] = "Round";
      LightType[LightType["Sector"] = 1] = "Sector";
    })(LightType = exports.LightType || (exports.LightType = {}));
    var LightBound = new QuadTree_1.Bound(0, 0, 0, 0);
    var Light = function(_super) {
      __extends(Light, _super);
      function Light() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.graphics = null;
        _this.lightType = 0;
        _this.canvasSize = null;
        _this.visiableSize = null;
        _this.radius = 200;
        _this.fade = 1;
        _this._material = null;
        return _this;
      }
      Light.prototype.onLoad = function() {
        this._material = this.graphics.getMaterial(0);
        this.canvasSize = cc.view.getCanvasSize();
        this.visiableSize = cc.view.getCanvasSize();
        this.node.setContentSize(this.canvasSize);
        this._material.setProperty("screen", cc.v2(this.canvasSize.width, this.canvasSize.height));
        var r = this.radius / this.canvasSize.width;
        this._material.setProperty("maxRadius", r);
      };
      Light.prototype.start = function() {
        this.node.on(cc.Node.EventType.TOUCH_MOVE, this.onTouchMove, this);
      };
      Light.prototype.onDestroy = function() {
        this.node.off(cc.Node.EventType.TOUCH_MOVE, this.onTouchMove, this);
      };
      Light.prototype.onTouchMove = function(e) {
        this.node.x += e.getDeltaX();
        this.node.y += e.getDeltaY();
      };
      Light.prototype.getBound = function() {
        var pos = this.node.getPosition();
        LightBound.x = pos.x - this.radius / 2;
        LightBound.y = pos.y - this.radius / 2;
        LightBound.width = LightBound.height = this.radius;
        return LightBound;
      };
      Light.prototype.draw = function(intersections) {
        var lightPos = this.node.getPosition();
        this._doDraw(this.graphics, lightPos, intersections);
        this._material.setProperty("lightPos", cc.v2(lightPos.x / this.visiableSize.width, lightPos.y / this.visiableSize.height));
      };
      Light.prototype._doDraw = function(graphics, light, intersects) {
        graphics.clear();
        graphics.moveTo(intersects[0].x, intersects[0].y);
        for (var i = 1; i < intersects.length; i++) {
          var intersect = intersects[i];
          graphics.lineTo(intersect.x, intersect.y);
        }
        graphics.moveTo(intersects[0].x, intersects[0].y);
        graphics.fill();
      };
      __decorate([ property(cc.Graphics) ], Light.prototype, "graphics", void 0);
      __decorate([ property({
        type: cc.Enum(LightType)
      }) ], Light.prototype, "lightType", void 0);
      Light = __decorate([ ccclass ], Light);
      return Light;
    }(cc.Component);
    exports.default = Light;
    cc._RF.pop();
  }, {
    "../Components/QuadTree": "QuadTree"
  } ],
  ListItem: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "a7fffNLv8pJKpv/2o70E/WX", "ListItem");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, disallowMultiple = _a.disallowMultiple, menu = _a.menu, executionOrder = _a.executionOrder;
    var SelectedType;
    (function(SelectedType) {
      SelectedType[SelectedType["NONE"] = 0] = "NONE";
      SelectedType[SelectedType["TOGGLE"] = 1] = "TOGGLE";
      SelectedType[SelectedType["SWITCH"] = 2] = "SWITCH";
    })(SelectedType || (SelectedType = {}));
    var ListItem = function(_super) {
      __extends(ListItem, _super);
      function ListItem() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.icon = null;
        _this.title = null;
        _this.selectedMode = SelectedType.NONE;
        _this.selectedFlag = null;
        _this.selectedSpriteFrame = null;
        _this._unselectedSpriteFrame = null;
        _this.adaptiveSize = false;
        _this._selected = false;
        _this._eventReg = false;
        return _this;
      }
      Object.defineProperty(ListItem.prototype, "selected", {
        get: function() {
          return this._selected;
        },
        set: function(val) {
          this._selected = val;
          if (!this.selectedFlag) return;
          switch (this.selectedMode) {
           case SelectedType.TOGGLE:
            this.selectedFlag.active = val;
            break;

           case SelectedType.SWITCH:
            var sp = this.selectedFlag.getComponent(cc.Sprite);
            sp && (sp.spriteFrame = val ? this.selectedSpriteFrame : this._unselectedSpriteFrame);
          }
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ListItem.prototype, "btnCom", {
        get: function() {
          this._btnCom || (this._btnCom = this.node.getComponent(cc.Button));
          return this._btnCom;
        },
        enumerable: false,
        configurable: true
      });
      ListItem.prototype.onLoad = function() {
        if (this.selectedMode == SelectedType.SWITCH) {
          var com = this.selectedFlag.getComponent(cc.Sprite);
          this._unselectedSpriteFrame = com.spriteFrame;
        }
        this.btnCom && this._registerEvent();
      };
      ListItem.prototype.onDestroy = function() {
        this.node.off(cc.Node.EventType.SIZE_CHANGED, this._onSizeChange, this);
      };
      ListItem.prototype._registerEvent = function() {
        if (!this._eventReg) {
          this.btnCom && this.btnCom.clickEvents.unshift(this.createEvt(this, "onClickThis"));
          this.adaptiveSize && this.node.on(cc.Node.EventType.SIZE_CHANGED, this._onSizeChange, this);
          this._eventReg = true;
        }
      };
      ListItem.prototype._onSizeChange = function() {
        this.list._onItemAdaptive(this.node);
      };
      ListItem.prototype.createEvt = function(component, handlerName, node) {
        void 0 === node && (node = null);
        if (!component.isValid) return;
        component["comName"] = component["comName"] || component.name.match(/\<(.*?)\>/g).pop().replace(/\<|>/g, "");
        var evt = new cc.Component.EventHandler();
        evt.target = node || component.node;
        evt.component = component["comName"];
        evt.handler = handlerName;
        return evt;
      };
      ListItem.prototype.showAni = function(aniType, callFunc, del) {
        var t = this;
        var tween;
        switch (aniType) {
         case 0:
          tween = cc.tween(t.node).to(.2, {
            scale: .7
          }).by(.3, {
            y: 2 * t.node.height
          });
          break;

         case 1:
          tween = cc.tween(t.node).to(.2, {
            scale: .7
          }).by(.3, {
            x: 2 * t.node.width
          });
          break;

         case 2:
          tween = cc.tween(t.node).to(.2, {
            scale: .7
          }).by(.3, {
            y: -2 * t.node.height
          });
          break;

         case 3:
          tween = cc.tween(t.node).to(.2, {
            scale: .7
          }).by(.3, {
            x: -2 * t.node.width
          });
          break;

         default:
          tween = cc.tween(t.node).to(.3, {
            scale: .1
          });
        }
        (callFunc || del) && tween.call(function() {
          if (del) {
            t.list._delSingleItem(t.node);
            for (var n = t.list.displayData.length - 1; n >= 0; n--) if (t.list.displayData[n].id == t.listId) {
              t.list.displayData.splice(n, 1);
              break;
            }
          }
          callFunc();
        });
        tween.start();
      };
      ListItem.prototype.onClickThis = function() {
        this.list.selectedId = this.listId;
      };
      __decorate([ property({
        type: cc.Sprite,
        tooltip: false
      }) ], ListItem.prototype, "icon", void 0);
      __decorate([ property({
        type: cc.Node,
        tooltip: false
      }) ], ListItem.prototype, "title", void 0);
      __decorate([ property({
        type: cc.Enum(SelectedType),
        tooltip: false
      }) ], ListItem.prototype, "selectedMode", void 0);
      __decorate([ property({
        type: cc.Node,
        tooltip: false,
        visible: function() {
          return this.selectedMode > SelectedType.NONE;
        }
      }) ], ListItem.prototype, "selectedFlag", void 0);
      __decorate([ property({
        type: cc.SpriteFrame,
        tooltip: false,
        visible: function() {
          return this.selectedMode == SelectedType.SWITCH;
        }
      }) ], ListItem.prototype, "selectedSpriteFrame", void 0);
      __decorate([ property({
        tooltip: false
      }) ], ListItem.prototype, "adaptiveSize", void 0);
      ListItem = __decorate([ ccclass, disallowMultiple(), menu("\u81ea\u5b9a\u4e49\u7ec4\u4ef6/List Item"), executionOrder(-5001) ], ListItem);
      return ListItem;
    }(cc.Component);
    exports.default = ListItem;
    cc._RF.pop();
  }, {} ],
  List: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "c90caYxyjpBsprfoYNnL4hm", "List");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const {ccclass: ccclass, property: property, disallowMultiple: disallowMultiple, menu: menu, executionOrder: executionOrder, requireComponent: requireComponent} = cc._decorator;
    const ListItem_1 = require("./ListItem");
    var TemplateType;
    (function(TemplateType) {
      TemplateType[TemplateType["NODE"] = 1] = "NODE";
      TemplateType[TemplateType["PREFAB"] = 2] = "PREFAB";
    })(TemplateType || (TemplateType = {}));
    var SlideType;
    (function(SlideType) {
      SlideType[SlideType["NORMAL"] = 1] = "NORMAL";
      SlideType[SlideType["ADHERING"] = 2] = "ADHERING";
      SlideType[SlideType["PAGE"] = 3] = "PAGE";
    })(SlideType || (SlideType = {}));
    var SelectedType;
    (function(SelectedType) {
      SelectedType[SelectedType["NONE"] = 0] = "NONE";
      SelectedType[SelectedType["SINGLE"] = 1] = "SINGLE";
      SelectedType[SelectedType["MULT"] = 2] = "MULT";
    })(SelectedType || (SelectedType = {}));
    let List = class List extends cc.Component {
      constructor() {
        super(...arguments);
        this.templateType = TemplateType.NODE;
        this.tmpNode = null;
        this.tmpPrefab = null;
        this._slideMode = SlideType.NORMAL;
        this.pageDistance = .3;
        this.pageChangeEvent = new cc.Component.EventHandler();
        this._virtual = true;
        this.cyclic = false;
        this.lackCenter = false;
        this.lackSlide = false;
        this._updateRate = 0;
        this.frameByFrameRenderNum = 0;
        this.renderEvent = new cc.Component.EventHandler();
        this.selectedMode = SelectedType.NONE;
        this.repeatEventSingle = false;
        this.selectedEvent = new cc.Component.EventHandler();
        this._selectedId = -1;
        this._forceUpdate = false;
        this._updateDone = true;
        this._numItems = 0;
        this._inited = false;
        this._needUpdateWidget = false;
        this._aniDelRuning = false;
        this._doneAfterUpdate = false;
        this.adhering = false;
        this._adheringBarrier = false;
        this.curPageNum = 0;
      }
      set slideMode(val) {
        this._slideMode = val;
      }
      get slideMode() {
        return this._slideMode;
      }
      set virtual(val) {
        null != val && (this._virtual = val);
        (true, 0 != this._numItems) && this._onScrolling();
      }
      get virtual() {
        return this._virtual;
      }
      set updateRate(val) {
        val >= 0 && val <= 6 && (this._updateRate = val);
      }
      get updateRate() {
        return this._updateRate;
      }
      set selectedId(val) {
        let t = this;
        let item;
        switch (t.selectedMode) {
         case SelectedType.SINGLE:
          {
            if (!t.repeatEventSingle && val == t._selectedId) return;
            item = t.getItemByListId(val);
            let listItem;
            t._selectedId >= 0 ? t._lastSelectedId = t._selectedId : t._lastSelectedId = null;
            t._selectedId = val;
            if (item) {
              listItem = item.getComponent(ListItem_1.default);
              listItem.selected = true;
            }
            if (t._lastSelectedId >= 0 && t._lastSelectedId != t._selectedId) {
              let lastItem = t.getItemByListId(t._lastSelectedId);
              lastItem && (lastItem.getComponent(ListItem_1.default).selected = false);
            }
            t.selectedEvent && cc.Component.EventHandler.emitEvents([ t.selectedEvent ], item, val % this._actualNumItems, null == t._lastSelectedId ? null : t._lastSelectedId % this._actualNumItems);
            break;
          }

         case SelectedType.MULT:
          {
            item = t.getItemByListId(val);
            if (!item) return;
            let listItem = item.getComponent(ListItem_1.default);
            t._selectedId >= 0 && (t._lastSelectedId = t._selectedId);
            t._selectedId = val;
            let bool = !listItem.selected;
            listItem.selected = bool;
            let sub = t.multSelected.indexOf(val);
            bool && sub < 0 ? t.multSelected.push(val) : !bool && sub >= 0 && t.multSelected.splice(sub, 1);
            t.selectedEvent && cc.Component.EventHandler.emitEvents([ t.selectedEvent ], item, val % this._actualNumItems, null == t._lastSelectedId ? null : t._lastSelectedId % this._actualNumItems, bool);
            break;
          }
        }
      }
      get selectedId() {
        return this._selectedId;
      }
      set numItems(val) {
        let t = this;
        if (!t.checkInited(false)) return;
        if (null == val || val < 0) {
          cc.error("numItems set the wrong::", val);
          return;
        }
        t._actualNumItems = t._numItems = val;
        t._forceUpdate = true;
        if (t._virtual) {
          t._resizeContent();
          t.cyclic && (t._numItems = t._cyclicNum * t._numItems);
          t._onScrolling();
          t.frameByFrameRenderNum || t.slideMode != SlideType.PAGE || (t.curPageNum = t.nearestListId);
        } else {
          if (t.cyclic) {
            t._resizeContent();
            t._numItems = t._cyclicNum * t._numItems;
          }
          let layout = t.content.getComponent(cc.Layout);
          layout && (layout.enabled = true);
          t._delRedundantItem();
          t.firstListId = 0;
          if (t.frameByFrameRenderNum > 0) {
            let len = t.frameByFrameRenderNum > t._numItems ? t._numItems : t.frameByFrameRenderNum;
            for (let n = 0; n < len; n++) t._createOrUpdateItem2(n);
            if (t.frameByFrameRenderNum < t._numItems) {
              t._updateCounter = t.frameByFrameRenderNum;
              t._updateDone = false;
            }
          } else {
            for (let n = 0; n < t._numItems; n++) t._createOrUpdateItem2(n);
            t.displayItemNum = t._numItems;
          }
        }
      }
      get numItems() {
        return this._actualNumItems;
      }
      get scrollView() {
        return this._scrollView;
      }
      onLoad() {
        this._init();
      }
      onDestroy() {
        let t = this;
        cc.isValid(t._itemTmp) && t._itemTmp.destroy();
        cc.isValid(t.tmpNode) && t.tmpNode.destroy();
        t._pool && t._pool.clear();
      }
      onEnable() {
        this._registerEvent();
        this._init();
        if (this._aniDelRuning) {
          this._aniDelRuning = false;
          if (this._aniDelItem) {
            if (this._aniDelBeforePos) {
              this._aniDelItem.position = this._aniDelBeforePos;
              delete this._aniDelBeforePos;
            }
            if (this._aniDelBeforeScale) {
              this._aniDelItem.scale = this._aniDelBeforeScale;
              delete this._aniDelBeforeScale;
            }
            delete this._aniDelItem;
          }
          if (this._aniDelCB) {
            this._aniDelCB();
            delete this._aniDelCB;
          }
        }
      }
      onDisable() {
        this._unregisterEvent();
      }
      _registerEvent() {
        let t = this;
        t.node.on(cc.Node.EventType.TOUCH_START, t._onTouchStart, t, true);
        t.node.on("touch-up", t._onTouchUp, t);
        t.node.on(cc.Node.EventType.TOUCH_CANCEL, t._onTouchCancelled, t, true);
        t.node.on("scroll-began", t._onScrollBegan, t, true);
        t.node.on("scroll-ended", t._onScrollEnded, t, true);
        t.node.on("scrolling", t._onScrolling, t, true);
        t.node.on(cc.Node.EventType.SIZE_CHANGED, t._onSizeChanged, t);
      }
      _unregisterEvent() {
        let t = this;
        t.node.off(cc.Node.EventType.TOUCH_START, t._onTouchStart, t, true);
        t.node.off("touch-up", t._onTouchUp, t);
        t.node.off(cc.Node.EventType.TOUCH_CANCEL, t._onTouchCancelled, t, true);
        t.node.off("scroll-began", t._onScrollBegan, t, true);
        t.node.off("scroll-ended", t._onScrollEnded, t, true);
        t.node.off("scrolling", t._onScrolling, t, true);
        t.node.off(cc.Node.EventType.SIZE_CHANGED, t._onSizeChanged, t);
      }
      _init() {
        let t = this;
        if (t._inited) return;
        t._scrollView = t.node.getComponent(cc.ScrollView);
        t.content = t._scrollView.content;
        if (!t.content) {
          cc.error(t.node.name + "'s cc.ScrollView unset content!");
          return;
        }
        t._layout = t.content.getComponent(cc.Layout);
        t._align = t._layout.type;
        t._resizeMode = t._layout.resizeMode;
        t._startAxis = t._layout.startAxis;
        t._topGap = t._layout.paddingTop;
        t._rightGap = t._layout.paddingRight;
        t._bottomGap = t._layout.paddingBottom;
        t._leftGap = t._layout.paddingLeft;
        t._columnGap = t._layout.spacingX;
        t._lineGap = t._layout.spacingY;
        t._colLineNum;
        t._verticalDir = t._layout.verticalDirection;
        t._horizontalDir = t._layout.horizontalDirection;
        t.setTemplateItem(cc.instantiate(t.templateType == TemplateType.PREFAB ? t.tmpPrefab : t.tmpNode));
        if (t._slideMode == SlideType.ADHERING || t._slideMode == SlideType.PAGE) {
          t._scrollView.inertia = false;
          t._scrollView._onMouseWheel = function() {
            return;
          };
        }
        t.virtual || (t.lackCenter = false);
        t._lastDisplayData = [];
        t.displayData = [];
        t._pool = new cc.NodePool();
        t._forceUpdate = false;
        t._updateCounter = 0;
        t._updateDone = true;
        t.curPageNum = 0;
        if (t.cyclic || 0) {
          t._scrollView._processAutoScrolling = this._processAutoScrolling.bind(t);
          t._scrollView._startBounceBackIfNeeded = function() {
            return false;
          };
        }
        switch (t._align) {
         case cc.Layout.Type.HORIZONTAL:
          switch (t._horizontalDir) {
           case cc.Layout.HorizontalDirection.LEFT_TO_RIGHT:
            t._alignCalcType = 1;
            break;

           case cc.Layout.HorizontalDirection.RIGHT_TO_LEFT:
            t._alignCalcType = 2;
          }
          break;

         case cc.Layout.Type.VERTICAL:
          switch (t._verticalDir) {
           case cc.Layout.VerticalDirection.TOP_TO_BOTTOM:
            t._alignCalcType = 3;
            break;

           case cc.Layout.VerticalDirection.BOTTOM_TO_TOP:
            t._alignCalcType = 4;
          }
          break;

         case cc.Layout.Type.GRID:
          switch (t._startAxis) {
           case cc.Layout.AxisDirection.HORIZONTAL:
            switch (t._verticalDir) {
             case cc.Layout.VerticalDirection.TOP_TO_BOTTOM:
              t._alignCalcType = 3;
              break;

             case cc.Layout.VerticalDirection.BOTTOM_TO_TOP:
              t._alignCalcType = 4;
            }
            break;

           case cc.Layout.AxisDirection.VERTICAL:
            switch (t._horizontalDir) {
             case cc.Layout.HorizontalDirection.LEFT_TO_RIGHT:
              t._alignCalcType = 1;
              break;

             case cc.Layout.HorizontalDirection.RIGHT_TO_LEFT:
              t._alignCalcType = 2;
            }
          }
        }
        t.content.removeAllChildren();
        t._inited = true;
      }
      _processAutoScrolling(dt) {
        let brakingFactor = 1;
        this._scrollView["_autoScrollAccumulatedTime"] += dt * (1 / brakingFactor);
        let percentage = Math.min(1, this._scrollView["_autoScrollAccumulatedTime"] / this._scrollView["_autoScrollTotalTime"]);
        if (this._scrollView["_autoScrollAttenuate"]) {
          let time = percentage - 1;
          percentage = time * time * time * time * time + 1;
        }
        let newPosition = this._scrollView["_autoScrollStartPosition"].add(this._scrollView["_autoScrollTargetDelta"].mul(percentage));
        let EPSILON = this._scrollView["getScrollEndedEventTiming"]();
        let reachedEnd = Math.abs(percentage - 1) <= EPSILON;
        let fireEvent = Math.abs(percentage - 1) <= this._scrollView["getScrollEndedEventTiming"]();
        if (fireEvent && !this._scrollView["_isScrollEndedWithThresholdEventFired"]) {
          this._scrollView["_dispatchEvent"]("scroll-ended-with-threshold");
          this._scrollView["_isScrollEndedWithThresholdEventFired"] = true;
        }
        reachedEnd && (this._scrollView["_autoScrolling"] = false);
        let deltaMove = newPosition.sub(this._scrollView.getContentPosition());
        this._scrollView["_moveContent"](this._scrollView["_clampDelta"](deltaMove), reachedEnd);
        this._scrollView["_dispatchEvent"]("scrolling");
        if (!this._scrollView["_autoScrolling"]) {
          this._scrollView["_isBouncing"] = false;
          this._scrollView["_scrolling"] = false;
          this._scrollView["_dispatchEvent"]("scroll-ended");
        }
      }
      setTemplateItem(item) {
        if (!item) return;
        let t = this;
        t._itemTmp = item;
        t._resizeMode == cc.Layout.ResizeMode.CHILDREN ? t._itemSize = t._layout.cellSize : t._itemSize = cc.size(item.width, item.height);
        let com = item.getComponent(ListItem_1.default);
        let remove = false;
        com || (remove = true);
        remove && (t.selectedMode = SelectedType.NONE);
        com = item.getComponent(cc.Widget);
        com && com.enabled && (t._needUpdateWidget = true);
        t.selectedMode == SelectedType.MULT && (t.multSelected = []);
        switch (t._align) {
         case cc.Layout.Type.HORIZONTAL:
          t._colLineNum = 1;
          t._sizeType = false;
          break;

         case cc.Layout.Type.VERTICAL:
          t._colLineNum = 1;
          t._sizeType = true;
          break;

         case cc.Layout.Type.GRID:
          switch (t._startAxis) {
           case cc.Layout.AxisDirection.HORIZONTAL:
            let trimW = t.content.width - t._leftGap - t._rightGap;
            t._colLineNum = Math.floor((trimW + t._columnGap) / (t._itemSize.width + t._columnGap));
            t._sizeType = true;
            break;

           case cc.Layout.AxisDirection.VERTICAL:
            let trimH = t.content.height - t._topGap - t._bottomGap;
            t._colLineNum = Math.floor((trimH + t._lineGap) / (t._itemSize.height + t._lineGap));
            t._sizeType = false;
          }
        }
      }
      checkInited(printLog = true) {
        if (!this._inited) {
          printLog && cc.error("List initialization not completed!");
          return false;
        }
        return true;
      }
      _resizeContent() {
        let t = this;
        let result;
        switch (t._align) {
         case cc.Layout.Type.HORIZONTAL:
          if (t._customSize) {
            let fixed = t._getFixedSize(null);
            result = t._leftGap + fixed.val + t._itemSize.width * (t._numItems - fixed.count) + t._columnGap * (t._numItems - 1) + t._rightGap;
          } else result = t._leftGap + t._itemSize.width * t._numItems + t._columnGap * (t._numItems - 1) + t._rightGap;
          break;

         case cc.Layout.Type.VERTICAL:
          if (t._customSize) {
            let fixed = t._getFixedSize(null);
            result = t._topGap + fixed.val + t._itemSize.height * (t._numItems - fixed.count) + t._lineGap * (t._numItems - 1) + t._bottomGap;
          } else result = t._topGap + t._itemSize.height * t._numItems + t._lineGap * (t._numItems - 1) + t._bottomGap;
          break;

         case cc.Layout.Type.GRID:
          t.lackCenter && (t.lackCenter = false);
          switch (t._startAxis) {
           case cc.Layout.AxisDirection.HORIZONTAL:
            let lineNum = Math.ceil(t._numItems / t._colLineNum);
            result = t._topGap + t._itemSize.height * lineNum + t._lineGap * (lineNum - 1) + t._bottomGap;
            break;

           case cc.Layout.AxisDirection.VERTICAL:
            let colNum = Math.ceil(t._numItems / t._colLineNum);
            result = t._leftGap + t._itemSize.width * colNum + t._columnGap * (colNum - 1) + t._rightGap;
          }
        }
        let layout = t.content.getComponent(cc.Layout);
        layout && (layout.enabled = false);
        t._allItemSize = result;
        t._allItemSizeNoEdge = t._allItemSize - (t._sizeType ? t._topGap + t._bottomGap : t._leftGap + t._rightGap);
        if (t.cyclic) {
          let totalSize = t._sizeType ? t.node.height : t.node.width;
          t._cyclicPos1 = 0;
          totalSize -= t._cyclicPos1;
          t._cyclicNum = Math.ceil(totalSize / t._allItemSizeNoEdge) + 1;
          let spacing = t._sizeType ? t._lineGap : t._columnGap;
          t._cyclicPos2 = t._cyclicPos1 + t._allItemSizeNoEdge + spacing;
          t._cyclicAllItemSize = t._allItemSize + t._allItemSizeNoEdge * (t._cyclicNum - 1) + spacing * (t._cyclicNum - 1);
          t._cycilcAllItemSizeNoEdge = t._allItemSizeNoEdge * t._cyclicNum;
          t._cycilcAllItemSizeNoEdge += spacing * (t._cyclicNum - 1);
        }
        t._lack = !t.cyclic && t._allItemSize < (t._sizeType ? t.node.height : t.node.width);
        let slideOffset = t._lack && t.lackCenter || !t.lackSlide ? .1 : 0;
        let targetWH = t._lack ? (t._sizeType ? t.node.height : t.node.width) - slideOffset : t.cyclic ? t._cyclicAllItemSize : t._allItemSize;
        targetWH < 0 && (targetWH = 0);
        t._sizeType ? t.content.height = targetWH : t.content.width = targetWH;
      }
      _onScrolling(ev = null) {
        null == this.frameCount && (this.frameCount = this._updateRate);
        if (!this._forceUpdate && ev && "scroll-ended" != ev.type && this.frameCount > 0) {
          this.frameCount--;
          return;
        }
        this.frameCount = this._updateRate;
        if (this._aniDelRuning) return;
        if (this.cyclic) {
          let scrollPos = this.content.getPosition();
          scrollPos = this._sizeType ? scrollPos.y : scrollPos.x;
          let addVal = this._allItemSizeNoEdge + (this._sizeType ? this._lineGap : this._columnGap);
          let add = this._sizeType ? cc.v2(0, addVal) : cc.v2(addVal, 0);
          switch (this._alignCalcType) {
           case 1:
            if (scrollPos > -this._cyclicPos1) {
              this.content.x = -this._cyclicPos2;
              this._scrollView.isAutoScrolling() && (this._scrollView["_autoScrollStartPosition"] = this._scrollView["_autoScrollStartPosition"].sub(add));
            } else if (scrollPos < -this._cyclicPos2) {
              this.content.x = -this._cyclicPos1;
              this._scrollView.isAutoScrolling() && (this._scrollView["_autoScrollStartPosition"] = this._scrollView["_autoScrollStartPosition"].add(add));
            }
            break;

           case 2:
            if (scrollPos < this._cyclicPos1) {
              this.content.x = this._cyclicPos2;
              this._scrollView.isAutoScrolling() && (this._scrollView["_autoScrollStartPosition"] = this._scrollView["_autoScrollStartPosition"].add(add));
            } else if (scrollPos > this._cyclicPos2) {
              this.content.x = this._cyclicPos1;
              this._scrollView.isAutoScrolling() && (this._scrollView["_autoScrollStartPosition"] = this._scrollView["_autoScrollStartPosition"].sub(add));
            }
            break;

           case 3:
            if (scrollPos < this._cyclicPos1) {
              this.content.y = this._cyclicPos2;
              this._scrollView.isAutoScrolling() && (this._scrollView["_autoScrollStartPosition"] = this._scrollView["_autoScrollStartPosition"].add(add));
            } else if (scrollPos > this._cyclicPos2) {
              this.content.y = this._cyclicPos1;
              this._scrollView.isAutoScrolling() && (this._scrollView["_autoScrollStartPosition"] = this._scrollView["_autoScrollStartPosition"].sub(add));
            }
            break;

           case 4:
            if (scrollPos > -this._cyclicPos1) {
              this.content.y = -this._cyclicPos2;
              this._scrollView.isAutoScrolling() && (this._scrollView["_autoScrollStartPosition"] = this._scrollView["_autoScrollStartPosition"].sub(add));
            } else if (scrollPos < -this._cyclicPos2) {
              this.content.y = -this._cyclicPos1;
              this._scrollView.isAutoScrolling() && (this._scrollView["_autoScrollStartPosition"] = this._scrollView["_autoScrollStartPosition"].add(add));
            }
          }
        }
        this._calcViewPos();
        let vTop, vRight, vBottom, vLeft;
        if (this._sizeType) {
          vTop = this.viewTop;
          vBottom = this.viewBottom;
        } else {
          vRight = this.viewRight;
          vLeft = this.viewLeft;
        }
        if (this._virtual) {
          this.displayData = [];
          let itemPos;
          let curId = 0;
          let endId = this._numItems - 1;
          if (this._customSize) {
            let breakFor = false;
            for (;curId <= endId && !breakFor; curId++) {
              itemPos = this._calcItemPos(curId);
              switch (this._align) {
               case cc.Layout.Type.HORIZONTAL:
                itemPos.right >= vLeft && itemPos.left <= vRight ? this.displayData.push(itemPos) : 0 != curId && this.displayData.length > 0 && (breakFor = true);
                break;

               case cc.Layout.Type.VERTICAL:
                itemPos.bottom <= vTop && itemPos.top >= vBottom ? this.displayData.push(itemPos) : 0 != curId && this.displayData.length > 0 && (breakFor = true);
                break;

               case cc.Layout.Type.GRID:
                switch (this._startAxis) {
                 case cc.Layout.AxisDirection.HORIZONTAL:
                  itemPos.bottom <= vTop && itemPos.top >= vBottom ? this.displayData.push(itemPos) : 0 != curId && this.displayData.length > 0 && (breakFor = true);
                  break;

                 case cc.Layout.AxisDirection.VERTICAL:
                  itemPos.right >= vLeft && itemPos.left <= vRight ? this.displayData.push(itemPos) : 0 != curId && this.displayData.length > 0 && (breakFor = true);
                }
              }
            }
          } else {
            let ww = this._itemSize.width + this._columnGap;
            let hh = this._itemSize.height + this._lineGap;
            switch (this._alignCalcType) {
             case 1:
              curId = (vLeft - this._leftGap) / ww;
              endId = (vRight - this._leftGap) / ww;
              break;

             case 2:
              curId = (-vRight - this._rightGap) / ww;
              endId = (-vLeft - this._rightGap) / ww;
              break;

             case 3:
              curId = (-vTop - this._topGap) / hh;
              endId = (-vBottom - this._topGap) / hh;
              break;

             case 4:
              curId = (vBottom - this._bottomGap) / hh;
              endId = (vTop - this._bottomGap) / hh;
            }
            curId = Math.floor(curId) * this._colLineNum;
            endId = Math.ceil(endId) * this._colLineNum;
            endId--;
            curId < 0 && (curId = 0);
            endId >= this._numItems && (endId = this._numItems - 1);
            for (;curId <= endId; curId++) this.displayData.push(this._calcItemPos(curId));
          }
          this._delRedundantItem();
          if (this.displayData.length <= 0 || !this._numItems) {
            this._lastDisplayData = [];
            return;
          }
          this.firstListId = this.displayData[0].id;
          this.displayItemNum = this.displayData.length;
          let len = this._lastDisplayData.length;
          let haveDataChange = this.displayItemNum != len;
          if (haveDataChange) {
            this.frameByFrameRenderNum > 0 && this._lastDisplayData.sort((a, b) => a - b);
            haveDataChange = this.firstListId != this._lastDisplayData[0] || this.displayData[this.displayItemNum - 1].id != this._lastDisplayData[len - 1];
          }
          if (this._forceUpdate || haveDataChange) if (this.frameByFrameRenderNum > 0) if (this._numItems > 0) {
            this._updateDone ? this._updateCounter = 0 : this._doneAfterUpdate = true;
            this._updateDone = false;
          } else {
            this._updateCounter = 0;
            this._updateDone = true;
          } else {
            this._lastDisplayData = [];
            for (let c = 0; c < this.displayItemNum; c++) this._createOrUpdateItem(this.displayData[c]);
            this._forceUpdate = false;
          }
          this._calcNearestItem();
        }
      }
      _calcViewPos() {
        let scrollPos = this.content.getPosition();
        switch (this._alignCalcType) {
         case 1:
          this.elasticLeft = scrollPos.x > 0 ? scrollPos.x : 0;
          this.viewLeft = (scrollPos.x < 0 ? -scrollPos.x : 0) - this.elasticLeft;
          this.viewRight = this.viewLeft + this.node.width;
          this.elasticRight = this.viewRight > this.content.width ? Math.abs(this.viewRight - this.content.width) : 0;
          this.viewRight += this.elasticRight;
          break;

         case 2:
          this.elasticRight = scrollPos.x < 0 ? -scrollPos.x : 0;
          this.viewRight = (scrollPos.x > 0 ? -scrollPos.x : 0) + this.elasticRight;
          this.viewLeft = this.viewRight - this.node.width;
          this.elasticLeft = this.viewLeft < -this.content.width ? Math.abs(this.viewLeft + this.content.width) : 0;
          this.viewLeft -= this.elasticLeft;
          break;

         case 3:
          this.elasticTop = scrollPos.y < 0 ? Math.abs(scrollPos.y) : 0;
          this.viewTop = (scrollPos.y > 0 ? -scrollPos.y : 0) + this.elasticTop;
          this.viewBottom = this.viewTop - this.node.height;
          this.elasticBottom = this.viewBottom < -this.content.height ? Math.abs(this.viewBottom + this.content.height) : 0;
          this.viewBottom += this.elasticBottom;
          break;

         case 4:
          this.elasticBottom = scrollPos.y > 0 ? Math.abs(scrollPos.y) : 0;
          this.viewBottom = (scrollPos.y < 0 ? -scrollPos.y : 0) - this.elasticBottom;
          this.viewTop = this.viewBottom + this.node.height;
          this.elasticTop = this.viewTop > this.content.height ? Math.abs(this.viewTop - this.content.height) : 0;
          this.viewTop -= this.elasticTop;
        }
      }
      _calcItemPos(id) {
        let width, height, top, bottom, left, right, itemX, itemY;
        switch (this._align) {
         case cc.Layout.Type.HORIZONTAL:
          switch (this._horizontalDir) {
           case cc.Layout.HorizontalDirection.LEFT_TO_RIGHT:
            if (this._customSize) {
              let fixed = this._getFixedSize(id);
              left = this._leftGap + (this._itemSize.width + this._columnGap) * (id - fixed.count) + (fixed.val + this._columnGap * fixed.count);
              let cs = this._customSize[id];
              width = cs > 0 ? cs : this._itemSize.width;
            } else {
              left = this._leftGap + (this._itemSize.width + this._columnGap) * id;
              width = this._itemSize.width;
            }
            if (this.lackCenter) {
              left -= this._leftGap;
              let offset = this.content.width / 2 - this._allItemSizeNoEdge / 2;
              left += offset;
            }
            right = left + width;
            return {
              id: id,
              left: left,
              right: right,
              x: left + this._itemTmp.anchorX * width,
              y: this._itemTmp.y
            };

           case cc.Layout.HorizontalDirection.RIGHT_TO_LEFT:
            if (this._customSize) {
              let fixed = this._getFixedSize(id);
              right = -this._rightGap - (this._itemSize.width + this._columnGap) * (id - fixed.count) - (fixed.val + this._columnGap * fixed.count);
              let cs = this._customSize[id];
              width = cs > 0 ? cs : this._itemSize.width;
            } else {
              right = -this._rightGap - (this._itemSize.width + this._columnGap) * id;
              width = this._itemSize.width;
            }
            if (this.lackCenter) {
              right += this._rightGap;
              let offset = this.content.width / 2 - this._allItemSizeNoEdge / 2;
              right -= offset;
            }
            left = right - width;
            return {
              id: id,
              right: right,
              left: left,
              x: left + this._itemTmp.anchorX * width,
              y: this._itemTmp.y
            };
          }
          break;

         case cc.Layout.Type.VERTICAL:
          switch (this._verticalDir) {
           case cc.Layout.VerticalDirection.TOP_TO_BOTTOM:
            if (this._customSize) {
              let fixed = this._getFixedSize(id);
              top = -this._topGap - (this._itemSize.height + this._lineGap) * (id - fixed.count) - (fixed.val + this._lineGap * fixed.count);
              let cs = this._customSize[id];
              height = cs > 0 ? cs : this._itemSize.height;
            } else {
              top = -this._topGap - (this._itemSize.height + this._lineGap) * id;
              height = this._itemSize.height;
            }
            if (this.lackCenter) {
              top += this._topGap;
              let offset = this.content.height / 2 - this._allItemSizeNoEdge / 2;
              top -= offset;
            }
            bottom = top - height;
            return {
              id: id,
              top: top,
              bottom: bottom,
              x: this._itemTmp.x,
              y: bottom + this._itemTmp.anchorY * height
            };

           case cc.Layout.VerticalDirection.BOTTOM_TO_TOP:
            if (this._customSize) {
              let fixed = this._getFixedSize(id);
              bottom = this._bottomGap + (this._itemSize.height + this._lineGap) * (id - fixed.count) + (fixed.val + this._lineGap * fixed.count);
              let cs = this._customSize[id];
              height = cs > 0 ? cs : this._itemSize.height;
            } else {
              bottom = this._bottomGap + (this._itemSize.height + this._lineGap) * id;
              height = this._itemSize.height;
            }
            if (this.lackCenter) {
              bottom -= this._bottomGap;
              let offset = this.content.height / 2 - this._allItemSizeNoEdge / 2;
              bottom += offset;
            }
            top = bottom + height;
            return {
              id: id,
              top: top,
              bottom: bottom,
              x: this._itemTmp.x,
              y: bottom + this._itemTmp.anchorY * height
            };
          }

         case cc.Layout.Type.GRID:
          {
            let colLine = Math.floor(id / this._colLineNum);
            switch (this._startAxis) {
             case cc.Layout.AxisDirection.HORIZONTAL:
              switch (this._verticalDir) {
               case cc.Layout.VerticalDirection.TOP_TO_BOTTOM:
                top = -this._topGap - (this._itemSize.height + this._lineGap) * colLine;
                bottom = top - this._itemSize.height;
                itemY = bottom + this._itemTmp.anchorY * this._itemSize.height;
                break;

               case cc.Layout.VerticalDirection.BOTTOM_TO_TOP:
                bottom = this._bottomGap + (this._itemSize.height + this._lineGap) * colLine;
                top = bottom + this._itemSize.height;
                itemY = bottom + this._itemTmp.anchorY * this._itemSize.height;
              }
              itemX = this._leftGap + id % this._colLineNum * (this._itemSize.width + this._columnGap);
              switch (this._horizontalDir) {
               case cc.Layout.HorizontalDirection.LEFT_TO_RIGHT:
                itemX += this._itemTmp.anchorX * this._itemSize.width;
                itemX -= this.content.anchorX * this.content.width;
                break;

               case cc.Layout.HorizontalDirection.RIGHT_TO_LEFT:
                itemX += (1 - this._itemTmp.anchorX) * this._itemSize.width;
                itemX -= (1 - this.content.anchorX) * this.content.width;
                itemX *= -1;
              }
              return {
                id: id,
                top: top,
                bottom: bottom,
                x: itemX,
                y: itemY
              };

             case cc.Layout.AxisDirection.VERTICAL:
              switch (this._horizontalDir) {
               case cc.Layout.HorizontalDirection.LEFT_TO_RIGHT:
                left = this._leftGap + (this._itemSize.width + this._columnGap) * colLine;
                right = left + this._itemSize.width;
                itemX = left + this._itemTmp.anchorX * this._itemSize.width;
                itemX -= this.content.anchorX * this.content.width;
                break;

               case cc.Layout.HorizontalDirection.RIGHT_TO_LEFT:
                right = -this._rightGap - (this._itemSize.width + this._columnGap) * colLine;
                left = right - this._itemSize.width;
                itemX = left + this._itemTmp.anchorX * this._itemSize.width;
                itemX += (1 - this.content.anchorX) * this.content.width;
              }
              itemY = -this._topGap - id % this._colLineNum * (this._itemSize.height + this._lineGap);
              switch (this._verticalDir) {
               case cc.Layout.VerticalDirection.TOP_TO_BOTTOM:
                itemY -= (1 - this._itemTmp.anchorY) * this._itemSize.height;
                itemY += (1 - this.content.anchorY) * this.content.height;
                break;

               case cc.Layout.VerticalDirection.BOTTOM_TO_TOP:
                itemY -= this._itemTmp.anchorY * this._itemSize.height;
                itemY += this.content.anchorY * this.content.height;
                itemY *= -1;
              }
              return {
                id: id,
                left: left,
                right: right,
                x: itemX,
                y: itemY
              };
            }
            break;
          }
        }
      }
      _calcExistItemPos(id) {
        let item = this.getItemByListId(id);
        if (!item) return null;
        let data = {
          id: id,
          x: item.x,
          y: item.y
        };
        if (this._sizeType) {
          data.top = item.y + item.height * (1 - item.anchorY);
          data.bottom = item.y - item.height * item.anchorY;
        } else {
          data.left = item.x - item.width * item.anchorX;
          data.right = item.x + item.width * (1 - item.anchorX);
        }
        return data;
      }
      getItemPos(id) {
        return this._virtual ? this._calcItemPos(id) : this.frameByFrameRenderNum ? this._calcItemPos(id) : this._calcExistItemPos(id);
      }
      _getFixedSize(listId) {
        if (!this._customSize) return null;
        null == listId && (listId = this._numItems);
        let fixed = 0;
        let count = 0;
        for (let id in this._customSize) if (parseInt(id) < listId) {
          fixed += this._customSize[id];
          count++;
        }
        return {
          val: fixed,
          count: count
        };
      }
      _onScrollBegan() {
        this._beganPos = this._sizeType ? this.viewTop : this.viewLeft;
      }
      _onScrollEnded() {
        let t = this;
        t.curScrollIsTouch = false;
        if (null != t.scrollToListId) {
          let item = t.getItemByListId(t.scrollToListId);
          t.scrollToListId = null;
          item && cc.tween(item).to(.1, {
            scale: 1.06
          }).to(.1, {
            scale: 1
          }).start();
        }
        t._onScrolling();
        t._slideMode != SlideType.ADHERING || t.adhering ? t._slideMode == SlideType.PAGE && (null != t._beganPos && t.curScrollIsTouch ? this._pageAdhere() : t.adhere()) : t.adhere();
      }
      _onTouchStart(ev, captureListeners) {
        if (this._scrollView["hasNestedViewGroup"](ev, captureListeners)) return;
        this.curScrollIsTouch = true;
        let isMe = ev.eventPhase === cc.Event.AT_TARGET && ev.target === this.node;
        if (!isMe) {
          let itemNode = ev.target;
          while (null == itemNode._listId && itemNode.parent) itemNode = itemNode.parent;
          this._scrollItem = null != itemNode._listId ? itemNode : ev.target;
        }
      }
      _onTouchUp() {
        let t = this;
        t._scrollPos = null;
        if (t._slideMode == SlideType.ADHERING) {
          this.adhering && (this._adheringBarrier = true);
          t.adhere();
        } else t._slideMode == SlideType.PAGE && (null != t._beganPos ? this._pageAdhere() : t.adhere());
        this._scrollItem = null;
      }
      _onTouchCancelled(ev, captureListeners) {
        let t = this;
        if (t._scrollView["hasNestedViewGroup"](ev, captureListeners) || ev.simulate) return;
        t._scrollPos = null;
        if (t._slideMode == SlideType.ADHERING) {
          t.adhering && (t._adheringBarrier = true);
          t.adhere();
        } else t._slideMode == SlideType.PAGE && (null != t._beganPos ? t._pageAdhere() : t.adhere());
        this._scrollItem = null;
      }
      _onSizeChanged() {
        this.checkInited(false) && this._onScrolling();
      }
      _onItemAdaptive(item) {
        if (!this._sizeType && item.width != this._itemSize.width || this._sizeType && item.height != this._itemSize.height) {
          this._customSize || (this._customSize = {});
          let val = this._sizeType ? item.height : item.width;
          if (this._customSize[item._listId] != val) {
            this._customSize[item._listId] = val;
            this._resizeContent();
            this.updateAll();
            if (null != this._scrollToListId) {
              this._scrollPos = null;
              this.unschedule(this._scrollToSo);
              this.scrollTo(this._scrollToListId, Math.max(0, this._scrollToEndTime - new Date().getTime() / 1e3));
            }
          }
        }
      }
      _pageAdhere() {
        let t = this;
        if (!t.cyclic && (t.elasticTop > 0 || t.elasticRight > 0 || t.elasticBottom > 0 || t.elasticLeft > 0)) return;
        let curPos = t._sizeType ? t.viewTop : t.viewLeft;
        let dis = (t._sizeType ? t.node.height : t.node.width) * t.pageDistance;
        let canSkip = Math.abs(t._beganPos - curPos) > dis;
        if (canSkip) {
          let timeInSecond = .5;
          switch (t._alignCalcType) {
           case 1:
           case 4:
            t._beganPos > curPos ? t.prePage(timeInSecond) : t.nextPage(timeInSecond);
            break;

           case 2:
           case 3:
            t._beganPos < curPos ? t.prePage(timeInSecond) : t.nextPage(timeInSecond);
          }
        } else t.elasticTop <= 0 && t.elasticRight <= 0 && t.elasticBottom <= 0 && t.elasticLeft <= 0 && t.adhere();
        t._beganPos = null;
      }
      adhere() {
        let t = this;
        if (!t.checkInited()) return;
        if (t.elasticTop > 0 || t.elasticRight > 0 || t.elasticBottom > 0 || t.elasticLeft > 0) return;
        t.adhering = true;
        t._calcNearestItem();
        let offset = (t._sizeType ? t._topGap : t._leftGap) / (t._sizeType ? t.node.height : t.node.width);
        let timeInSecond = .7;
        t.scrollTo(t.nearestListId, timeInSecond, offset);
      }
      update() {
        if (this.frameByFrameRenderNum <= 0 || this._updateDone) return;
        if (this._virtual) {
          let len = this._updateCounter + this.frameByFrameRenderNum > this.displayItemNum ? this.displayItemNum : this._updateCounter + this.frameByFrameRenderNum;
          for (let n = this._updateCounter; n < len; n++) {
            let data = this.displayData[n];
            data && this._createOrUpdateItem(data);
          }
          if (this._updateCounter >= this.displayItemNum - 1) if (this._doneAfterUpdate) {
            this._updateCounter = 0;
            this._updateDone = false;
            this._doneAfterUpdate = false;
          } else {
            this._updateDone = true;
            this._delRedundantItem();
            this._forceUpdate = false;
            this._calcNearestItem();
            this.slideMode == SlideType.PAGE && (this.curPageNum = this.nearestListId);
          } else this._updateCounter += this.frameByFrameRenderNum;
        } else if (this._updateCounter < this._numItems) {
          let len = this._updateCounter + this.frameByFrameRenderNum > this._numItems ? this._numItems : this._updateCounter + this.frameByFrameRenderNum;
          for (let n = this._updateCounter; n < len; n++) this._createOrUpdateItem2(n);
          this._updateCounter += this.frameByFrameRenderNum;
        } else {
          this._updateDone = true;
          this._calcNearestItem();
          this.slideMode == SlideType.PAGE && (this.curPageNum = this.nearestListId);
        }
      }
      _createOrUpdateItem(data) {
        let item = this.getItemByListId(data.id);
        if (item) {
          if (this._forceUpdate && this.renderEvent) {
            item.setPosition(cc.v2(data.x, data.y));
            this._resetItemSize(item);
            this.renderEvent && cc.Component.EventHandler.emitEvents([ this.renderEvent ], item, data.id % this._actualNumItems);
          }
        } else {
          let canGet = this._pool.size() > 0;
          item = canGet ? this._pool.get() : cc.instantiate(this._itemTmp);
          if (!canGet || !cc.isValid(item)) {
            item = cc.instantiate(this._itemTmp);
            canGet = false;
          }
          if (item._listId != data.id) {
            item._listId = data.id;
            item.setContentSize(this._itemSize);
          }
          item.setPosition(cc.v2(data.x, data.y));
          this._resetItemSize(item);
          this.content.addChild(item);
          if (canGet && this._needUpdateWidget) {
            let widget = item.getComponent(cc.Widget);
            widget && widget.updateAlignment();
          }
          item.setSiblingIndex(this.content.childrenCount - 1);
          let listItem = item.getComponent(ListItem_1.default);
          item["listItem"] = listItem;
          if (listItem) {
            listItem.listId = data.id;
            listItem.list = this;
            listItem._registerEvent();
          }
          this.renderEvent && cc.Component.EventHandler.emitEvents([ this.renderEvent ], item, data.id % this._actualNumItems);
        }
        this._resetItemSize(item);
        this._updateListItem(item["listItem"]);
        this._lastDisplayData.indexOf(data.id) < 0 && this._lastDisplayData.push(data.id);
      }
      _createOrUpdateItem2(listId) {
        let item = this.content.children[listId];
        let listItem;
        if (item) {
          if (this._forceUpdate && this.renderEvent) {
            item._listId = listId;
            listItem && (listItem.listId = listId);
            this.renderEvent && cc.Component.EventHandler.emitEvents([ this.renderEvent ], item, listId % this._actualNumItems);
          }
        } else {
          item = cc.instantiate(this._itemTmp);
          item._listId = listId;
          this.content.addChild(item);
          listItem = item.getComponent(ListItem_1.default);
          item["listItem"] = listItem;
          if (listItem) {
            listItem.listId = listId;
            listItem.list = this;
            listItem._registerEvent();
          }
          this.renderEvent && cc.Component.EventHandler.emitEvents([ this.renderEvent ], item, listId % this._actualNumItems);
        }
        this._updateListItem(listItem);
        this._lastDisplayData.indexOf(listId) < 0 && this._lastDisplayData.push(listId);
      }
      _updateListItem(listItem) {
        if (!listItem) return;
        if (this.selectedMode > SelectedType.NONE) {
          let item = listItem.node;
          switch (this.selectedMode) {
           case SelectedType.SINGLE:
            listItem.selected = this.selectedId == item._listId;
            break;

           case SelectedType.MULT:
            listItem.selected = this.multSelected.indexOf(item._listId) >= 0;
          }
        }
      }
      _resetItemSize(item) {
        return;
      }
      _updateItemPos(listIdOrItem) {
        let item = isNaN(listIdOrItem) ? listIdOrItem : this.getItemByListId(listIdOrItem);
        let pos = this.getItemPos(item._listId);
        item.setPosition(pos.x, pos.y);
      }
      setMultSelected(args, bool) {
        let t = this;
        if (!t.checkInited()) return;
        Array.isArray(args) || (args = [ args ]);
        if (null == bool) t.multSelected = args; else {
          let listId, sub;
          if (bool) for (let n = args.length - 1; n >= 0; n--) {
            listId = args[n];
            sub = t.multSelected.indexOf(listId);
            sub < 0 && t.multSelected.push(listId);
          } else for (let n = args.length - 1; n >= 0; n--) {
            listId = args[n];
            sub = t.multSelected.indexOf(listId);
            sub >= 0 && t.multSelected.splice(sub, 1);
          }
        }
        t._forceUpdate = true;
        t._onScrolling();
      }
      getMultSelected() {
        return this.multSelected;
      }
      hasMultSelected(listId) {
        return this.multSelected && this.multSelected.indexOf(listId) >= 0;
      }
      updateItem(args) {
        if (!this.checkInited()) return;
        Array.isArray(args) || (args = [ args ]);
        for (let n = 0, len = args.length; n < len; n++) {
          let listId = args[n];
          let item = this.getItemByListId(listId);
          item && cc.Component.EventHandler.emitEvents([ this.renderEvent ], item, listId % this._actualNumItems);
        }
      }
      updateAll() {
        if (!this.checkInited()) return;
        this.numItems = this.numItems;
      }
      getItemByListId(listId) {
        if (this.content) for (let n = this.content.childrenCount - 1; n >= 0; n--) {
          let item = this.content.children[n];
          if (item._listId == listId) return item;
        }
      }
      _getOutsideItem() {
        let item;
        let result = [];
        for (let n = this.content.childrenCount - 1; n >= 0; n--) {
          item = this.content.children[n];
          this.displayData.find(d => d.id == item._listId) || result.push(item);
        }
        return result;
      }
      _delRedundantItem() {
        if (this._virtual) {
          let arr = this._getOutsideItem();
          for (let n = arr.length - 1; n >= 0; n--) {
            let item = arr[n];
            if (this._scrollItem && item._listId == this._scrollItem._listId) continue;
            item.isCached = true;
            this._pool.put(item);
            for (let m = this._lastDisplayData.length - 1; m >= 0; m--) if (this._lastDisplayData[m] == item._listId) {
              this._lastDisplayData.splice(m, 1);
              break;
            }
          }
        } else while (this.content.childrenCount > this._numItems) this._delSingleItem(this.content.children[this.content.childrenCount - 1]);
      }
      _delSingleItem(item) {
        item.removeFromParent();
        item.destroy && item.destroy();
        item = null;
      }
      aniDelItem(listId, callFunc, aniType) {
        let t = this;
        if (!t.checkInited() || t.cyclic || !t._virtual) return cc.error("This function is not allowed to be called!");
        if (!callFunc) return cc.error("CallFunc are not allowed to be NULL, You need to delete the corresponding index in the data array in the CallFunc!");
        if (t._aniDelRuning) return cc.warn("Please wait for the current deletion to finish!");
        let item = t.getItemByListId(listId);
        let listItem;
        if (!item) {
          callFunc(listId);
          return;
        }
        listItem = item.getComponent(ListItem_1.default);
        t._aniDelRuning = true;
        t._aniDelCB = callFunc;
        t._aniDelItem = item;
        t._aniDelBeforePos = item.position;
        t._aniDelBeforeScale = item.scale;
        let curLastId = t.displayData[t.displayData.length - 1].id;
        let resetSelectedId = listItem.selected;
        listItem.showAni(aniType, () => {
          let newId;
          curLastId < t._numItems - 2 && (newId = curLastId + 1);
          if (null != newId) {
            let newData = t._calcItemPos(newId);
            t.displayData.push(newData);
            t._virtual ? t._createOrUpdateItem(newData) : t._createOrUpdateItem2(newId);
          } else t._numItems--;
          if (t.selectedMode == SelectedType.SINGLE) resetSelectedId ? t._selectedId = -1 : t._selectedId - 1 >= 0 && t._selectedId--; else if (t.selectedMode == SelectedType.MULT && t.multSelected.length) {
            let sub = t.multSelected.indexOf(listId);
            sub >= 0 && t.multSelected.splice(sub, 1);
            for (let n = t.multSelected.length - 1; n >= 0; n--) {
              let id = t.multSelected[n];
              id >= listId && t.multSelected[n]--;
            }
          }
          if (t._customSize) {
            t._customSize[listId] && delete t._customSize[listId];
            let newCustomSize = {};
            let size;
            for (let id in t._customSize) {
              size = t._customSize[id];
              let idNumber = parseInt(id);
              newCustomSize[idNumber - (idNumber >= listId ? 1 : 0)] = size;
            }
            t._customSize = newCustomSize;
          }
          let sec = .2333;
          let tween, haveCB;
          for (let n = null != newId ? newId : curLastId; n >= listId + 1; n--) {
            item = t.getItemByListId(n);
            if (item) {
              let posData = t._calcItemPos(n - 1);
              tween = cc.tween(item).to(sec, {
                position: cc.v2(posData.x, posData.y)
              });
              if (n <= listId + 1) {
                haveCB = true;
                tween.call(() => {
                  t._aniDelRuning = false;
                  callFunc(listId);
                  delete t._aniDelCB;
                });
              }
              tween.start();
            }
          }
          if (!haveCB) {
            t._aniDelRuning = false;
            callFunc(listId);
            t._aniDelCB = null;
          }
        }, true);
      }
      scrollTo(listId, timeInSecond = .5, offset = null, overStress = false) {
        let t = this;
        if (!t.checkInited(false)) return;
        null == timeInSecond ? timeInSecond = .5 : timeInSecond < 0 && (timeInSecond = 0);
        listId < 0 ? listId = 0 : listId >= t._numItems && (listId = t._numItems - 1);
        !t._virtual && t._layout && t._layout.enabled && t._layout.updateLayout();
        let pos = t.getItemPos(listId);
        if (!pos) return false;
        let targetX, targetY;
        switch (t._alignCalcType) {
         case 1:
          targetX = pos.left;
          targetX -= null != offset ? t.node.width * offset : t._leftGap;
          pos = cc.v2(targetX, 0);
          break;

         case 2:
          targetX = pos.right - t.node.width;
          targetX += null != offset ? t.node.width * offset : t._rightGap;
          pos = cc.v2(targetX + t.content.width, 0);
          break;

         case 3:
          targetY = pos.top;
          targetY += null != offset ? t.node.height * offset : t._topGap;
          pos = cc.v2(0, -targetY);
          break;

         case 4:
          targetY = pos.bottom + t.node.height;
          targetY -= null != offset ? t.node.height * offset : t._bottomGap;
          pos = cc.v2(0, -targetY + t.content.height);
        }
        let viewPos = t.content.getPosition();
        viewPos = Math.abs(t._sizeType ? viewPos.y : viewPos.x);
        let comparePos = t._sizeType ? pos.y : pos.x;
        let runScroll = Math.abs((null != t._scrollPos ? t._scrollPos : viewPos) - comparePos) > .5;
        if (runScroll) {
          t._scrollView.scrollToOffset(pos, timeInSecond);
          t._scrollToListId = listId;
          t._scrollToEndTime = new Date().getTime() / 1e3 + timeInSecond;
          t._scrollToSo = t.scheduleOnce(() => {
            t._adheringBarrier || (t.adhering = t._adheringBarrier = false);
            t._scrollPos = t._scrollToListId = t._scrollToEndTime = t._scrollToSo = null;
            if (overStress) {
              let item = t.getItemByListId(listId);
              item && cc.tween(item).to(.1, {
                scale: 1.05
              }).to(.1, {
                scale: 1
              }).start();
            }
          }, timeInSecond + .1);
          timeInSecond <= 0 && t._onScrolling();
        }
      }
      _calcNearestItem() {
        let t = this;
        t.nearestListId = null;
        let data, center;
        t._virtual && t._calcViewPos();
        let vTop, vRight, vBottom, vLeft;
        vTop = t.viewTop;
        vRight = t.viewRight;
        vBottom = t.viewBottom;
        vLeft = t.viewLeft;
        let breakFor = false;
        for (let n = 0; n < t.content.childrenCount && !breakFor; n += t._colLineNum) {
          data = t._virtual ? t.displayData[n] : t._calcExistItemPos(n);
          if (data) {
            center = t._sizeType ? (data.top + data.bottom) / 2 : center = (data.left + data.right) / 2;
            switch (t._alignCalcType) {
             case 1:
              if (data.right >= vLeft) {
                t.nearestListId = data.id;
                vLeft > center && (t.nearestListId += t._colLineNum);
                breakFor = true;
              }
              break;

             case 2:
              if (data.left <= vRight) {
                t.nearestListId = data.id;
                vRight < center && (t.nearestListId += t._colLineNum);
                breakFor = true;
              }
              break;

             case 3:
              if (data.bottom <= vTop) {
                t.nearestListId = data.id;
                vTop < center && (t.nearestListId += t._colLineNum);
                breakFor = true;
              }
              break;

             case 4:
              if (data.top >= vBottom) {
                t.nearestListId = data.id;
                vBottom > center && (t.nearestListId += t._colLineNum);
                breakFor = true;
              }
            }
          }
        }
        data = t._virtual ? t.displayData[t.displayItemNum - 1] : t._calcExistItemPos(t._numItems - 1);
        if (data && data.id == t._numItems - 1) {
          center = t._sizeType ? (data.top + data.bottom) / 2 : center = (data.left + data.right) / 2;
          switch (t._alignCalcType) {
           case 1:
            vRight > center && (t.nearestListId = data.id);
            break;

           case 2:
            vLeft < center && (t.nearestListId = data.id);
            break;

           case 3:
            vBottom < center && (t.nearestListId = data.id);
            break;

           case 4:
            vTop > center && (t.nearestListId = data.id);
          }
        }
      }
      prePage(timeInSecond = .5) {
        if (!this.checkInited()) return;
        this.skipPage(this.curPageNum - 1, timeInSecond);
      }
      nextPage(timeInSecond = .5) {
        if (!this.checkInited()) return;
        this.skipPage(this.curPageNum + 1, timeInSecond);
      }
      skipPage(pageNum, timeInSecond) {
        let t = this;
        if (!t.checkInited()) return;
        if (t._slideMode != SlideType.PAGE) return cc.error("This function is not allowed to be called, Must SlideMode = PAGE!");
        if (pageNum < 0 || pageNum >= t._numItems) return;
        if (t.curPageNum == pageNum) return;
        t.curPageNum = pageNum;
        t.pageChangeEvent && cc.Component.EventHandler.emitEvents([ t.pageChangeEvent ], pageNum);
        t.scrollTo(pageNum, timeInSecond);
      }
      calcCustomSize(numItems) {
        let t = this;
        if (!t.checkInited()) return;
        if (!t._itemTmp) return cc.error("Unset template item!");
        if (!t.renderEvent) return cc.error("Unset Render-Event!");
        t._customSize = {};
        let temp = cc.instantiate(t._itemTmp);
        t.content.addChild(temp);
        for (let n = 0; n < numItems; n++) {
          cc.Component.EventHandler.emitEvents([ t.renderEvent ], temp, n);
          temp.height == t._itemSize.height && temp.width == t._itemSize.width || (t._customSize[n] = t._sizeType ? temp.height : temp.width);
        }
        Object.keys(t._customSize).length || (t._customSize = null);
        temp.removeFromParent();
        temp.destroy && temp.destroy();
        return t._customSize;
      }
    };
    __decorate([ property({
      type: cc.Enum(TemplateType),
      tooltip: false
    }) ], List.prototype, "templateType", void 0);
    __decorate([ property({
      type: cc.Node,
      tooltip: false,
      visible() {
        return this.templateType == TemplateType.NODE;
      }
    }) ], List.prototype, "tmpNode", void 0);
    __decorate([ property({
      type: cc.Prefab,
      tooltip: false,
      visible() {
        return this.templateType == TemplateType.PREFAB;
      }
    }) ], List.prototype, "tmpPrefab", void 0);
    __decorate([ property() ], List.prototype, "_slideMode", void 0);
    __decorate([ property({
      type: cc.Enum(SlideType),
      tooltip: false
    }) ], List.prototype, "slideMode", null);
    __decorate([ property({
      type: cc.Float,
      range: [ 0, 1, .1 ],
      tooltip: false,
      slide: true,
      visible() {
        return this._slideMode == SlideType.PAGE;
      }
    }) ], List.prototype, "pageDistance", void 0);
    __decorate([ property({
      type: cc.Component.EventHandler,
      tooltip: false,
      visible() {
        return this._slideMode == SlideType.PAGE;
      }
    }) ], List.prototype, "pageChangeEvent", void 0);
    __decorate([ property() ], List.prototype, "_virtual", void 0);
    __decorate([ property({
      type: cc.Boolean,
      tooltip: false
    }) ], List.prototype, "virtual", null);
    __decorate([ property({
      tooltip: false,
      visible() {
        let val = this.slideMode == SlideType.NORMAL;
        val || (this.cyclic = false);
        return val;
      }
    }) ], List.prototype, "cyclic", void 0);
    __decorate([ property({
      tooltip: false,
      visible() {
        return this.virtual;
      }
    }) ], List.prototype, "lackCenter", void 0);
    __decorate([ property({
      tooltip: false,
      visible() {
        let val = this.virtual && !this.lackCenter;
        val || (this.lackSlide = false);
        return val;
      }
    }) ], List.prototype, "lackSlide", void 0);
    __decorate([ property({
      type: cc.Integer
    }) ], List.prototype, "_updateRate", void 0);
    __decorate([ property({
      type: cc.Integer,
      range: [ 0, 6, 1 ],
      tooltip: false,
      slide: true
    }) ], List.prototype, "updateRate", null);
    __decorate([ property({
      type: cc.Integer,
      range: [ 0, 12, 1 ],
      tooltip: false,
      slide: true
    }) ], List.prototype, "frameByFrameRenderNum", void 0);
    __decorate([ property({
      type: cc.Component.EventHandler,
      tooltip: false
    }) ], List.prototype, "renderEvent", void 0);
    __decorate([ property({
      type: cc.Enum(SelectedType),
      tooltip: false
    }) ], List.prototype, "selectedMode", void 0);
    __decorate([ property({
      tooltip: false,
      visible() {
        return this.selectedMode == SelectedType.SINGLE;
      }
    }) ], List.prototype, "repeatEventSingle", void 0);
    __decorate([ property({
      type: cc.Component.EventHandler,
      tooltip: false,
      visible() {
        return this.selectedMode > SelectedType.NONE;
      }
    }) ], List.prototype, "selectedEvent", void 0);
    __decorate([ property({
      serializable: false
    }) ], List.prototype, "_numItems", void 0);
    List = __decorate([ ccclass, disallowMultiple(), menu("\u81ea\u5b9a\u4e49\u7ec4\u4ef6/List"), requireComponent(cc.ScrollView), executionOrder(-5e3) ], List);
    exports.default = List;
    cc._RF.pop();
  }, {
    "./ListItem": "ListItem"
  } ],
  Logger: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "94e643std9EZ7Aq3phxk5YY", "Logger");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Logger = exports.LogType = void 0;
    var LogType;
    (function(LogType) {
      LogType[LogType["Net"] = 1] = "Net";
      LogType[LogType["Model"] = 2] = "Model";
      LogType[LogType["Business"] = 4] = "Business";
      LogType[LogType["View"] = 8] = "View";
      LogType[LogType["Config"] = 16] = "Config";
      LogType[LogType["Trace"] = 32] = "Trace";
    })(LogType = exports.LogType || (exports.LogType = {}));
    var names = {
      1: "\u7f51\u7edc\u65e5\u5fd7",
      2: "\u6570\u636e\u65e5\u5fd7",
      4: "\u4e1a\u52a1\u65e5\u5fd7",
      8: "\u89c6\u56fe\u65e5\u5fd7",
      16: "\u914d\u7f6e\u65e5\u5fd7",
      32: "\u6807\u51c6\u65e5\u5fd7"
    };
    var Logger = function() {
      function Logger() {}
      Logger.init = function() {
        this.tags = LogType.Net | LogType.Model | LogType.Business | LogType.View | LogType.Config | LogType.Trace;
      };
      Logger.setTags = function(tag) {
        void 0 === tag && (tag = null);
        tag && (this.tags = tag);
      };
      Logger.start = function(describe) {
        void 0 === describe && (describe = "Time");
        console.time(describe);
      };
      Logger.end = function(describe) {
        void 0 === describe && (describe = "Time");
        console.timeEnd(describe);
      };
      Logger.table = function(msg, describe) {
        if (!this.isOpen(LogType.Trace)) return;
        console.table(msg);
      };
      Logger.trace = function(msg, color) {
        void 0 === color && (color = "color:#ffffff;");
        if (!this.isOpen(LogType.Trace)) return;
        var backLog = console.log || cc.log;
        backLog.call(null, "%c%s%s", color, this.getDateString(), msg);
      };
      Logger.logNet = function(msg, describe) {
        this.orange(LogType.Net, msg, describe);
      };
      Logger.logModel = function(msg, describe) {
        this.violet(LogType.Model, msg, describe);
      };
      Logger.logBusiness = function(msg, describe) {
        this.blue(LogType.Business, msg, describe);
      };
      Logger.logView = function(msg, describe) {
        this.green(LogType.View, msg, describe);
      };
      Logger.logConfig = function(msg, describe) {
        this.gray(LogType.Config, msg, describe);
      };
      Logger.orange = function(tag, msg, describe) {
        this.print(tag, msg, "color:#ee7700;", describe);
      };
      Logger.violet = function(tag, msg, describe) {
        this.print(tag, msg, "color:Violet;", describe);
      };
      Logger.blue = function(tag, msg, describe) {
        this.print(tag, msg, "color:#3a5fcd;", describe);
      };
      Logger.green = function(tag, msg, describe) {
        this.print(tag, msg, "color:green;", describe);
      };
      Logger.gray = function(tag, msg, describe) {
        this.print(tag, msg, "color:gray;", describe);
      };
      Logger.isOpen = function(tag) {
        return 0 != (this.tags & tag);
      };
      Logger.print = function(tag, msg, color, describe) {
        if (!this.isOpen(tag)) return;
        var backLog = console.log || cc.log;
        var type = names[tag];
        describe ? backLog.call(null, "%c%s%s%s:%s%o", color, this.getDateString(), "[" + type + "]", this.stack(5), describe, msg) : backLog.call(null, "%c%s%s%s:%o", color, this.getDateString(), "[" + type + "]", this.stack(5), msg);
      };
      Logger.stack = function(index) {
        var e = new Error();
        var lines = e.stack.split("\n");
        var result = [];
        lines.forEach(function(line) {
          var _a;
          line = line.substring(7);
          var lineBreak = line.split(" ");
          lineBreak.length < 2 ? result.push(lineBreak[0]) : result.push((_a = {}, _a[lineBreak[0]] = lineBreak[1], 
          _a));
        });
        var list = [];
        var splitList = [];
        if (index < result.length - 1) {
          var value;
          for (var a in result[index]) {
            var splitList = a.split(".");
            if (2 == splitList.length) list = splitList.concat(); else {
              value = result[index][a];
              var start = value.lastIndexOf("/");
              var end = value.lastIndexOf(".");
              if (start > -1 && end > -1) {
                var r = value.substring(start + 1, end);
                list.push(r);
              } else list.push(value);
            }
          }
        }
        if (1 == list.length) return "[" + list[0] + ".ts]";
        if (2 == list.length) return "[" + list[0] + ".ts->" + list[1] + "]";
        return "";
      };
      Logger.getDateString = function() {
        var d = new Date();
        var str = d.getHours().toString();
        var timeStr = "";
        timeStr += (1 == str.length ? "0" + str : str) + ":";
        str = d.getMinutes().toString();
        timeStr += (1 == str.length ? "0" + str : str) + ":";
        str = d.getSeconds().toString();
        timeStr += (1 == str.length ? "0" + str : str) + ":";
        str = d.getMilliseconds().toString();
        1 == str.length && (str = "00" + str);
        2 == str.length && (str = "0" + str);
        timeStr += str;
        timeStr = "[" + timeStr + "]";
        return timeStr;
      };
      Logger.tags = 0;
      return Logger;
    }();
    exports.Logger = Logger;
    Logger.init();
    cc._RF.pop();
  }, {} ],
  Main: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "e1b90/rohdEk4SdmmEZANaD", "Main");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const PropController_1 = require("./Common/Components/PropController");
    const UIHome_1 = require("./UIScript/UIHome");
    const {ccclass: ccclass, property: property} = cc._decorator;
    let Main = class Main extends cc.Component {
      constructor() {
        super(...arguments);
        this.building = null;
      }
      onLoad() {}
      start() {
        UIHome_1.default.open();
      }
      onDestroy() {}
    };
    __decorate([ property(PropController_1.default) ], Main.prototype, "building", void 0);
    Main = __decorate([ ccclass ], Main);
    exports.default = Main;
    cc._RF.pop();
  }, {
    "./Common/Components/PropController": "PropController",
    "./UIScript/UIHome": "UIHome"
  } ],
  MaskPlus: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "a1aa9cyaadEZ67qCIT1FuzO", "MaskPlus");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MaskPlusType = void 0;
    var CommonUtils_1 = require("../Utils/CommonUtils");
    var MaskPlusType;
    (function(MaskPlusType) {
      MaskPlusType[MaskPlusType["RECT"] = 0] = "RECT";
      MaskPlusType[MaskPlusType["ELLIPSE"] = 1] = "ELLIPSE";
      MaskPlusType[MaskPlusType["IMAGE_STENCIL"] = 2] = "IMAGE_STENCIL";
      MaskPlusType[MaskPlusType["Polygon"] = 3] = "Polygon";
    })(MaskPlusType = exports.MaskPlusType || (exports.MaskPlusType = {}));
    var _vec2_temp = new cc.Vec2();
    var _mat4_temp = new cc.Mat4();
    var _circlepoints = [];
    function _calculateCircle(center, radius, segements) {
      _circlepoints.length = 0;
      var anglePerStep = 2 * Math.PI / segements;
      for (var step = 0; step < segements; ++step) _circlepoints.push(cc.v2(radius.x * Math.cos(anglePerStep * step) + center.x, radius.y * Math.sin(anglePerStep * step) + center.y));
      return _circlepoints;
    }
    var EllipseConfig = function() {
      function EllipseConfig() {}
      return EllipseConfig;
    }();
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, executeInEditMode = _a.executeInEditMode, menu = _a.menu, help = _a.help, inspector = _a.inspector;
    var MaskPlus = function(_super) {
      __extends(MaskPlus, _super);
      function MaskPlus() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this._type = 0;
        _this._polygon = [];
        _this.ellipse = new EllipseConfig();
        return _this;
      }
      Object.defineProperty(MaskPlus.prototype, "type", {
        get: function() {
          return this._type;
        },
        set: function(value) {
          this._type !== value && this["_resetAssembler"]();
          this._type = value;
          if (this._type === MaskPlusType.Polygon && 0 === this._polygon.length) {
            var _a = this.getNodeRect(), x = _a[0], y = _a[1], width = _a[2], height = _a[3];
            this._polygon.push(cc.v2(x, y), cc.v2(x + width, y), cc.v2(x + width, y + height), cc.v2(x, y + height));
          }
          if (this._type !== MaskPlusType.IMAGE_STENCIL) {
            this.spriteFrame = null;
            this.alphaThreshold = 0;
            this._updateGraphics();
          }
          this["_activateMaterial"]();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(MaskPlus.prototype, "polygon", {
        get: function() {
          return this._polygon;
        },
        set: function(points) {
          this._polygon = points;
          this._updateGraphics();
        },
        enumerable: false,
        configurable: true
      });
      MaskPlus.prototype.setEllipse = function(center, r, segments) {
        this.ellipse.center = center;
        this.ellipse.r = r;
        this.ellipse.segments = segments || this.segements;
      };
      MaskPlus.prototype._updateGraphics = function() {
        var node = this.node;
        var graphics = this["_graphics"];
        graphics.clear(false);
        var _a = this.getNodeRect(), x = _a[0], y = _a[1], width = _a[2], height = _a[3];
        if (this["_type"] === MaskPlusType.RECT) graphics.rect(x, y, width, height); else if (this["_type"] === MaskPlusType.ELLIPSE) {
          var center = this.ellipse.center || cc.v2(x + width / 2, y + height / 2);
          var radius = this.ellipse.r || {
            x: width / 2,
            y: height / 2
          };
          var segments = this.ellipse.segments || this["_segments"];
          var points = _calculateCircle(center, radius, segments);
          for (var i = 0; i < points.length; ++i) {
            var point = points[i];
            0 === i ? graphics.moveTo(point.x, point.y) : graphics.lineTo(point.x, point.y);
          }
          graphics.close();
        } else if (this["_type"] === MaskPlusType.Polygon) {
          0 === this._polygon.length && this._polygon.push(cc.v2(0, 0));
          graphics.moveTo(this._polygon[0].x, this._polygon[0].y);
          for (var i = 1; i < this._polygon.length; i++) graphics.lineTo(this._polygon[i].x, this._polygon[i].y);
          graphics.lineTo(this._polygon[0].x, this._polygon[0].y);
        }
        cc.game.renderType === cc.game.RENDER_TYPE_CANVAS ? graphics.stroke() : graphics.fill();
      };
      MaskPlus.prototype._hitTest = function(cameraPt) {
        var node = this.node;
        var size = node.getContentSize(), w = size.width, h = size.height, testPt = _vec2_temp;
        node["_updateWorldMatrix"]();
        if (!cc.Mat4.invert(_mat4_temp, node["_worldMatrix"])) return false;
        var point = cc.v2(0, 0);
        cc.Vec2.transformMat4(point, cameraPt, _mat4_temp);
        testPt.x = point.x + node["_anchorPoint"].x * w;
        testPt.y = point.y + node["_anchorPoint"].y * h;
        var result = false;
        if (this.type === MaskPlusType.RECT || this.type === MaskPlusType.IMAGE_STENCIL) result = testPt.x >= 0 && testPt.y >= 0 && testPt.x <= w && testPt.y <= h; else if (this.type === MaskPlusType.ELLIPSE) {
          var rx = w / 2, ry = h / 2;
          var px = testPt.x - .5 * w, py = testPt.y - .5 * h;
          result = px * px / (rx * rx) + py * py / (ry * ry) < 1;
        } else this.type === MaskPlusType.Polygon && (result = CommonUtils_1.CommonUtils.isInPolygon(point, this.polygon));
        this.inverted && (result = !result);
        return result;
      };
      MaskPlus.prototype.getNodeRect = function() {
        var width = this.node["_contentSize"].width;
        var height = this.node["_contentSize"].height;
        var x = -width * this.node["_anchorPoint"].x;
        var y = -height * this.node["_anchorPoint"].y;
        return [ x, y, width, height ];
      };
      MaskPlus.Type = MaskPlusType;
      __decorate([ property({
        type: cc.Enum(MaskPlusType),
        override: true
      }) ], MaskPlus.prototype, "_type", void 0);
      __decorate([ property({
        type: cc.Enum(MaskPlusType),
        override: true
      }) ], MaskPlus.prototype, "type", null);
      __decorate([ property({
        type: [ cc.Vec2 ],
        serializable: true
      }) ], MaskPlus.prototype, "_polygon", void 0);
      __decorate([ property({
        type: [ cc.Vec2 ],
        serializable: true
      }) ], MaskPlus.prototype, "polygon", null);
      MaskPlus = __decorate([ ccclass, menu("i18n:MAIN_MENU.component.renderers/MaskPlus"), executeInEditMode, help("i18n:COMPONENT.help_url.mask"), inspector("packages://maskplus/inspector.js") ], MaskPlus);
      return MaskPlus;
    }(cc.Mask);
    exports.default = MaskPlus;
    cc["MaskPlus"] = MaskPlus;
    cc._RF.pop();
  }, {
    "../Utils/CommonUtils": "CommonUtils"
  } ],
  MatchUtils: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "ce2a5iLaMdGPJK3POfEqDgZ", "MatchUtils");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MathUtils = void 0;
    class MathUtils {
      static clamp(a, b, x) {
        if (a > b) {
          let t = a;
          a = b;
          b = t;
        }
        if (x < a) return a;
        if (x > b) return b;
        return x;
      }
      static getAngle(radian) {
        return 180 * radian / Math.PI;
      }
      static getRadian(angle) {
        return angle / 180 * Math.PI;
      }
      static getRadian2(p1X, p1Y, p2X, p2Y) {
        var xdis = p2X - p1X;
        var ydis = p2Y - p1Y;
        return Math.atan2(ydis, xdis);
      }
      static getDistance(p1X, p1Y, p2X, p2Y) {
        var disX = p2X - p1X;
        var disY = p2Y - p1Y;
        var disQ = disX * disX + disY * disY;
        return Math.sqrt(disQ);
      }
      static toFixedStr(value, fixCount) {
        return value.toFixed(fixCount).replace(/\.?0*$/, "");
      }
      static toPercentStr(value, fixCount) {
        return this.toFixedStr(100 * value, fixCount) + "%";
      }
      static toFixedWan(value) {
        const wanFix = 1e5;
        let wanFloat = wanFix / 10;
        var v = Math.floor(value / wanFloat) * wanFloat;
        return value > wanFix ? `${MathUtils.toFixedStr(v / wanFix * 10, 1)}\u4e07` : value.toString();
      }
      static getFinalValueBasedOnParams(level, paramList, needCeil) {
        if (paramList.length < 5) return 0;
        let ret = paramList[4] * (paramList[0] * Math.pow(level, paramList[3]) + paramList[1] * level + paramList[2]);
        needCeil && (ret = Math.ceil(ret));
        return ret;
      }
      static getRandomInt(min, max) {
        return Math.floor(Math.random() * (max - min)) + min;
      }
      static limit($from, $end) {
        $from = Math.min($from, $end);
        $end = Math.max($from, $end);
        var range = $end - $from;
        return $from + Math.random() * range;
      }
      static limitInteger($from, $end) {
        return Math.round(MathUtils.limit($from, $end));
      }
      static randomArray(arr) {
        var index = Math.floor(Math.random() * arr.length);
        return arr[index];
      }
    }
    exports.MathUtils = MathUtils;
    cc._RF.pop();
  }, {} ],
  Measure: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "88f3djvTDJHMY+UnVZdcrvg", "Measure");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.measure = void 0;
    var measure = function(target, propertyKey, descriptor) {
      var originalMethod = descriptor.value;
      descriptor.value = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
        var start = performance.now();
        var result = originalMethod.apply(this, args);
        var finish = performance.now();
        console.log(propertyKey + " Execution time: " + (finish - start).toFixed(2) + " milliseconds");
        return result;
      };
      return descriptor;
    };
    exports.measure = measure;
    cc._RF.pop();
  }, {} ],
  MenuItem: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "8f753evmXpEpJHipBbmNcOy", "MenuItem");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const UIWorkDesk_1 = require("../../UIScript/UIWorkDesk");
    const {ccclass: ccclass, property: property} = cc._decorator;
    let MenuItem = class MenuItem extends cc.Component {
      constructor() {
        super(...arguments);
        this.icon = null;
        this.desk = null;
        this.itemData = null;
        this.rawItem = null;
      }
      onLoad() {}
      init(desk) {
        this.desk = desk;
      }
      start() {
        this.registerEvent();
      }
      registerEvent() {
        this.node.on(cc.Node.EventType.TOUCH_START, this.touchStart, this);
        this.node.on(cc.Node.EventType.TOUCH_MOVE, this.desk.dragMove.bind(this.desk), this);
        this.node.on(cc.Node.EventType.TOUCH_END, this.desk.dragEnd.bind(this.desk), this);
        this.node.on(cc.Node.EventType.TOUCH_CANCEL, this.desk.dragEnd.bind(this.desk), this);
      }
      unRegisterEvent() {
        this.node.off(cc.Node.EventType.TOUCH_START, this.touchStart, this);
        this.node.off(cc.Node.EventType.TOUCH_MOVE, this.desk.dragMove.bind(this.desk), this);
        this.node.off(cc.Node.EventType.TOUCH_END, this.desk.dragEnd.bind(this.desk), this);
        this.node.off(cc.Node.EventType.TOUCH_CANCEL, this.desk.dragEnd.bind(this.desk), this);
      }
      touchStart(event) {
        this.desk.dragNode(event, this, UIWorkDesk_1.DragType.Menu);
      }
      onDestroy() {
        super.onDestroy();
        this.unRegisterEvent();
      }
    };
    __decorate([ property({
      type: cc.Sprite,
      tooltip: false
    }) ], MenuItem.prototype, "icon", void 0);
    MenuItem = __decorate([ ccclass ], MenuItem);
    exports.default = MenuItem;
    cc._RF.pop();
  }, {
    "../../UIScript/UIWorkDesk": "UIWorkDesk"
  } ],
  MeshAssembler: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "9ba87xSitVM9boajZ/wQdaJ", "MeshAssembler");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var gfx = cc["gfx"];
    var vfmtPosUvColor = new gfx.VertexFormat([ {
      name: gfx.ATTR_POSITION,
      type: gfx.ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: gfx.ATTR_UV0,
      type: gfx.ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: gfx.ATTR_COLOR,
      type: gfx.ATTR_TYPE_UINT8,
      num: 4,
      normalize: true
    } ]);
    var MeshAssembler = function(_super) {
      __extends(MeshAssembler, _super);
      function MeshAssembler() {
        var _this = _super.call(this) || this;
        _this.row = 0;
        _this.col = 0;
        _this._realRow = 0;
        _this._realCol = 0;
        _this.stepRow = 0;
        _this.StepCol = 0;
        _this.verticesCount = 4;
        _this.indicesCount = 6;
        _this.floatsPerVert = 5;
        _this.uvOffset = 2;
        _this.colorOffset = 4;
        _this._renderData = null;
        _this._local = null;
        _this._renderData = new cc.RenderData();
        _this._renderData.init(_this);
        _this.initData();
        _this.initLocal();
        return _this;
      }
      Object.defineProperty(MeshAssembler.prototype, "verticesFloats", {
        get: function() {
          return this.verticesCount * this.floatsPerVert;
        },
        enumerable: false,
        configurable: true
      });
      MeshAssembler.prototype.getTriangleCount = function() {
        return (this.row - 1) * (this.col - 1) * 2;
      };
      MeshAssembler.prototype.getTriangle = function(idx) {
        if (idx < 0 || idx >= this.getTriangleCount()) return null;
        var verts = this._renderData.vDatas[0];
        var vertIdx = Math.floor(idx / this._realCol) * this._realCol * 2 + idx;
        var arr = [];
        arr = idx % 2 == 0 ? [ cc.v2(verts[vertIdx * this.floatsPerVert], verts[vertIdx * this.floatsPerVert + 1]), cc.v2(verts[(vertIdx + 1) * this.floatsPerVert], verts[(vertIdx + 1) * this.floatsPerVert + 1]), cc.v2(verts[(vertIdx + this._realCol) * this.floatsPerVert], verts[(vertIdx + this._realCol) * this.floatsPerVert + 1]) ] : [ cc.v2(verts[vertIdx * this.floatsPerVert], verts[vertIdx * this.floatsPerVert + 1]), cc.v2(verts[(vertIdx + this._realCol) * this.floatsPerVert], verts[(vertIdx + this._realCol) * this.floatsPerVert + 1]), cc.v2(verts[(vertIdx + this._realCol - 1) * this.floatsPerVert], verts[(vertIdx + this._realCol - 1) * this.floatsPerVert + 1]) ];
        return arr;
      };
      MeshAssembler.prototype.setTriangle = function(idx, arr, comp) {
        if (idx < 0 || idx >= this.getTriangleCount()) return;
        var verts = this._renderData.vDatas[0];
        var vertIdx = Math.floor(idx / this._realCol) * this._realCol * 2 + idx;
        if (idx % 2 == 0) {
          verts[vertIdx * this.floatsPerVert] = arr[0].x;
          verts[vertIdx * this.floatsPerVert + 1] = arr[0].y;
          verts[(vertIdx + 1) * this.floatsPerVert] = arr[1].x;
          verts[(vertIdx + 1) * this.floatsPerVert + 1] = arr[1].y;
          verts[(vertIdx + this._realCol) * this.floatsPerVert] = arr[2].x;
          verts[(vertIdx + this._realCol) * this.floatsPerVert + 1] = arr[2].y;
        } else {
          verts[vertIdx * this.floatsPerVert] = arr[0].x;
          verts[vertIdx * this.floatsPerVert + 1] = arr[0].y;
          verts[(vertIdx + this._realCol) * this.floatsPerVert] = arr[1].x;
          verts[(vertIdx + this._realCol) * this.floatsPerVert + 1] = arr[1].y;
          verts[(vertIdx + this._realCol - 1) * this.floatsPerVert] = arr[2].x;
          verts[(vertIdx + this._realCol - 1) * this.floatsPerVert + 1] = arr[2].y;
        }
        comp._vertsDirty = true;
      };
      MeshAssembler.prototype.getRectCount = function() {
        return (this.row - 1) * (this.col - 1);
      };
      MeshAssembler.prototype.getRect = function(idx) {
        if (idx < 0 || idx >= this.getRectCount()) return null;
        var verts = this._renderData.vDatas[0];
        var vertIdx = Math.floor(2 * idx / this._realCol) * this._realCol * 2 + 2 * idx % this._realCol;
        var arr = [ cc.v2(verts[vertIdx * this.floatsPerVert], verts[vertIdx * this.floatsPerVert + 1]), cc.v2(verts[(vertIdx + 1) * this.floatsPerVert], verts[(vertIdx + 1) * this.floatsPerVert + 1]), cc.v2(verts[(vertIdx + this._realCol) * this.floatsPerVert], verts[(vertIdx + this._realCol) * this.floatsPerVert + 1]), cc.v2(verts[(vertIdx + this._realCol + 1) * this.floatsPerVert], verts[(vertIdx + this._realCol + 1) * this.floatsPerVert + 1]) ];
        return arr;
      };
      MeshAssembler.prototype.setRect = function(idx, arr) {
        if (idx < 0 || idx >= this.getRectCount()) return;
        var verts = this._renderData.vDatas[0];
        var vertIdx = Math.floor(2 * idx / this._realCol) * this._realCol * 2 + 2 * idx % this._realCol;
        verts[vertIdx * this.floatsPerVert] = arr[0].x;
        verts[vertIdx * this.floatsPerVert + 1] = arr[0].y;
        verts[(vertIdx + 1) * this.floatsPerVert] = arr[1].x;
        verts[(vertIdx + 1) * this.floatsPerVert + 1] = arr[1].y;
        verts[(vertIdx + this._realCol) * this.floatsPerVert] = arr[2].x;
        verts[(vertIdx + this._realCol) * this.floatsPerVert + 1] = arr[2].y;
        verts[(vertIdx + this._realCol + 1) * this.floatsPerVert] = arr[3].x;
        verts[(vertIdx + this._realCol + 1) * this.floatsPerVert + 1] = arr[3].y;
      };
      MeshAssembler.prototype.resetData = function(comp) {
        if (!comp.texture) return;
        var width = comp.texture.width;
        var height = comp.texture.height;
        var step = comp.step;
        this.row = Math.floor(height / step) + 1;
        this.col = Math.floor(width / step) + 1;
        this.stepRow = height / (this.row - 1);
        this.StepCol = width / (this.col - 1);
        this._realRow = 2 + 2 * (this.row - 2);
        this._realCol = 2 + 2 * (this.col - 2);
        cc.log(this.row, this.col);
        this.verticesCount = this._realRow * this._realCol;
        this.indicesCount = (this.row - 1) * (this.col - 1) * 6;
        this._renderData["clear"]();
        this.initData();
      };
      MeshAssembler.prototype.getVfmt = function() {
        return vfmtPosUvColor;
      };
      MeshAssembler.prototype.getBuffer = function() {
        return cc.renderer["_handle"].getBuffer("mesh", this.getVfmt());
      };
      MeshAssembler.prototype.initData = function() {
        var data = this._renderData;
        data.createQuadData(0, this.verticesFloats, this.indicesCount);
        var indices = this._renderData.iDatas[0];
        var indexOffset = 0;
        for (var r = 0; r < this.row - 1; ++r) for (var c = 0; c < this.col - 1; ++c) {
          var start = 2 * r * this._realCol + 2 * c;
          indices[indexOffset++] = start;
          indices[indexOffset++] = start + 1;
          indices[indexOffset++] = start + this._realCol;
          indices[indexOffset++] = start + 1;
          indices[indexOffset++] = start + this._realCol + 1;
          indices[indexOffset++] = start + this._realCol;
        }
      };
      MeshAssembler.prototype.initLocal = function() {
        this._local = [];
        this._local.length = 4;
      };
      MeshAssembler.prototype.updateColor = function(comp, color) {
        var uintVerts = this._renderData.uintVDatas[0];
        if (!uintVerts) return;
        color = null != color ? color : comp.node.color["_val"];
        var floatsPerVert = this.floatsPerVert;
        var colorOffset = this.colorOffset;
        for (var i = 0; i < this.verticesCount; i++) uintVerts[colorOffset + i * floatsPerVert] = color;
      };
      MeshAssembler.prototype.updateUVs = function(comp) {
        var _this = this;
        var uvOffset = this.uvOffset;
        var floatsPerVert = this.floatsPerVert;
        var verts = this._renderData.vDatas[0];
        var vid = 0;
        var _setUv = function(uv_x, uv_y, vid) {
          var voffset = vid * floatsPerVert;
          verts[voffset + uvOffset] = uv_x;
          verts[voffset + uvOffset + 1] = uv_y;
        };
        var _fillOneRow = function(uv_y) {
          for (var col = 0; col < _this.col; col++) {
            var uv_x = col / (_this.col - 1);
            _setUv(uv_x, uv_y, vid++);
            0 !== col && col !== _this.col - 1 && _setUv(uv_x, uv_y, vid++);
          }
        };
        for (var row = 0; row < this.row; row++) {
          var uv_y = 1 - row / (this.row - 1);
          _fillOneRow(uv_y);
          0 !== row && row !== this.row - 1 && _fillOneRow(uv_y);
        }
      };
      MeshAssembler.prototype.updateWorldVertsWebGL = function(comp) {
        var _this = this;
        var local = this._local;
        var verts = this._renderData.vDatas[0];
        var matrix = comp.node["_worldMatrix"];
        var matrixm = matrix.m, a = matrixm[0], b = matrixm[1], c = matrixm[4], d = matrixm[5], tx = matrixm[12], ty = matrixm[13];
        var vl = local[0], vr = local[2], vb = local[1], vt = local[3];
        var justTranslate = 1 === a && 0 === b && 0 === c && 1 === d;
        var floatsPerVert = this.floatsPerVert;
        var vertIdx = 0;
        var _setVert = function(localColX, localRowY, vertIdx) {
          var worldIndex = floatsPerVert * vertIdx;
          verts[worldIndex] = localColX + tx;
          verts[worldIndex + 1] = localRowY + ty;
        };
        var _setVert2 = function(localColX, localRowY, vertIdx) {
          var worldIndex = vertIdx * floatsPerVert;
          verts[worldIndex] = localColX * a + localRowY * c + tx;
          verts[worldIndex + 1] = localColX * b + localRowY * d + ty;
        };
        var _fillOneRow = function(localRowY, setVert) {
          for (var col = 0; col < _this.col; col++) {
            var localColX = col == _this.col - 1 ? vr : vl + col * _this.StepCol;
            setVert(localColX, localRowY, vertIdx++);
            0 !== col && col !== _this.col - 1 && setVert(localColX, localRowY, vertIdx++);
          }
        };
        if (justTranslate) for (var row = 0; row < this.row; row++) {
          var localRowY = row == this.row - 1 ? vt : vb + row * this.stepRow;
          _fillOneRow(localRowY, _setVert);
          0 !== row && row !== this.row - 1 && _fillOneRow(localRowY, _setVert);
        } else for (var row = 0; row < this.row; row++) {
          var localRowY = row == this.row - 1 ? vt : vb + row * this.stepRow;
          _fillOneRow(localRowY, _setVert2);
          0 !== row && row !== this.row - 1 && _fillOneRow(localRowY, _setVert2);
        }
      };
      MeshAssembler.prototype.updateWorldVertsNative = function(comp) {
        var local = this._local;
        var verts = this._renderData.vDatas[0];
        var floatsPerVert = this.floatsPerVert;
        var vl = local[0], vr = local[2], vb = local[1], vt = local[3];
        var index = 0;
        verts[index] = vl;
        verts[index + 1] = vb;
        index += floatsPerVert;
        verts[index] = vr;
        verts[index + 1] = vb;
        index += floatsPerVert;
        verts[index] = vl;
        verts[index + 1] = vt;
        index += floatsPerVert;
        verts[index] = vr;
        verts[index + 1] = vt;
      };
      MeshAssembler.prototype.updateWorldVerts = function(comp) {
        false;
        this.updateWorldVertsWebGL(comp);
      };
      MeshAssembler.prototype.updateVerts = function(comp) {
        var node = comp.node, cw = node.width, ch = node.height, appx = node.anchorX * cw, appy = node.anchorY * ch, l, b, r, t;
        l = -appx;
        b = -appy;
        r = cw - appx;
        t = ch - appy;
        var local = this._local;
        local[0] = l;
        local[1] = b;
        local[2] = r;
        local[3] = t;
        this.updateWorldVerts(comp);
      };
      MeshAssembler.prototype.updateRenderData = function(comp) {
        if (comp._vertsDirty) {
          this.resetData(comp);
          this.updateUVs(comp);
          this.updateVerts(comp);
          comp._vertsDirty = false;
        }
      };
      MeshAssembler.prototype.fillBuffers = function(comp, renderer) {
        renderer.worldMatDirty && this.updateWorldVerts(comp);
        var renderData = this._renderData;
        var vData = renderData.vDatas[0];
        var iData = renderData.iDatas[0];
        var buffer = this.getBuffer();
        var offsetInfo = buffer.request(this.verticesCount, this.indicesCount);
        var vertexOffset = offsetInfo.byteOffset >> 2, vbuf = buffer._vData;
        vData.length + vertexOffset > vbuf.length ? vbuf.set(vData.subarray(0, vbuf.length - vertexOffset), vertexOffset) : vbuf.set(vData, vertexOffset);
        var ibuf = buffer._iData, indiceOffset = offsetInfo.indiceOffset, vertexId = offsetInfo.vertexOffset;
        for (var i = 0, l = iData.length; i < l; i++) ibuf[indiceOffset++] = vertexId + iData[i];
      };
      MeshAssembler.prototype.packToDynamicAtlas = function(comp, frame) {
        false;
        if (!frame._original && cc.dynamicAtlasManager && frame._texture.packable) {
          var packedFrame = cc.dynamicAtlasManager.insertSpriteFrame(frame);
          packedFrame && frame._setDynamicAtlasFrame(packedFrame);
        }
        var material = comp._materials[0];
        if (!material) return;
        if (material.getProperty("texture") !== frame._texture) {
          comp._vertsDirty = true;
          comp._updateMaterial();
        }
      };
      return MeshAssembler;
    }(cc.Assembler);
    exports.default = MeshAssembler;
    cc._RF.pop();
  }, {} ],
  MeshTexture: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "1acd7QWgaNGAIz6Mkh6ICTD", "MeshTexture");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = this && this.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (1 & t[0]) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, "function" === typeof Symbol && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([ n, v ]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = 2 & op[0] ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 
          0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          (y = 0, t) && (op = [ 2 & op[0], t.value ]);
          switch (op[0]) {
           case 0:
           case 1:
            t = op;
            break;

           case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

           case 5:
            _.label++;
            y = op[1];
            op = [ 0 ];
            continue;

           case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;

           default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (6 === op[0] || 2 === op[0])) {
              _ = 0;
              continue;
            }
            if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (6 === op[0] && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop();
            _.trys.pop();
            continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [ 6, e ];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (5 & op[0]) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var MeshAssembler_1 = require("../Assemblers/MeshAssembler");
    var _a = cc._decorator, ccclass = _a.ccclass, menu = _a.menu, executeInEditMode = _a.executeInEditMode, mixins = _a.mixins, property = _a.property;
    var MeshTexture = function(_super) {
      __extends(MeshTexture, _super);
      function MeshTexture() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this._texture = null;
        _this.step = 10;
        _this.srcBlendFactor = cc.macro.BlendFactor.SRC_ALPHA;
        _this.dstBlendFactor = cc.macro.BlendFactor.ONE_MINUS_SRC_ALPHA;
        _this._assembler = null;
        return _this;
      }
      Object.defineProperty(MeshTexture.prototype, "texture", {
        get: function() {
          return this._texture;
        },
        set: function(val) {
          this._texture = val;
          this.node.width = val.width;
          this.node.height = val.height;
          this._updateMaterial();
        },
        enumerable: false,
        configurable: true
      });
      MeshTexture.prototype._updateVerts = function() {
        this.setVertsDirty();
      };
      MeshTexture.prototype._updateMaterial = function() {
        var texture = this._texture;
        var material = this.getMaterial(0);
        if (material) {
          void 0 !== material.getDefine("USE_TEXTURE") && material.define("USE_TEXTURE", true);
          material.setProperty("texture", texture);
        }
        this["__proto__"]._updateBlendFunc.call(this);
        this.setVertsDirty();
      };
      MeshTexture.prototype._validateRender = function() {};
      MeshTexture.prototype._resetAssembler = function() {
        var assembler = this._assembler = window["textureAssember"] = new MeshAssembler_1.default();
        assembler.init(this);
        this._updateColor();
        this.setVertsDirty();
      };
      MeshTexture.prototype.getPolygonCenter = function(polygon) {
        var x = 0, y = 0;
        for (var i = 0; i < polygon.length; i++) {
          x += polygon[i].x;
          y += polygon[i].y;
        }
        x /= polygon.length;
        y /= polygon.length;
        return cc.v2(x, y);
      };
      MeshTexture.prototype.tweenVec2 = function(from, to, duration, onUpdate, onComplete, delay) {
        void 0 === delay && (delay = 0);
        var o = {
          _value: from
        };
        Object.defineProperty(o, "position", {
          get: function() {
            return o._value;
          },
          set: function(v) {
            o._value = v;
            onUpdate && onUpdate(o._value);
          }
        });
        var tween = cc.tween(o).delay(delay).to(duration, {
          position: to
        }).call(onComplete);
        tween.start();
        return tween;
      };
      MeshTexture.prototype.tweenVec2Bezier = function(from, to, duration, onUpdate, onComplete, delay) {
        void 0 === delay && (delay = 0);
        var o = {
          _value: from
        };
        Object.defineProperty(o, "position", {
          get: function() {
            return o._value;
          },
          set: function(v) {
            o._value = v;
            onUpdate && onUpdate(o._value);
          }
        });
        var tween = cc.tween(o).delay(delay).bezierTo(duration, cc.v2(from.x, from.y + 100), cc.v2(to.x, to.y + 100), to).call(onComplete);
        tween.start();
        return tween;
      };
      MeshTexture.prototype.doScaleEffect = function() {
        var _this = this;
        return new Promise(function(resolve, reject) {
          var rectCount = _this._assembler.getRectCount();
          var pos = _this.node.convertToWorldSpaceAR(cc.v2(0, 0));
          var _loop_1 = function(i) {
            var arr = _this._assembler.getRect(i);
            var center = _this.getPolygonCenter(arr);
            var dir = center.sub(pos).normalize();
            _this.tweenVec2(cc.v2(0, 0), dir.mul(1.5), .3, function(dt) {
              _this._assembler.setRect(i, [ arr[0].addSelf(dt), arr[1].addSelf(dt), arr[2].addSelf(dt), arr[3].addSelf(dt) ]);
            }, function() {
              i == rectCount - 1 && resolve(true);
            });
          };
          for (var i = 0; i < rectCount; i++) _loop_1(i);
        });
      };
      MeshTexture.prototype.doTextureMove = function(e, data) {
        return __awaiter(this, void 0, void 0, function() {
          var dir, rectCount, pos, _loop_2, this_1, i;
          var _this = this;
          return __generator(this, function(_a) {
            dir = cc.v2(-1, 0);
            "right" == data && (dir = cc.v2(1, 0));
            rectCount = this._assembler.getRectCount();
            pos = this.node.convertToWorldSpaceAR(cc.v2(0, 0));
            _loop_2 = function(i) {
              var idx = rectCount - i - 1;
              var arr = this_1._assembler.getRect(idx);
              var targetPos = dir.mul(400);
              this_1.tweenVec2Bezier(cc.v2(0, 0), targetPos, 1, function(dt) {
                _this._assembler.setRect(idx, [ arr[0].add(dt), arr[1].add(dt), arr[2].add(dt), arr[3].add(dt) ]);
              }, function() {
                _this._assembler.setRect(idx, [ arr[0].add(targetPos), arr[1].add(targetPos), arr[2].add(targetPos), arr[3].add(targetPos) ]);
              }, .1 * Math.floor(i / 40));
            };
            this_1 = this;
            for (i = 0; i < rectCount; i++) _loop_2(i);
            return [ 2 ];
          });
        });
      };
      __decorate([ property(cc.Texture2D) ], MeshTexture.prototype, "_texture", void 0);
      __decorate([ property(cc.Texture2D) ], MeshTexture.prototype, "texture", null);
      __decorate([ property({
        displayName: "\u6b65\u957f"
      }) ], MeshTexture.prototype, "step", void 0);
      __decorate([ property({
        type: cc.Enum(cc.macro.BlendFactor),
        override: true
      }) ], MeshTexture.prototype, "srcBlendFactor", void 0);
      __decorate([ property({
        type: cc.Enum(cc.macro.BlendFactor),
        override: true
      }) ], MeshTexture.prototype, "dstBlendFactor", void 0);
      MeshTexture = __decorate([ ccclass, executeInEditMode, menu("i18n:MAIN_MENU.component.ui/MeshTexture"), mixins(cc.BlendFunc) ], MeshTexture);
      return MeshTexture;
    }(cc.RenderComponent);
    exports.default = MeshTexture;
    cc._RF.pop();
  }, {
    "../Assemblers/MeshAssembler": "MeshAssembler"
  } ],
  MessageInfo: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "19cfc8vrhdFtKaKI74EWCyv", "MessageInfo");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.MessageInfo = void 0;
    class MessageInfo {}
    exports.MessageInfo = MessageInfo;
    MessageInfo.rawInfo = "\u5148\u628a\u539f\u6599\u653e\u5165\u63d2\u69fd";
    MessageInfo.makeSucc = "\u5236\u4f5c\u6210\u529f";
    MessageInfo.checkMenuErrr = "\u914d\u65b9\u5339\u914d\u5931\u8d25";
    MessageInfo.unlockRecipe = "\u672a\u89e3\u9501\u5f53\u524d\u914d\u65b9";
    MessageInfo.buySucc = "\u8d2d\u4e70\u6210\u529f";
    MessageInfo.buyFail = "\u5c0f\u5c4c\u4e1d\uff0c\u4f60\u4e70\u4e0d\u8d77~~~";
    MessageInfo.noRaw = "\u6682\u65f6\u6ca1\u6709\u65b0\u7684~";
    cc._RF.pop();
  }, {} ],
  MessageType: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "64f8ceb62tIyYTl7+o/NdOW", "MessageType");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TableType = exports.RoleType = exports.MessageType = void 0;
    var MessageType;
    (function(MessageType) {
      MessageType["RoleStand"] = "0";
      MessageType["BuildState"] = "1";
      MessageType["GameState"] = "2";
    })(MessageType = exports.MessageType || (exports.MessageType = {}));
    var RoleType;
    (function(RoleType) {
      RoleType["COME"] = "come";
      RoleType["LEAVE"] = "leave";
      RoleType["SIT"] = "sit";
      RoleType["WAIT"] = "wait";
    })(RoleType = exports.RoleType || (exports.RoleType = {}));
    var TableType;
    (function(TableType) {
      TableType["NONE"] = "none";
      TableType["DRINK"] = "drink";
      TableType["TRASH"] = "trash";
    })(TableType = exports.TableType || (exports.TableType = {}));
    cc._RF.pop();
  }, {} ],
  ModalMgr1: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "6c4f4bdEj1Ng5N+KJWsftEv", "ModalMgr1");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = this && this.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (1 & t[0]) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, "function" === typeof Symbol && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([ n, v ]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = 2 & op[0] ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 
          0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          (y = 0, t) && (op = [ 2 & op[0], t.value ]);
          switch (op[0]) {
           case 0:
           case 1:
            t = op;
            break;

           case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

           case 5:
            _.label++;
            y = op[1];
            op = [ 0 ];
            continue;

           case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;

           default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (6 === op[0] || 2 === op[0])) {
              _ = 0;
              continue;
            }
            if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (6 === op[0] && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop();
            _.trys.pop();
            continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [ 6, e ];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (5 & op[0]) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var UIModalScript_1 = require("./UIModalScript");
    var SysDefine_1 = require("./config/SysDefine");
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
    var ModalMgr1 = function(_super) {
      __extends(ModalMgr1, _super);
      function ModalMgr1() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.uiModal = null;
        return _this;
      }
      ModalMgr1_1 = ModalMgr1;
      Object.defineProperty(ModalMgr1, "inst", {
        get: function() {
          if (null == this._inst) {
            this._inst = new ModalMgr1_1();
            var node = new cc.Node("UIModalNode");
            ModalMgr1_1.popUpRoot = SysDefine_1.SysDefine.SYS_UIROOT_NAME + "/" + SysDefine_1.SysDefine.SYS_DRAWER_NODE;
            var rootNode = cc.find(ModalMgr1_1.popUpRoot);
            rootNode.addChild(node);
            this._inst.uiModal = node.addComponent(UIModalScript_1.default);
            this._inst.uiModal.init();
          }
          return this._inst;
        },
        enumerable: false,
        configurable: true
      });
      ModalMgr1.prototype.showModal = function(maskType) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              return [ 4, this.uiModal.showModal(maskType.opacity, maskType.easingTime, maskType.isEasing, maskType.dualBlur) ];

             case 1:
              _a.sent();
              return [ 2 ];
            }
          });
        });
      };
      ModalMgr1.prototype.checkModalWindow = function(coms) {
        if (coms.length <= 0) {
          this.uiModal.node.active = false;
          return;
        }
        this.uiModal.node.active = true;
        this.uiModal.node.parent && this.uiModal.node.removeFromParent();
        for (var i = coms.length - 1; i >= 0; i--) if (coms[i].modalType.opacity > 0) {
          cc.find(ModalMgr1_1.popUpRoot).addChild(this.uiModal.node, Math.max(coms[i].node.zIndex - 1, 0));
          this.uiModal.fid = coms[i].fid;
          this.showModal(coms[i].modalType);
          break;
        }
      };
      var ModalMgr1_1;
      ModalMgr1.popUpRoot = "";
      ModalMgr1._inst = null;
      ModalMgr1 = ModalMgr1_1 = __decorate([ ccclass ], ModalMgr1);
      return ModalMgr1;
    }(cc.Component);
    exports.default = ModalMgr1;
    cc._RF.pop();
  }, {
    "./UIModalScript": "UIModalScript",
    "./config/SysDefine": "SysDefine"
  } ],
  ModalMgr: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "9b75bodHflDGK6GhPrmOvTs", "ModalMgr");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = this && this.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (1 & t[0]) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, "function" === typeof Symbol && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([ n, v ]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = 2 & op[0] ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 
          0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          (y = 0, t) && (op = [ 2 & op[0], t.value ]);
          switch (op[0]) {
           case 0:
           case 1:
            t = op;
            break;

           case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

           case 5:
            _.label++;
            y = op[1];
            op = [ 0 ];
            continue;

           case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;

           default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (6 === op[0] || 2 === op[0])) {
              _ = 0;
              continue;
            }
            if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (6 === op[0] && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop();
            _.trys.pop();
            continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [ 6, e ];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (5 & op[0]) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var UIModalScript_1 = require("./UIModalScript");
    var SysDefine_1 = require("./config/SysDefine");
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
    var ModalMgr = function(_super) {
      __extends(ModalMgr, _super);
      function ModalMgr() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.uiModal = null;
        return _this;
      }
      ModalMgr_1 = ModalMgr;
      Object.defineProperty(ModalMgr, "inst", {
        get: function() {
          if (null == this._inst) {
            this._inst = new ModalMgr_1();
            var node = new cc.Node("UIModalNode");
            ModalMgr_1.popUpRoot = SysDefine_1.SysDefine.SYS_UIROOT_NAME + "/" + SysDefine_1.SysDefine.SYS_POPUP_NODE;
            var rootNode = cc.find(ModalMgr_1.popUpRoot);
            rootNode.addChild(node);
            this._inst.uiModal = node.addComponent(UIModalScript_1.default);
            this._inst.uiModal.init();
          }
          return this._inst;
        },
        enumerable: false,
        configurable: true
      });
      ModalMgr.prototype.showModal = function(maskType) {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              return [ 4, this.uiModal.showModal(maskType.opacity, maskType.easingTime, maskType.isEasing, maskType.dualBlur) ];

             case 1:
              _a.sent();
              return [ 2 ];
            }
          });
        });
      };
      ModalMgr.prototype.checkModalWindow = function(coms) {
        if (coms.length <= 0) {
          this.uiModal.node.active = false;
          return;
        }
        this.uiModal.node.active = true;
        this.uiModal.node.parent && this.uiModal.node.removeFromParent();
        for (var i = coms.length - 1; i >= 0; i--) if (coms[i].modalType.opacity > 0) {
          cc.find(ModalMgr_1.popUpRoot).addChild(this.uiModal.node, Math.max(coms[i].node.zIndex - 1, 0));
          this.uiModal.fid = coms[i].fid;
          this.showModal(coms[i].modalType);
          break;
        }
      };
      var ModalMgr_1;
      ModalMgr.popUpRoot = "";
      ModalMgr._inst = null;
      ModalMgr = ModalMgr_1 = __decorate([ ccclass ], ModalMgr);
      return ModalMgr;
    }(cc.Component);
    exports.default = ModalMgr;
    cc._RF.pop();
  }, {
    "./UIModalScript": "UIModalScript",
    "./config/SysDefine": "SysDefine"
  } ],
  Obstacle: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "eaa90oCwvRPFqm2RBIJWdZL", "Obstacle");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var QuadTree_1 = require("../Components/QuadTree");
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
    var Obstacle = function(_super) {
      __extends(Obstacle, _super);
      function Obstacle() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this._quadtree = null;
        _this._polygons = cc.js.createMap();
        return _this;
      }
      Obstacle.prototype.onLoad = function() {
        var size = cc.view.getVisibleSize();
        this._quadtree = new QuadTree_1.default({
          x: 0,
          y: 0,
          width: size.width,
          height: size.height
        });
      };
      Obstacle.prototype.addPolygon = function(uid, points) {
        this._polygons[uid] = points;
        var bound = this._getBound(points);
        bound.uid = uid;
        this._quadtree.insert(bound);
      };
      Obstacle.prototype.removePolygon = function(uid) {};
      Obstacle.prototype.getPolygons = function(bound) {
        var bounds = this._quadtree.retrieve(bound);
        var polygons = [];
        for (var _i = 0, bounds_1 = bounds; _i < bounds_1.length; _i++) {
          var e = bounds_1[_i];
          polygons.push(this._polygons[e.uid]);
        }
        return polygons;
      };
      Obstacle.prototype._getBound = function(points) {
        var point = points[0];
        var xMin = point.x;
        var xMax = point.x;
        var yMin = point.y;
        var yMax = point.y;
        for (var i = 0; i < points.length; i++) {
          points[i].x < xMin && (xMin = points[i].x);
          points[i].x > xMax && (xMax = points[i].x);
          points[i].y < yMin && (yMin = points[i].y);
          points[i].y > yMax && (yMax = points[i].y);
        }
        return new QuadTree_1.Bound(xMin, yMin, xMax - xMin, yMax - yMin);
      };
      Obstacle.prototype.clear = function() {
        this._quadtree.clear();
        this._polygons = {};
      };
      Obstacle = __decorate([ ccclass ], Obstacle);
      return Obstacle;
    }(cc.Component);
    exports.default = Obstacle;
    cc._RF.pop();
  }, {
    "../Components/QuadTree": "QuadTree"
  } ],
  PlayerMgr: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "bea7406655LzLidqx+dJrtq", "PlayerMgr");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var BaseMgr_1 = require("./BaseMgr");
    var PlayerMgr = function(_super) {
      __extends(PlayerMgr, _super);
      function PlayerMgr() {
        return null !== _super && _super.apply(this, arguments) || this;
      }
      PlayerMgr.prototype.onConfigChange = function() {};
      return PlayerMgr;
    }(BaseMgr_1.BaseMgr);
    exports.default = PlayerMgr;
    cc._RF.pop();
  }, {
    "./BaseMgr": "BaseMgr"
  } ],
  Player: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "c6524N6VP9KkIrAUdQgv6Tz", "Player");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var Joystick_1 = require("../Extra/Joystick");
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
    var Joystick_2 = require("../Extra/Joystick");
    var Player = function(_super) {
      __extends(Player, _super);
      function Player() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.rigidbody = false;
        _this.moveDir = cc.v2(0, 1);
        _this._speedType = Joystick_1.SpeedType.STOP;
        _this._moveSpeed = 0;
        _this.stopSpeed = 0;
        _this.normalSpeed = 100;
        _this.fastSpeed = 200;
        _this.PlayerCamera = null;
        return _this;
      }
      Player.prototype.onLoad = function() {
        if (this.rigidbody) {
          cc.director.getPhysicsManager().enabled = true;
          this._body = this.getComponent(cc.RigidBody);
        }
        this._ani = this.getComponent(cc.Animation);
        Joystick_2.instance.on(cc.Node.EventType.TOUCH_START, this.onTouchStart, this);
        Joystick_2.instance.on(cc.Node.EventType.TOUCH_MOVE, this.onTouchMove, this);
        Joystick_2.instance.on(cc.Node.EventType.TOUCH_END, this.onTouchEnd, this);
      };
      Player.prototype.start = function() {
        this._ani.playAdditive("idle");
      };
      Player.prototype.onTouchStart = function() {};
      Player.prototype.onTouchMove = function(event, data) {
        this._speedType = data.speedType;
        this.moveDir = data.moveDistance;
      };
      Player.prototype.onTouchEnd = function(event, data) {
        this._speedType = data.speedType;
      };
      Player.prototype.move = function() {
        this.node.scaleX = this.moveDir.x >= 0 ? -1 : 1;
        if (this.rigidbody) this._body.applyForceToCenter(cc.v2(200 * this.moveDir.x, 200 * this.moveDir.y), true); else {
          var oldPos = cc.v2();
          this.node.getPosition(oldPos);
          var newPos = oldPos.add(this.moveDir.mul(this._moveSpeed / 120));
          this.node.setPosition(newPos);
        }
      };
      Player.prototype.update = function(dt) {
        switch (this._speedType) {
         case Joystick_1.SpeedType.STOP:
          this._moveSpeed = this.stopSpeed;
          break;

         case Joystick_1.SpeedType.NORMAL:
          this._moveSpeed = this.normalSpeed;
          break;

         case Joystick_1.SpeedType.FAST:
          this._moveSpeed = this.fastSpeed;
        }
        this._speedType !== Joystick_1.SpeedType.STOP && this.move();
      };
      __decorate([ property({
        displayName: "\u521a\u4f53\u6a21\u5f0f",
        tooltip: "\u4e0d\u4f1a\u7acb\u5373\u505c\u6b62"
      }) ], Player.prototype, "rigidbody", void 0);
      __decorate([ property({
        displayName: "Move Dir",
        tooltip: "\u79fb\u52a8\u65b9\u5411"
      }) ], Player.prototype, "moveDir", void 0);
      __decorate([ property({
        displayName: "Speed Type",
        tooltip: "\u901f\u5ea6\u7ea7\u522b"
      }) ], Player.prototype, "_speedType", void 0);
      __decorate([ property({
        type: cc.Integer,
        displayName: "Move Speed",
        tooltip: "\u79fb\u52a8\u901f\u5ea6"
      }) ], Player.prototype, "_moveSpeed", void 0);
      __decorate([ property({
        type: cc.Integer,
        displayName: "Stop Speed",
        tooltip: "\u505c\u6b62\u65f6\u901f\u5ea6"
      }) ], Player.prototype, "stopSpeed", void 0);
      __decorate([ property({
        type: cc.Integer,
        tooltip: "\u6b63\u5e38\u901f\u5ea6"
      }) ], Player.prototype, "normalSpeed", void 0);
      __decorate([ property({
        type: cc.Integer,
        tooltip: "\u6700\u5feb\u901f\u5ea6"
      }) ], Player.prototype, "fastSpeed", void 0);
      __decorate([ property(cc.Camera) ], Player.prototype, "PlayerCamera", void 0);
      Player = __decorate([ ccclass ], Player);
      return Player;
    }(cc.Component);
    exports.default = Player;
    cc._RF.pop();
  }, {
    "../Extra/Joystick": "Joystick"
  } ],
  PolygonUtil: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "97fd0nhC4FP37VI4oHddHl0", "PolygonUtil");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.PolygonUtil = void 0;
    var PolygonUtil = function() {
      function PolygonUtil() {}
      PolygonUtil.splitPolygonByLine = function(l0, l1, polygon, useDichotomy) {
        void 0 === useDichotomy && (useDichotomy = false);
        var result = [];
        for (var i = polygon.length - 1; i >= 0; i--) {
          var p0 = polygon[i], p1 = 0 == i ? polygon[polygon.length - 1] : polygon[i - 1];
          var _a = this.lineCrossPoint(p0, p1, l0, l1), n = _a[0], p = _a[1];
          if (-1 == n) continue;
          polygon.splice(i, -1, p);
          result.push(i + 1);
        }
        return result;
      };
      PolygonUtil.lineCrossPoint = function(p1, p2, q1, q2) {
        var a = p1, b = p2, c = q1, d = q2;
        var s1, s2, s3, s4;
        var d1, d2, d3, d4;
        var p = new cc.Vec2(0, 0);
        d1 = this.dblcmp(s1 = this.ab_cross_ac(a, b, c), 0);
        d2 = this.dblcmp(s2 = this.ab_cross_ac(a, b, d), 0);
        d3 = this.dblcmp(s3 = this.ab_cross_ac(c, d, a), 0);
        d4 = this.dblcmp(s4 = this.ab_cross_ac(c, d, b), 0);
        if (-2 == (d1 ^ d2) && -2 == (d3 ^ d4)) {
          p.x = (c.x * s2 - d.x * s1) / (s2 - s1);
          p.y = (c.y * s2 - d.y * s1) / (s2 - s1);
          return [ 0, p ];
        }
        if (0 == d1 && this.point_on_line(c, a, b) <= 0) {
          p = c;
          return [ 1, p ];
        }
        if (0 == d2 && this.point_on_line(d, a, b) <= 0) {
          p = d;
          return [ 1, p ];
        }
        if (0 == d3 && this.point_on_line(a, c, d) <= 0) {
          p = a;
          return [ 1, p ];
        }
        if (0 == d4 && this.point_on_line(b, c, d) <= 0) {
          p = b;
          return [ 1, p ];
        }
        return [ -1, null ];
      };
      PolygonUtil.isLineSegmentCross = function(P1, P2, Q1, Q2) {
        if (((Q1.x - P1.x) * (Q1.y - Q2.y) - (Q1.y - P1.y) * (Q1.x - Q2.x)) * ((Q1.x - P2.x) * (Q1.y - Q2.y) - (Q1.y - P2.y) * (Q1.x - Q2.x)) < 0 || ((P1.x - Q1.x) * (P1.y - P2.y) - (P1.y - Q1.y) * (P1.x - P2.x)) * ((P1.x - Q2.x) * (P1.y - P2.y) - (P1.y - Q2.y) * (P1.x - P2.x)) < 0) return true;
        return false;
      };
      PolygonUtil.point_on_line = function(a, p1, p2) {
        return this.dblcmp(this.dot(p1.x - a.x, p1.y - a.y, p2.x - a.x, p2.y - a.y), 0);
      };
      PolygonUtil.rayPointToLine = function(point, linePA, linePB) {
        var minX = Math.min(linePA.x, linePB.x);
        var maxX = Math.max(linePA.x, linePB.x);
        var minY = Math.min(linePA.y, linePB.y);
        var maxY = Math.max(linePA.y, linePB.y);
        if (point.y < minY || point.y > maxY || point.x > maxX) return -1;
        var x0 = linePA.x + (linePB.x - linePA.x) / (linePB.y - linePA.y) * (point.y - linePA.y);
        if (x0 > point.x) return 0;
        if (x0 == point.x) return 1;
        return -1;
      };
      PolygonUtil.relationPointToPolygon = function(point, polygon) {
        var count = 0;
        for (var i = 0; i < polygon.length; ++i) {
          if (polygon[i].equals(point)) return 2;
          var pa = polygon[i];
          var pb = polygon[0];
          i < polygon.length - 1 && (pb = polygon[i + 1]);
          var re = this.rayPointToLine(point, pa, pb);
          if (1 == re) return 1;
          0 == re && count++;
        }
        if (count % 2 == 0) return -1;
        return 0;
      };
      PolygonUtil.lineCutPolygon = function(pa, pb, polygon) {
        var ret = [];
        var points = [];
        var pointIndex = [];
        for (var i = 0; i < polygon.length; ++i) {
          points.push(polygon[i]);
          var a = polygon[i];
          var b = polygon[0];
          i < polygon.length - 1 && (b = polygon[i + 1]);
          var c = this.lineCrossPoint(pa, pb, a, b);
          if (0 == c[0]) {
            pointIndex.push(points.length);
            points.push(c[1]);
          } else c[0] > 0 && (c[1].equals(a) ? pointIndex.push(points.length - 1) : pointIndex.push(points.length));
        }
        if (pointIndex.length > 1) {
          var cp0 = points[pointIndex[0]];
          var cp1 = points[pointIndex[1]];
          var r = this.relationPointToPolygon(new cc.Vec2((cp0.x + cp1.x) / 2, (cp0.y + cp1.y) / 2), polygon);
          var inPolygon = r >= 0;
          if (pointIndex.length > 2 && cp0.sub(cp1).mag() > cp0.sub(points[pointIndex[pointIndex.length - 1]]).mag()) {
            cp1 = points[pointIndex[pointIndex.length - 1]];
            r = this.relationPointToPolygon(new cc.Vec2((cp0.x + cp1.x) / 2, (cp0.y + cp1.y) / 2), polygon);
            inPolygon = r < 0;
          }
          var firstInPolygon = inPolygon;
          var index = 0;
          var startIndex = pointIndex[index];
          var oldPoints = [];
          var newPoints = [];
          var count = 0;
          oldPoints.push(points[startIndex]);
          inPolygon && newPoints.push(points[startIndex]);
          index++;
          count++;
          startIndex++;
          while (count < points.length) {
            startIndex == points.length && (startIndex = 0);
            var p = points[startIndex];
            if (index >= 0 && startIndex == pointIndex[index]) {
              index++;
              index >= pointIndex.length && (index = 0);
              if (inPolygon) {
                newPoints.push(p);
                ret.push(newPoints);
                newPoints = [];
              } else {
                newPoints = [];
                newPoints.push(p);
              }
              oldPoints.push(p);
              inPolygon = !inPolygon;
            } else inPolygon ? newPoints.push(p) : oldPoints.push(p);
            startIndex++;
            count++;
          }
          if (inPolygon) if (!firstInPolygon && newPoints.length > 1) {
            newPoints.push(points[pointIndex[0]]);
            ret.push(newPoints);
          } else for (var i = 0; i < newPoints.length; ++i) oldPoints.push(newPoints[i]);
          ret.push(oldPoints);
        }
        return ret;
      };
      PolygonUtil.ab_cross_ac = function(a, b, c) {
        return this.cross(b.x - a.x, b.y - a.y, c.x - a.x, c.y - a.y);
      };
      PolygonUtil.dot = function(x1, y1, x2, y2) {
        return x1 * x2 + y1 * y2;
      };
      PolygonUtil.cross = function(x1, y1, x2, y2) {
        return x1 * y2 - x2 * y1;
      };
      PolygonUtil.dblcmp = function(a, b) {
        if (Math.abs(a - b) <= 1e-6) return 0;
        return a > b ? 1 : -1;
      };
      return PolygonUtil;
    }();
    exports.PolygonUtil = PolygonUtil;
    cc._RF.pop();
  }, {} ],
  Pool: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "284d8zxqTdJtYjT+CGS5XDE", "Pool");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Pool = void 0;
    var Pool = function() {
      function Pool(fn, size) {
        this._fn = fn;
        this._idx = size - 1;
        this._frees = new Array(size);
        for (var i = 0; i < size; i++) this._frees[i] = fn();
      }
      Object.defineProperty(Pool.prototype, "freeCount", {
        get: function() {
          return this._frees.length;
        },
        enumerable: false,
        configurable: true
      });
      Pool.prototype.alloc = function() {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) params[_i] = arguments[_i];
        this._idx < 0 && this._expand(Math.round(1.2 * this._frees.length) + 1);
        var obj = this._frees[this._idx];
        this._frees.splice(this._idx);
        --this._idx;
        obj.use && obj.use.apply(obj, params);
        return obj;
      };
      Pool.prototype.free = function(obj) {
        ++this._idx;
        obj.free && obj.free();
        this._frees[this._idx] = obj;
      };
      Pool.prototype.clear = function(fn) {
        for (var i = 0; i < this._idx; i++) fn && fn(this._frees[i]);
        this._frees.splice(0);
        this._idx = -1;
      };
      Pool.prototype._expand = function(size) {
        var old = this._frees;
        this._frees = new Array(size);
        var len = size - old.length;
        for (var i = 0; i < len; i++) this._frees[i] = this._fn();
        for (var i = len, j = 0; i < size; ++i, ++j) this._frees[i] = old[j];
        this._idx += len;
      };
      return Pool;
    }();
    exports.Pool = Pool;
    cc._RF.pop();
  }, {} ],
  Printer: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "8f39dwNrqdDNaoXE30RfAfY", "Printer");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Priter = void 0;
    const {ccclass: ccclass, property: property} = cc._decorator;
    var LaeblType;
    (function(LaeblType) {
      LaeblType[LaeblType["Label"] = 0] = "Label";
      LaeblType[LaeblType["RichText"] = 1] = "RichText";
    })(LaeblType || (LaeblType = {}));
    let Priter = class Priter extends cc.Component {
      constructor() {
        super(...arguments);
        this.labelType = LaeblType.Label;
        this.label = null;
        this.printerTimer = null;
      }
      onLoad() {
        this.richTextEditBox && (this.richTextEditBox.string = "FF0000");
      }
      beforeDestory() {
        this.printerTimer && clearInterval(this.printerTimer);
      }
      showLabelPrinter(str) {
        this.label.string = "";
        this.makeLabelPrinter(str);
      }
      makeLabelPrinter(str) {
        let charArr = str.split("");
        let charIdx = 0;
        this.printerTimer && clearInterval(this.printerTimer);
        this.printerTimer = setInterval(() => {
          if (charIdx >= charArr.length) this.printerTimer && clearInterval(this.printerTimer); else {
            charIdx += 1;
            this.label.string = charArr.slice(0, charIdx).join("");
          }
        }, 150);
      }
      showRichTextPrinter(str) {
        this.richText.string = "";
        this.makeRichTextPrinter(str);
      }
      makeRichTextPrinter(str) {
        let delimiterCharList = [ "\u2701", "\u2702", "\u2703", "\u2704", "\u273a", "\u273b", "\u273c", "\u2744", "\u2745", "\u2746", "\u2747", "\u2748", "\u2749", "\u274a" ];
        let regexp = /<.+?\/?>/g;
        let matchArr = str.match(regexp);
        let delimiterChar = delimiterCharList.find(item => -1 == str.indexOf(item));
        let replaceStr = str.replace(regexp, delimiterChar);
        let tagInfoArr = [];
        let temp = [];
        let tagInfo = {};
        let num = 0;
        for (let i = 0; i < replaceStr.length; i++) if (replaceStr[i] == delimiterChar) {
          temp.push(i);
          if (temp.length >= 2) {
            tagInfo.endStr = matchArr[2 * tagInfoArr.length + 1];
            tagInfo.endtIdx = i - num;
            tagInfoArr.push(tagInfo);
            temp = [];
            tagInfo = {};
          } else {
            tagInfo.startIdx = i - num;
            tagInfo.startStr = matchArr[2 * tagInfoArr.length];
          }
          num += 1;
        }
        let showCharArr = str.replace(regexp, "").split("");
        let printerArray = [];
        for (let i = 1; i <= showCharArr.length; i++) {
          let temp = showCharArr.join("").slice(0, i);
          let addLen = 0;
          for (let j = 0; j < tagInfoArr.length; j++) {
            let tagInfo = tagInfoArr[j];
            let start = tagInfo.startIdx;
            let end = tagInfo.endtIdx;
            if (i > start && i <= end) {
              temp = temp.slice(0, start + addLen) + tagInfo.startStr + temp.slice(start + addLen) + tagInfo.endStr;
              addLen += tagInfo.startStr.length + tagInfo.endStr.length;
            } else if (i > end) {
              temp = temp.slice(0, start + addLen) + tagInfo.startStr + temp.slice(start + addLen, end + addLen) + tagInfo.endStr + temp.slice(end + addLen);
              addLen += tagInfo.startStr.length + tagInfo.endStr.length;
            }
          }
          printerArray.unshift(temp);
        }
        this.printerTimer && clearInterval(this.printerTimer);
        this.printerTimer = setInterval(() => {
          printerArray.length ? this.richText.string = printerArray.pop() : this.printerTimer && clearInterval(this.printerTimer);
        }, 50);
      }
    };
    __decorate([ property({
      type: cc.Enum(LaeblType),
      tooltip: false
    }) ], Priter.prototype, "labelType", void 0);
    __decorate([ property({
      type: cc.Label,
      visible() {
        return this.labelType == LaeblType.Label;
      }
    }) ], Priter.prototype, "label", void 0);
    __decorate([ property({
      type: cc.RichText,
      visible() {
        return this.labelType == LaeblType.RichText;
      }
    }) ], Priter.prototype, "richText", void 0);
    __decorate([ property({
      type: cc.RichText,
      visible() {
        return this.labelType == LaeblType.RichText;
      }
    }) ], Priter.prototype, "richTextEditBox", void 0);
    Priter = __decorate([ ccclass("Priter") ], Priter);
    exports.Priter = Priter;
    cc._RF.pop();
  }, {} ],
  PriorityQueue: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "f2318nn5GJChLoRevUhhLkg", "PriorityQueue");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.PriorityElement = void 0;
    var PriorityElement = function() {
      function PriorityElement(data, priority) {
        this.data = data;
        this.priority = priority;
      }
      return PriorityElement;
    }();
    exports.PriorityElement = PriorityElement;
    var PriorityQueue = function() {
      function PriorityQueue() {
        this.queue = new Array(32);
        this._size = 0;
      }
      Object.defineProperty(PriorityQueue.prototype, "size", {
        get: function() {
          return this._size;
        },
        enumerable: false,
        configurable: true
      });
      PriorityQueue.prototype.hasElement = function(t) {
        for (var _i = 0, _a = this.queue; _i < _a.length; _i++) {
          var e = _a[_i];
          if (e.data === t) return true;
        }
        return false;
      };
      PriorityQueue.prototype.enqueue = function(e, priority) {
        void 0 === priority && (priority = 0);
        this._size > this.queue.length && this._expand();
        this.queue[this._size++] = new PriorityElement(e, priority);
        this.upAdjust();
      };
      PriorityQueue.prototype.dequeue = function() {
        if (this._size <= 0) return null;
        var head = this.queue[0];
        this.queue[0] = this.queue[--this._size];
        this.downAdjust();
        return head.data;
      };
      PriorityQueue.prototype.clear = function() {
        this.queue = [];
        this._size = 0;
      };
      PriorityQueue.prototype.upAdjust = function() {
        var childIndex = this._size - 1;
        var parentIndex = Math.floor(childIndex / 2);
        var tmp = this.queue[childIndex];
        while (childIndex > 0 && tmp.priority > this.queue[parentIndex].priority) {
          this.queue[childIndex] = this.queue[parentIndex];
          childIndex = parentIndex;
          parentIndex = Math.floor(parentIndex / 2);
        }
        this.queue[childIndex] = tmp;
      };
      PriorityQueue.prototype.downAdjust = function() {
        var parentIndex = 0;
        var tmp = this.queue[parentIndex];
        var childIndex = 1;
        while (childIndex < this._size) {
          childIndex + 1 < this._size && this.queue[childIndex + 1].priority > this.queue[childIndex].priority && childIndex++;
          if (tmp.priority >= this.queue[childIndex].priority) break;
          this.queue[parentIndex] = this.queue[childIndex];
          parentIndex = childIndex;
          childIndex = 2 * childIndex + 1;
        }
        this.queue[parentIndex] = tmp;
      };
      PriorityQueue.prototype._expand = function() {
        var newSize = Math.round(1.2 * this.queue.length) + 1;
        var oldQueue = this.queue;
        this.queue = new Array(newSize);
        for (var i = 0; i < oldQueue.length; i++) this.queue[i] = oldQueue[i];
      };
      PriorityQueue.prototype.toString = function() {
        var s = "";
        for (var i = 0; i < this._size; i++) {
          var data = this.queue[i].data;
          data.toString ? s += data.toString() : s += "object" === typeof data ? JSON.stringify(data) : data;
        }
        return s;
      };
      return PriorityQueue;
    }();
    exports.default = PriorityQueue;
    cc._RF.pop();
  }, {} ],
  PriorityStack: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "9ed15uYIzxGna5Bj3+zkuo8", "PriorityStack");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var PriorityQueue_1 = require("./PriorityQueue");
    var PriorityStack = function() {
      function PriorityStack(compare) {
        this.compare = function(a, b) {
          return a === b;
        };
        this.stack = new Array();
        this._size = 0;
        this.compare = compare;
      }
      Object.defineProperty(PriorityStack.prototype, "size", {
        get: function() {
          return this._size;
        },
        enumerable: false,
        configurable: true
      });
      PriorityStack.prototype.clear = function() {
        this.stack.length = 0;
        this._size = 0;
        return true;
      };
      PriorityStack.prototype.getTopEPriority = function() {
        if (this.stack.length <= 0) return -1;
        return this.stack[this.stack.length - 1].priority;
      };
      PriorityStack.prototype.getTopElement = function() {
        if (this.stack.length <= 0) return null;
        return this.stack[this.stack.length - 1].data;
      };
      PriorityStack.prototype.getElements = function() {
        var elements = [];
        for (var _i = 0, _a = this.stack; _i < _a.length; _i++) {
          var e = _a[_i];
          elements.push(e.data);
        }
        return elements;
      };
      PriorityStack.prototype.push = function(e, priority) {
        void 0 === priority && (priority = 0);
        this.stack.push(new PriorityQueue_1.PriorityElement(e, priority));
        this._size++;
        this._adjust();
      };
      PriorityStack.prototype.pop = function() {
        if (this.stack.length <= 0) return null;
        this._size--;
        return this.stack.pop().data;
      };
      PriorityStack.prototype._adjust = function() {
        for (var i = this.stack.length - 1; i > 0; i--) this.stack[i].priority < this.stack[i - 1].priority && this._swap(i, i - 1);
      };
      PriorityStack.prototype._swap = function(a, b) {
        var tmp = this.stack[a];
        this.stack[a] = this.stack[b];
        this.stack[b] = tmp;
      };
      PriorityStack.prototype.hasElement = function(t) {
        for (var _i = 0, _a = this.stack; _i < _a.length; _i++) {
          var e = _a[_i];
          if (this.compare(e.data, t)) return true;
        }
        return false;
      };
      PriorityStack.prototype.remove = function(t) {
        for (var i = this.stack.length - 1; i >= 0; i--) if (this.compare(this.stack[i].data, t)) {
          this.stack.splice(i, 1);
          this._size--;
          return true;
        }
        return false;
      };
      return PriorityStack;
    }();
    exports.default = PriorityStack;
    cc._RF.pop();
  }, {
    "./PriorityQueue": "PriorityQueue"
  } ],
  PropBind: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "2f9f8Tv5WdH8a3E1C7Bm4Ro", "PropBind");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var PropBind = function() {
      function PropBind() {}
      PropBind.prototype.bind = function(name, callback) {};
      return PropBind;
    }();
    exports.default = PropBind;
    cc._RF.pop();
  }, {} ],
  PropController: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "9c55bh8k9BD0JhzsvfCJYNE", "PropController");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.NodePathType = void 0;
    var PropSelector_1 = require("./PropSelector");
    var NodePathType;
    (function(NodePathType) {
      NodePathType[NodePathType["Name"] = 0] = "Name";
      NodePathType[NodePathType["SiblingIndex"] = 1] = "SiblingIndex";
    })(NodePathType = exports.NodePathType || (exports.NodePathType = {}));
    cc["NodePathType"] = NodePathType;
    var _a = cc._decorator, ccclass = _a.ccclass, executeInEditMode = _a.executeInEditMode, menu = _a.menu, inspector = _a.inspector, property = _a.property;
    var PropController = function(_super) {
      __extends(PropController, _super);
      function PropController() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.nodePathType = NodePathType.SiblingIndex;
        _this.open = true;
        _this._uid = "";
        _this._state = 0;
        _this._states = [];
        _this.propertyJson = "";
        return _this;
      }
      PropController_1 = PropController;
      Object.defineProperty(PropController.prototype, "uid", {
        get: function() {
          return this._uid;
        },
        set: function(val) {
          this._uid = val;
          this._refreshIdEnum();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PropController.prototype, "state", {
        get: function() {
          return this._state;
        },
        set: function(val) {
          this._state = val;
          this.doControl(val);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(PropController.prototype, "states", {
        get: function() {
          return this._states;
        },
        set: function(states) {
          this._states = states;
          this._refresh();
        },
        enumerable: false,
        configurable: true
      });
      PropController.prototype.onLoad = function() {
        this.open = false;
        this._refresh();
        this._refreshIdEnum();
      };
      PropController.prototype.start = function() {};
      PropController.prototype.doControl = function(type) {
        var t = type;
        var ctrl = JSON.parse(this.propertyJson);
        var map = ctrl[t];
        for (var path in map) {
          var paths = path.split(":");
          var node = null;
          switch (+paths[0]) {
           case NodePathType.Name:
            node = cc.find(paths[1], this.node);
            break;

           case NodePathType.SiblingIndex:
            node = this._getNodeBySiblingIndex(paths[1], this.node);
          }
          if (!node) {
            cc.warn("find node faild, path:", path);
            continue;
          }
          var nodeProps = map[path];
          for (var key in nodeProps) {
            var func = _localSetFunc[key];
            if (!func) continue;
            func(node, nodeProps[key]);
          }
        }
      };
      PropController.prototype._getNodeBySiblingIndex = function(path, node) {
        path = "/" == path[0] ? path.substring(1) : path;
        for (var _i = 0, _a = path.split("/"); _i < _a.length; _i++) {
          var e = _a[_i];
          node = node.children[+e];
        }
        return node;
      };
      PropController.prototype._refresh = function() {
        var array;
        false;
      };
      PropController.prototype._refreshIdEnum = function() {
        var coms;
        var array;
        false;
      };
      var PropController_1;
      __decorate([ property({
        type: cc.Enum(NodePathType),
        tooltip: "Name: \u6839\u636enode name\u4fdd\u5b58, SiblingIndex: \u6839\u636enode \u5728children\u7684index\u4fdd\u5b58"
      }) ], PropController.prototype, "nodePathType", void 0);
      __decorate([ property({
        tooltip: "\u662f\u5426\u542f\u7528\u63a7\u5236\u5668"
      }) ], PropController.prototype, "open", void 0);
      __decorate([ property({
        serializable: true
      }) ], PropController.prototype, "_uid", void 0);
      __decorate([ property ], PropController.prototype, "uid", null);
      __decorate([ property({
        type: cc.Enum({})
      }) ], PropController.prototype, "_state", void 0);
      __decorate([ property({
        type: cc.Enum({})
      }) ], PropController.prototype, "state", null);
      __decorate([ property ], PropController.prototype, "_states", void 0);
      __decorate([ property([ cc.String ]) ], PropController.prototype, "states", null);
      __decorate([ property() ], PropController.prototype, "propertyJson", void 0);
      PropController = PropController_1 = __decorate([ ccclass, executeInEditMode, menu("i18n:\u72b6\u6001\u63a7\u5236/PropController"), inspector("packages://propcontroller/dist/inspector.js") ], PropController);
      return PropController;
    }(cc.Component);
    exports.default = PropController;
    function _setPosition(node, prop) {
      node.setPosition(prop);
    }
    function _setColor(node, prop) {
      node.color = new cc.Color(prop.r, prop.g, prop.b);
    }
    function _setSacle(node, prop) {
      node.scaleX = prop.scaleX;
      node.scaleY = prop.scaleY;
    }
    function _setRotation(node, prop) {
      node.angle = prop;
    }
    function _setOpacity(node, prop) {
      node.opacity = prop;
    }
    function _setSlew(node, prop) {
      node.skewX = prop.skewX;
      node.skewY = prop.skewY;
    }
    function _setSize(node, prop) {
      node.setContentSize(prop);
    }
    function _setAnchor(node, prop) {
      node.anchorX = prop.anchorX;
      node.anchorY = prop.anchorY;
    }
    function _setActive(node, prop) {
      node.active = prop;
    }
    function _setLabelString(node, prop) {
      node.getComponent(cc.Label).string = prop;
    }
    function _setAll(node, prop) {
      var nodeProp = prop["node"];
      node.active = nodeProp.active;
      node.setPosition(nodeProp.position);
      node.angle = nodeProp.angle;
      node.scaleX = nodeProp.scale.scaleX;
      node.scaleY = nodeProp.scale.scaleY;
      node.anchorX = nodeProp.anchor.anchorX;
      node.anchorY = nodeProp.anchor.anchorY;
      node.setContentSize(nodeProp.size);
      node.color = new cc.Color(nodeProp.color.r, nodeProp.color.g, nodeProp.color.b);
      node.opacity = nodeProp.opacity;
      for (var comName in prop.coms) {
        var comProp = prop.coms[comName];
        comName = comName.replace("_", ".");
        var com = node.getComponent(comName);
        for (var key in comProp) {
          if (key.startsWith("_")) continue;
          com[key] = comProp[key];
        }
      }
    }
    function _setSpriteTexture(node, prop) {
      var _a, _b;
      var url = null !== (_a = prop.url) && void 0 !== _a ? _a : "";
      var uuid = null !== (_b = prop.uuid) && void 0 !== _b ? _b : "";
      if (url.includes("resources")) {
        url = url.replace("resources/", "");
        url = url.split(".")[0];
      }
      false;
      cc.resources.load(url, cc.Texture2D, function(error, data) {
        if (error) {
          Editor.warn("PropController  load sprite texture faild", url, error);
          return;
        }
        node.getComponent(cc.Sprite).spriteFrame = new cc.SpriteFrame(data);
      });
    }
    var _localSetFunc = {};
    function _regiestSetFunction(id, func) {
      _localSetFunc[id] && cc.warn("");
      _localSetFunc[id] = func;
    }
    _regiestSetFunction(PropSelector_1.PropEmum.All, _setAll);
    _regiestSetFunction(PropSelector_1.PropEmum.Active, _setActive);
    _regiestSetFunction(PropSelector_1.PropEmum.Position, _setPosition);
    _regiestSetFunction(PropSelector_1.PropEmum.Color, _setColor);
    _regiestSetFunction(PropSelector_1.PropEmum.Scale, _setSacle);
    _regiestSetFunction(PropSelector_1.PropEmum.Rotation, _setRotation);
    _regiestSetFunction(PropSelector_1.PropEmum.Opacity, _setOpacity);
    _regiestSetFunction(PropSelector_1.PropEmum.Slew, _setSlew);
    _regiestSetFunction(PropSelector_1.PropEmum.Size, _setSize);
    _regiestSetFunction(PropSelector_1.PropEmum.Anchor, _setAnchor);
    _regiestSetFunction(PropSelector_1.PropEmum.Label_String, _setLabelString);
    _regiestSetFunction(PropSelector_1.PropEmum.Sprite_Texture, _setSpriteTexture);
    cc._RF.pop();
  }, {
    "./PropSelector": "PropSelector"
  } ],
  PropSelector: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "95cf9sVxtJHbIz3btfe766G", "PropSelector");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.PropEmum = void 0;
    var _a = cc._decorator, ccclass = _a.ccclass, executeInEditMode = _a.executeInEditMode, menu = _a.menu, property = _a.property;
    var PropEmum;
    (function(PropEmum) {
      PropEmum[PropEmum["All"] = 0] = "All";
      PropEmum[PropEmum["Active"] = 1] = "Active";
      PropEmum[PropEmum["Position"] = 2] = "Position";
      PropEmum[PropEmum["Rotation"] = 3] = "Rotation";
      PropEmum[PropEmum["Scale"] = 4] = "Scale";
      PropEmum[PropEmum["Anchor"] = 5] = "Anchor";
      PropEmum[PropEmum["Size"] = 6] = "Size";
      PropEmum[PropEmum["Color"] = 7] = "Color";
      PropEmum[PropEmum["Opacity"] = 8] = "Opacity";
      PropEmum[PropEmum["Slew"] = 9] = "Slew";
      PropEmum[PropEmum["Label_String"] = 10] = "Label_String";
      PropEmum[PropEmum["Sprite_Texture"] = 11] = "Sprite_Texture";
    })(PropEmum = exports.PropEmum || (exports.PropEmum = {}));
    cc["PropEmum"] = PropEmum;
    var ControllerId = cc.Enum({});
    var PropSelector = function(_super) {
      __extends(PropSelector, _super);
      function PropSelector() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.props = [ 0 ];
        return _this;
      }
      __decorate([ property({
        type: [ cc.Enum(PropEmum) ],
        tooltip: "\u88ab\u63a7\u5236\u7684\u5c5e\u6027"
      }) ], PropSelector.prototype, "props", void 0);
      PropSelector = __decorate([ ccclass, menu("i18n:\u72b6\u6001\u63a7\u5236/PropSelector"), executeInEditMode ], PropSelector);
      return PropSelector;
    }(cc.Component);
    exports.default = PropSelector;
    cc._RF.pop();
  }, {} ],
  QuadTree: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "97092zpFuhN/oWHIMkF7jei", "QuadTree");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Bound = void 0;
    var Bound = function() {
      function Bound(x, y, width, height, uid) {
        void 0 === uid && (uid = "");
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.uid = uid;
      }
      return Bound;
    }();
    exports.Bound = Bound;
    var Quadtree = function() {
      function Quadtree(bound, maxObjects, maxLevels, level) {
        this._maxObject = 10;
        this._maxLevel = 4;
        this._level = 0;
        this._bound = null;
        this._objects = [];
        this._nodes = [];
        this._bound = bound;
        this._maxObject = maxObjects || this._maxObject;
        this._maxLevel = maxLevels || this._maxLevel;
        this._level = level || this._level;
      }
      Quadtree.prototype.split = function() {
        var nextLevel = this._level + 1;
        var subWidth = this._bound.width / 2;
        var subHeight = this._bound.height / 2;
        var x = this._bound.x;
        var y = this._bound.y;
        this._nodes[0] = new Quadtree({
          uid: nextLevel + "-top-right",
          x: x + subWidth,
          y: y,
          width: subWidth,
          height: subHeight
        }, this._maxObject, this._maxLevel, nextLevel);
        this._nodes[1] = new Quadtree({
          uid: nextLevel + "-top-left",
          x: x,
          y: y,
          width: subWidth,
          height: subHeight
        }, this._maxObject, this._maxLevel, nextLevel);
        this._nodes[2] = new Quadtree({
          uid: nextLevel + "-bottom-left",
          x: x,
          y: y + subHeight,
          width: subWidth,
          height: subHeight
        }, this._maxObject, this._maxLevel, nextLevel);
        this._nodes[3] = new Quadtree({
          uid: nextLevel + "-bottom-right",
          x: x + subWidth,
          y: y + subHeight,
          width: subWidth,
          height: subHeight
        }, this._maxObject, this._maxLevel, nextLevel);
      };
      Quadtree.prototype.getIndex = function(bound) {
        var indexes = [], verticalMidpoint = this._bound.x + this._bound.width / 2, horizontalMidpoint = this._bound.y + this._bound.height / 2;
        var startIsNorth = bound.y < horizontalMidpoint, startIsWest = bound.x < verticalMidpoint, endIsEast = bound.x + bound.width > verticalMidpoint, endIsSouth = bound.y + bound.height > horizontalMidpoint;
        startIsNorth && endIsEast && indexes.push(0);
        startIsWest && startIsNorth && indexes.push(1);
        startIsWest && endIsSouth && indexes.push(2);
        endIsEast && endIsSouth && indexes.push(3);
        return indexes;
      };
      Quadtree.prototype.insert = function(bound) {
        var i = 0;
        var indexes = [];
        if (this._nodes.length) {
          indexes = this.getIndex(bound);
          for (i = 0; i < indexes.length; i++) this._nodes[indexes[i]].insert(bound);
          return;
        }
        this._objects.push(bound);
        if (this._objects.length > this._maxObject && this._level < this._maxLevel) {
          this._nodes.length || this.split();
          for (i = 0; i < this._objects.length; i++) {
            indexes = this.getIndex(this._objects[i]);
            for (var k = 0; k < indexes.length; k++) this._nodes[indexes[k]].insert(this._objects[i]);
          }
          this._objects = [];
        }
      };
      Quadtree.prototype.retrieve = function(bound) {
        var indexes = this.getIndex(bound), returnObjects = this._objects;
        if (this._nodes.length) for (var i = 0; i < indexes.length; i++) returnObjects = returnObjects.concat(this._nodes[indexes[i]].retrieve(bound));
        returnObjects = returnObjects.filter(function(item, index) {
          return returnObjects.indexOf(item) >= index;
        });
        return returnObjects;
      };
      Quadtree.prototype.clear = function() {
        this._objects = [];
        for (var i = 0; i < this._nodes.length; i++) this._nodes.length && this._nodes[i].clear();
        this._nodes = [];
      };
      return Quadtree;
    }();
    exports.default = Quadtree;
    cc._RF.pop();
  }, {} ],
  Queue: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "146d9Q6AJVLm5Z5V9zs9sHL", "Queue");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var Queue = function() {
      function Queue() {
        this.count = 0;
        this.lowestCount = 0;
        this.items = {};
      }
      Queue.prototype.enqueue = function(element) {
        this.items[this.count] = element;
        this.count++;
      };
      Queue.prototype.dequeue = function() {
        if (this.isEmpty()) return;
        var result = this.items[this.lowestCount];
        delete this.items[this.lowestCount];
        this.lowestCount++;
        return result;
      };
      Queue.prototype.peek = function() {
        if (this.isEmpty()) return;
        return this.items[this.lowestCount];
      };
      Queue.prototype.isEmpty = function() {
        return 0 === this.size();
      };
      Queue.prototype.clear = function() {
        this.items = {};
        this.count = 0;
        this.lowestCount = 0;
      };
      Queue.prototype.size = function() {
        return this.count - this.lowestCount;
      };
      Queue.prototype.toString = function() {
        if (this.isEmpty()) return "";
        var objString = "" + this.items[this.lowestCount];
        for (var i = this.lowestCount + 1; i < this.count; i++) objString = objString + "," + this.items[i];
        return objString;
      };
      return Queue;
    }();
    exports.default = Queue;
    cc._RF.pop();
  }, {} ],
  RawItem: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "ba46bd5sDpHoJSuHZGhdI7j", "RawItem");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const lodash_1 = require("lodash");
    const ListItem_1 = require("../../Common/Components/ListItem");
    const CommonUtils_1 = require("../../Common/Utils/CommonUtils");
    const GlobalData_1 = require("../../Config/GlobalData");
    const TableKey_1 = require("../../Config/TableKey");
    const Game_1 = require("../../Logic/Game");
    const UIWorkDesk_1 = require("../../UIScript/UIWorkDesk");
    const {ccclass: ccclass, property: property} = cc._decorator;
    let RawItem = class RawItem extends ListItem_1.default {
      constructor() {
        super(...arguments);
        this.count = null;
        this.itemData = null;
        this.desk = null;
        this.markTime = null;
      }
      onLoad() {
        super.onLoad();
      }
      start() {
        this.registerEvent();
      }
      registerEvent() {
        this.node.on(cc.Node.EventType.TOUCH_START, this.touchStart, this);
        this.node.on(cc.Node.EventType.TOUCH_MOVE, this.desk.dragMove.bind(this.desk), this);
        this.node.on(cc.Node.EventType.TOUCH_END, this.desk.dragEnd.bind(this.desk), this);
        this.node.on(cc.Node.EventType.TOUCH_CANCEL, this.desk.dragEnd.bind(this.desk), this);
      }
      unRegisterEvent() {
        this.node.off(cc.Node.EventType.TOUCH_START, this.touchStart, this);
        this.node.off(cc.Node.EventType.TOUCH_MOVE, this.desk.dragMove.bind(this.desk), this);
        this.node.off(cc.Node.EventType.TOUCH_END, this.desk.dragEnd.bind(this.desk), this);
        this.node.off(cc.Node.EventType.TOUCH_CANCEL, this.desk.dragEnd.bind(this.desk), this);
      }
      update(dt) {
        if (!this.markTime || !this.itemData || !this.desk || !this.home) return;
        if (new Date().getTime() - this.markTime > 1e3 * this.storeData.makeEffic && this.itemData.count < this.storeData.makeMax) {
          this.updateRawCount(1);
          this.markTime = new Date().getTime();
        }
      }
      touchStart(event) {
        this.desk.dragNode(event, this, UIWorkDesk_1.DragType.Raw);
      }
      onDestroy() {
        super.onDestroy();
        this.unRegisterEvent();
      }
      onClickThis() {
        super.onClickThis();
        console.log("RawItem onClickThis");
      }
      initUi(data, desk) {
        this.itemData = data;
        this.desk = desk;
        this.updateRawCount(0);
        this.title.getComponent(cc.Label).string = data["name"];
        CommonUtils_1.CommonUtils.setItemSpriteFrame(this.icon, `${GlobalData_1.GlobalData.rawPath}${data["ID"]}`);
      }
      updateRawCount(val) {
        let count = lodash_1.clamp(this.itemData.count + val, 0, this.storeData.makeMax + 1);
        this.count.string = `+${count}`;
        if (count !== this.itemData.count) {
          Game_1.default.dbMgr.update(TableKey_1.TableKey.MATE, {
            count: count
          }, {
            uid: this.itemData.uid
          });
          this.itemData.count = count;
          count < this.storeData.makeMax && null === this.markTime && (this.markTime = new Date().getTime());
        }
      }
      get home() {
        return this.desk.top.home;
      }
      get storeData() {
        return this.home.storeData;
      }
    };
    __decorate([ property(cc.Label) ], RawItem.prototype, "count", void 0);
    RawItem = __decorate([ ccclass ], RawItem);
    exports.default = RawItem;
    cc._RF.pop();
  }, {
    "../../Common/Components/ListItem": "ListItem",
    "../../Common/Utils/CommonUtils": "CommonUtils",
    "../../Config/GlobalData": "GlobalData",
    "../../Config/TableKey": "TableKey",
    "../../Logic/Game": "Game",
    "../../UIScript/UIWorkDesk": "UIWorkDesk",
    lodash: 1
  } ],
  RawMaterial: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "134487N1MJIzIe1T0+0PwIs", "RawMaterial");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.RoleBuyTalk = exports.BuildData = exports.BackpackList = exports.OrnamentsList = exports.TableList = exports.RecipeList = exports.BackPackModule = exports.BackpackType = exports.RecipeModule = exports.RawMaterial = void 0;
    const UIBuild_1 = require("../UIScript/UIBuild");
    exports.RawMaterial = [ {
      ID: 2001,
      name: "\u6c34",
      price: 0,
      intro: "\u4e00\u4efd\u7eaf\u51c0\u6c34\uff0c\u4e07\u7269\u7684\u8d77\u6e90,\u4e0d\u53ef\u51fa\u552e",
      type: "item_raw",
      sell: 0
    }, {
      ID: 2002,
      name: "\u5496\u5561\u8c46",
      price: 0,
      intro: "\u70d8\u7119\u597d\u7684\u5496\u5561\u8c46,\u4e0d\u53ef\u51fa\u552e",
      type: "item_raw",
      sell: 0
    }, {
      ID: 2003,
      name: "\u51b0",
      price: 0,
      intro: "\u628a\u90a3\u4e2a\u7eaf\u51c0\u6c34\u653e\u8fdb\u5236\u51b0\u673a\u91cc\u5f97\u6765\u7684,\u4e0d\u53ef\u51fa\u552e",
      type: "item_raw",
      sell: 0
    }, {
      ID: 2004,
      name: "\u725b\u5976",
      price: 20,
      intro: "\u7eaf\u725b\u5976\uff0c\u7edd\u5bf9\u6ca1\u6709\u4efb\u4f55\u6dfb\u52a0\uff0c\u4f60\u9700\u8981\u5c3d\u5feb\u4f7f\u7528,\u4e0d\uff01\u7136\uff01\u5c31\uff01\u4f1a\uff01\u574f\uff01\u6389\uff01,\u4e0d\u53ef\u51fa\u552e",
      type: "item_raw",
      sell: 0
    }, {
      ID: 2005,
      name: "\u5de7\u514b\u529b",
      price: 50,
      intro: "\u7eaf\u53ef\u53ef\u8102\u7684\u5de7\u514b\u529b\uff0c\u5077\u5403\u4e00\u70b9\u6ca1\u4eba\u53d1\u73b0\u5427\uff1f\u4e0d\u53ef\u51fa\u552e",
      type: "item_raw",
      sell: 0
    }, {
      ID: 2006,
      name: "\u6930\u5b50",
      price: 80,
      intro: "\u80af\u5b9a\u662f\u4ece\u5f88\u70ed\u7684\u5730\u65b9\u8fd0\u8fc7\u6765\u7684\uff0c\u4e0a\u9762\u8fd8\u6709\u9633\u5149\u548c\u6d77\u5cb8\u7ebf\u5347\u8d77\u7684\u5473\u9053,\u4e0d\u53ef\u51fa\u552e",
      type: "item_raw",
      sell: 0
    }, {
      ID: 2007,
      name: "\u5976\u6cb9\u74f6",
      price: 150,
      intro: "\u4e00\u74f6\u55b5\u9020\u690d\u7269\u5976\u6cb9,\u4e0d\u53ef\u51fa\u552e",
      type: "item_raw",
      sell: 0
    }, {
      ID: 2008,
      name: "\u7126\u7cd6",
      price: 130,
      intro: "\u767d\u7802\u7cd6\u71ac\u716e\u540e\u7126\u5316\u7684\u996e\u6599\u8c03\u5473\u54c1\uff0c\u5f88\u8bb2\u7a76\u706b\u5019,\u4e0d\u53ef\u51fa\u552e",
      type: "item_raw",
      sell: 0
    } ];
    exports.RecipeModule = [ {
      name: "\u914d\u65b9",
      color: "C38460"
    } ];
    exports.BackpackType = [ [ {
      name: "\u539f\u6750\u6599",
      color: "D6EE92",
      color_unSelected: "B6C194"
    }, {
      name: "\u6742\u7269",
      color: "D6EE92",
      color_unSelected: "B6C194"
    } ], [ {
      name: "\u5934\u9970",
      color: "EEAD92",
      color_unSelected: "C68282"
    }, {
      name: "\u8863\u670d",
      color: "EEAD92",
      color_unSelected: "C68282"
    }, {
      name: "\u978b\u5b50",
      color: "EEAD92",
      color_unSelected: "C68282"
    } ], [ {
      name: "\u684c\u5b50",
      color: "EED492",
      color_unSelected: "C1AA94"
    }, {
      name: "\u6446\u4ef6",
      color: "EED492",
      color_unSelected: "C1AA94"
    }, {
      name: "\u5899\u9970",
      color: "EED492",
      color_unSelected: "C1AA94"
    } ] ];
    exports.BackPackModule = [ {
      name: "\u9053\u5177",
      color: "A3C360"
    }, {
      name: "\u8863\u6a71",
      color: "C36060"
    }, {
      name: "\u5bb6\u5177",
      color: "C39660"
    } ];
    exports.RecipeList = [ {
      ID: 1001,
      name: "%s\u6c34",
      name_e: "water",
      raw1: 2001,
      raw2: "",
      raw3: "",
      raw4: "",
      raw5: "",
      raw6: "",
      coldDrink: true,
      price: 2,
      resPath: 1001,
      cupType: 1,
      tumbler_f: "glass10",
      tumbler_b: "glass11",
      intro: "\u4e00\u676f\u6c34",
      type: "formula",
      subType: "cofee",
      unlock: "lock"
    }, {
      ID: 1002,
      name: "\u610f\u5f0f\u6d53\u7f29\u5496\u5561",
      name_e: "Espresso",
      raw1: 2002,
      raw2: "",
      raw3: "",
      raw4: "",
      raw5: "",
      raw6: "",
      coldDrink: "",
      price: 3,
      resPath: 1002,
      cupType: 3,
      tumbler_f: "glass30",
      tumbler_b: "glass31",
      intro: "\u7ecf\u5178\u7684\u6d53\u7f29\u5496\u5561\uff0c\u5982\u679c\u76f4\u996e\u5efa\u8bae\u52a0\u7cd6",
      type: "formula",
      subType: "cofee",
      unlock: "lock"
    }, {
      ID: 1003,
      name: "%s\u7f8e\u5f0f\u5496\u5561",
      name_e: "Americano",
      raw1: 2001,
      raw2: 2002,
      raw3: "",
      raw4: "",
      raw5: "",
      raw6: "",
      coldDrink: true,
      price: 4,
      resPath: 1003,
      cupType: 1,
      tumbler_f: "glass10",
      tumbler_b: "glass11",
      intro: "\u7ecf\u5178\u597d\u559d\uff01",
      type: "formula",
      subType: "cofee",
      unlock: "lock"
    }, {
      ID: 1004,
      name: "%s\u62ff\u94c1\u5496\u5561",
      name_e: "latte",
      raw1: 2004,
      raw2: 2002,
      raw3: "",
      raw4: "",
      raw5: "",
      raw6: "",
      coldDrink: true,
      price: 5,
      resPath: 1004,
      cupType: 1,
      tumbler_f: "glass10",
      tumbler_b: "glass11",
      intro: "\u7ecf\u5178\u7684\u62ff\u94c1\u5496\u5561\uff0c\u5728\u5f88\u591a\u5730\u65b9\u90fd\u662f\u62db\u724c",
      type: "formula",
      subType: "cofee",
      unlock: "lock"
    }, {
      ID: 1005,
      name: "\u6469\u5361\u5496\u5561",
      name_e: "Mocha",
      raw1: 2004,
      raw2: 2002,
      raw3: 2005,
      raw4: "",
      raw5: "",
      raw6: "",
      coldDrink: "",
      price: 9,
      resPath: 1005,
      cupType: 2,
      tumbler_f: "glass20",
      tumbler_b: "glass21",
      intro: "\u4e00\u79cd\u53e4\u8001\u7684\u5496\u5561",
      type: "formula",
      subType: "cofee",
      unlock: "lock"
    }, {
      ID: 1006,
      name: "\u70ed\u5de7\u514b\u529b",
      name_e: "Hot_chocolate",
      raw1: 2005,
      raw2: 2004,
      raw3: "",
      raw4: "",
      raw5: "",
      raw6: "",
      coldDrink: "",
      price: 6,
      resPath: 1006,
      cupType: 2,
      tumbler_f: "glass20",
      tumbler_b: "glass21",
      intro: "\u788e\u788e\u7684\u5de7\u514b\u529b\u52a0\u4e0a\u725b\u5976\u540e\u4e00\u8d77\u52a0\u70ed\u5f62\u6210\u4e86\u8fd9\u79cd\u5947\u5999\u4e1d\u6ed1\u7684\u996e\u54c1",
      type: "formula",
      subType: "cofee",
      unlock: "lock"
    }, {
      ID: 1007,
      name: "%s\u6930\u6c41",
      name_e: "Coconut",
      raw1: 2006,
      raw2: "",
      raw3: "",
      raw4: "",
      raw5: "",
      raw6: "",
      coldDrink: true,
      price: 5,
      resPath: 1007,
      cupType: 1,
      tumbler_f: "glass10",
      tumbler_b: "glass11",
      intro: "\u6930\u5b50~\u597d\u559d\u7684\u6930\u5b50~\n\u800c\u4e14\u7edd\u5bf9\u6ca1\u6709\u5151\u6c34",
      type: "formula",
      subType: "cofee",
      unlock: "lock"
    }, {
      ID: 1008,
      name: "\u6930\u6c41%s\u62ff\u94c1",
      name_e: "Coconut_latte",
      raw1: 2006,
      raw2: 2004,
      raw3: 2002,
      raw4: "",
      raw5: "",
      raw6: "",
      coldDrink: true,
      price: 10,
      resPath: 1008,
      cupType: 1,
      tumbler_f: "glass10",
      tumbler_b: "glass11",
      intro: "\u52a0\u5165\u4e86\u5976\u6cb9\u7684\u62ff\u94c1\u5496\u5561\uff0c\u8ba9\u53e3\u611f\u53d8\u5f97\u66f4\u52a0\u6e05\u723d",
      type: "formula",
      subType: "cofee",
      unlock: "lock"
    }, {
      ID: 1009,
      name: "\u5976\u6cb9%s\u62ff\u94c1",
      name_e: "Cream_latte",
      raw1: 2002,
      raw2: 2004,
      raw3: 2007,
      raw4: "",
      raw5: "",
      raw6: "",
      coldDrink: true,
      price: 13,
      resPath: 1009,
      cupType: 1,
      tumbler_f: "glass10",
      tumbler_b: "glass11",
      intro: "\u52a0\u5165\u4e86\u5976\u6cb9\u7684\u62ff\u94c1\u5496\u5561\uff0c\u8ba9\u53e3\u611f\u53d8\u5f97\u66f4\u52a0\u7ec6\u817b\u9999\u751c",
      type: "formula",
      subType: "cofee",
      unlock: "lock"
    }, {
      ID: 1010,
      name: "\u5976\u6cb9\u5de7\u514b\u529b",
      name_e: "Cream_chocolate",
      raw1: 2005,
      raw2: 2004,
      raw3: 2007,
      raw4: "",
      raw5: "",
      raw6: "",
      coldDrink: "",
      price: 14,
      resPath: 1010,
      cupType: 2,
      tumbler_f: "glass20",
      tumbler_b: "glass21",
      intro: "\u5947\u5999\u7684\u5e78\u798f\u6ce1\u6ce1",
      type: "formula",
      subType: "cofee",
      unlock: "lock"
    }, {
      ID: 1011,
      name: "\u7126\u7cd6\u7f8e\u5f0f",
      name_e: "Caramel_Americano",
      raw1: 2008,
      raw2: 2001,
      raw3: 2002,
      raw4: "",
      raw5: "",
      raw6: "",
      coldDrink: "",
      price: 12,
      resPath: 1011,
      cupType: 1,
      tumbler_f: "glass10",
      tumbler_b: "glass11",
      intro: "\u50cf\u8dc3\u52a8\u7740\u7684\u706b\u7cbe\u7075",
      type: "formula",
      subType: "cofee",
      unlock: "lock"
    }, {
      ID: 1012,
      name: "\u7126\u7cd6\u739b\u5947\u6735",
      name_e: "Caramel_macchiato",
      raw1: 2008,
      raw2: 2004,
      raw3: 2002,
      raw4: "",
      raw5: "",
      raw6: "",
      coldDrink: "",
      price: 12,
      resPath: 1012,
      cupType: 2,
      tumbler_f: "glass20",
      tumbler_b: "glass21",
      intro: "\u751c\u871c\u7684\u5370\u8bb0",
      type: "formula",
      subType: "cofee",
      unlock: "lock"
    } ];
    exports.TableList = [ {
      ID: 3001,
      name: "\u6728\u684c",
      price: 0,
      intro: "\u7528\u6728\u677f\u5236\u6210\u7684\u666e\u901a\u684c\u5b50",
      type: 1,
      offseter: "",
      rank: 1,
      area: 1,
      resPath: "img/table/",
      count: 1,
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": ""
    }, {
      ID: 3002,
      name: "\u539f\u6728\u684c",
      price: 100,
      intro: "\u9664\u4e86\u6253\u78e8\u4e4b\u5916\u6ca1\u6709\u6536\u53d6\u4efb\u4f55\u5176\u4ed6\u52a0\u5de5\u8d39",
      type: 1,
      offseter: "",
      rank: 1,
      area: 1,
      resPath: "img/table/",
      count: 0,
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": ""
    }, {
      ID: 3003,
      name: "\u539f\u91ce\u684c",
      price: 450,
      intro: "\u5e03\u7f6e\u6709\u4e00\u4e9b\u7267\u8349\u7684\u684c\u5b50\uff0c\u597d\u50cf\u662f\u771f\u7684\u8349",
      type: 1,
      offseter: "",
      rank: 2,
      area: 1,
      resPath: "img/table/",
      count: 0,
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": ""
    }, {
      ID: 3004,
      name: "\u77f3\u684c",
      price: 900,
      intro: "\u7528\u77f3\u5934\u62fc\u63a5\u6210\u7684\u684c\u5b50\uff0c\u7f1d\u9699\u8854\u63a5\u7684\u5f88\u597d",
      type: 1,
      offseter: "",
      rank: 3,
      area: 1,
      resPath: "img/table/",
      count: 0,
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": ""
    }, {
      ID: 3005,
      name: "\u67ab\u6728\u684c",
      price: 500,
      intro: "\u67ab\u6728\u684c\u5b50\uff0c\u767d\u767d\u51c0\u51c0\u7684",
      type: 1,
      offseter: "",
      rank: 2,
      area: 1,
      resPath: "img/table/",
      count: 0,
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": ""
    }, {
      ID: 3006,
      name: "\u6a59\u8272\u7530\u56ed\u684c",
      price: 470,
      intro: "\u7528\u7530\u56ed\u98ce\u683c\u7684\u684c\u5e03\u6765\u88c5\u9970",
      type: 1,
      offseter: "",
      rank: 2,
      area: 1,
      resPath: "img/table/",
      count: 0,
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": ""
    }, {
      ID: 3007,
      name: "\u84dd\u8272\u7530\u56ed\u684c",
      price: 470,
      intro: "\u7528\u7530\u56ed\u98ce\u683c\u7684\u684c\u5e03\u6765\u88c5\u9970",
      type: 1,
      offseter: "",
      rank: 2,
      area: 1,
      resPath: "img/table/",
      count: 0,
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": ""
    }, {
      ID: 3008,
      name: "\u7c89\u7ea2\u7530\u56ed\u684c",
      price: 470,
      intro: "\u7528\u7530\u56ed\u98ce\u683c\u7684\u684c\u5e03\u6765\u88c5\u9970",
      type: 1,
      offseter: "",
      rank: 2,
      area: 1,
      resPath: "img/table/",
      count: 0,
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": ""
    }, {
      ID: 3009,
      name: "\u7b26\u6587\u77f3\u684c",
      price: 6400,
      intro: "\u4e0d\u77e5\u9053\u54ea\u91cc\u6765\u7684\u7b26\u6587\u77f3\u5934\u88ab\u5f53\u6210\u684c\u5b50\u4e86\uff0c\u4e0d\u4f1a\u89e6\u53d1\u4ec0\u4e48\u7981\u5fcc\u7684\u9b54\u6cd5\u5427\uff1f",
      type: 1,
      offseter: "",
      rank: 8,
      area: 1,
      resPath: "img/table/",
      count: 0,
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": ""
    }, {
      ID: 3010,
      name: "\u957f\u684c",
      price: 1600,
      intro: "\u957f\u957f\u7684\u684c\u5b50\uff0c\u66f4\u591a\u7684\u7a7a\u95f4",
      type: 1,
      offseter: "",
      rank: 4,
      area: 1,
      resPath: "img/table/",
      count: 0,
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": ""
    }, {
      ID: 3011,
      name: "\u9886\u4e3b\u957f\u684c",
      price: 3600,
      intro: "\u636e\u8bf4\u662f\u9886\u4e3b\u540c\u6b3e\u684c\u5b50",
      type: 1,
      offseter: "",
      rank: 6,
      area: 1,
      resPath: "img/table/",
      count: 0,
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": ""
    }, {
      ID: 3012,
      name: "\u7ef8\u7f0e\u957f\u684c",
      price: 2700,
      intro: "\u843d\u5730\u7684\u7ef8\u7f0e\u8ba9\u8fd9\u4e2a\u684c\u5b50\u770b\u8d77\u6765\u975e\u5e38\u5962\u534e",
      type: 1,
      offseter: "",
      rank: 5,
      area: 1,
      resPath: "img/table/",
      count: 0,
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": ""
    }, {
      ID: 3013,
      name: "\u9152\u9986\u5c0f\u684c",
      price: 1630,
      intro: "\u770b\u6765\u8fd9\u91cc\u7ecf\u5386\u4e86\u4e00\u573a\u6218\u6597\uff0c\u5927\u5bb6\u90fd\u559d\u7684\u9169\u914a\u5927\u9189",
      type: 1,
      offseter: "",
      rank: 4,
      area: 1,
      resPath: "img/table/",
      count: 0,
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": ""
    } ];
    exports.OrnamentsList = [ {
      ID: 3101,
      name: "\u7eff\u690d\u76c6\u683d",
      price: 200,
      intro: "\u5e2e\u4f60\u51c0\u5316\u7a7a\u6c14",
      type: 6,
      offseter: "",
      rank: 1,
      area: 1,
      resPath: "img/ornaments/",
      count: 0,
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": ""
    }, {
      ID: 3102,
      name: "\u5473\u74f6\u9648\u5217\u67dc",
      price: 3200,
      intro: "\u9648\u5217\u4e86\u4e00\u4e9b\u7528\u4e8e\u5236\u4f5c\u7684\u74f6\u74f6\u7f50\u7f50",
      type: 2,
      offseter: "",
      rank: 4,
      area: 1,
      resPath: "img/ornaments/",
      count: 0,
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": "",
      "": ""
    } ];
    exports.BackpackList = [ [ [], [] ], [ [], [], [] ], [ [], [], [] ] ];
    exports.BuildData = [ {
      type: UIBuild_1.BuildType.table,
      val: "\u684c\u5b50",
      data: [],
      tableKey: "TABLE"
    }, {
      type: UIBuild_1.BuildType.ornaments,
      val: "\u6446\u4ef6",
      data: []
    }, {
      type: UIBuild_1.BuildType.wallDecoration,
      val: "\u5899\u9970",
      data: []
    }, {
      type: UIBuild_1.BuildType.special,
      val: "\u7279\u6b8a",
      data: []
    } ];
    exports.RoleBuyTalk = {
      "001": [ {
        ID: 1,
        talk: "\u5728\u5fd9\u4e48\uff0c\u6211\u60f3\u6765\u4e00\u676f%d"
      }, {
        ID: 2,
        talk: "\u55ef\u2026\u6765\u4e00\u676f%d\u5427"
      }, {
        ID: 3,
        talk: "\u6bcf\u5929\u90fd\u5728\u5237\u90a3\u4e9b\u6751\u5e84\u4f4e\u7ea7\u60ac\u8d4f\u4efb\u52a1\uff0c\u6211\u90fd\u8981\u65e0\u804a\u6b7b\u4e86\uff0c\u9ebb\u70e6\u7ed9\u6211\u6765\u4e00\u676f%d\u89e3\u89e3\u6e34\uff0c\u518d\u4e0d\u559d\u70b9\u4ec0\u4e48\u6211\u90fd\u8981\u53d8\u6210\u4f4e\u7ea7\u4efb\u52a1\u4e86"
      }, {
        ID: 4,
        talk: "\u5e2e\u5fd9\u641e\u4e00\u676f%d\uff0c\u4f60\u8fd9\u8fb9\u4e0d\u80fd\u7528\u5151\u6362\u5238\u652f\u4ed8\u4e48\uff0c\u771f\u5751\u554a"
      }, {
        ID: 5,
        talk: "%d\uff0c\u8c22\u8c22\uff0c\u901f\u5ea6\u8981\u5feb"
      }, {
        ID: 6,
        talk: "\u771f\u60f3\u7a0d\u5fae\u7a7f\u7684\u51c9\u5feb\u90a3\u4e48\u4e00\u4e9b\uff0c\u9501\u94fe\u7532\u4ec0\u4e48\u7684\uff0c\u5e2e\u5fd9\u641e\u4e00\u676f%d"
      }, {
        ID: 7,
        talk: "\u6765\u676f%d\uff0c\u4f60\u4eec\u4f1a\u51fa\u53bb\u73a9\u4e48\uff1f\u5ea6\u5047\u4ec0\u4e48\u7684\u2026\u53bb\u738b\u57ce\u770b\u770b\u5427\uff0c\u90a3\u8fb9\u7684\u4ef7\u683c\u4f1a\u8ba9\u4f60\u54ed\u51fa\u6765\u7684\uff0c\u9664\u4e86\u6ca1\u6709\u4f60\u8fd9\u4e2a\u2026\u80fd\u8ba9\u5634\u5df4\u82e6\u82e6\u7684\u996e\u6599"
      }, {
        ID: 8,
        talk: "\u6211\u6628\u5929\u559d\u7684\u90a3\u4e2a\uff0c\u5473\u9053\u8fd8\u4e0d\u9519\u7684\u662f\u5565\u6765\u7740\uff1f\u54e6\u5bf9%d\uff01\u641e\u4e00\u676f"
      }, {
        ID: 9,
        talk: "\u55ef\u2026\u4e00\u676f%d\u5427\uff0c\u6211\u8d76\u65f6\u95f4\u5f85\u4f1a\u8981\u53bb\u8e6d\u996d"
      }, {
        ID: 10,
        talk: "\u4eca\u5929\u7684\u60ac\u8d4f\u4efb\u52a1\u592a\u5dee\u4e86\uff0c\u90fd\u7ed9\u4e0d\u5230\u4e94\u5341\u9a6c\u5185\uff0c\u90a3\u6211\u4e3a\u4ec0\u4e48\u8981\u53bb\u5e72\uff1f\u8fd8\u4e0d\u5982\u53bb\u6361\u522b\u4eba\u5269\u7684\u88c5\u5907\u3002\u54e6\u5bf9\uff0c\u7ed9\u6211\u6765\u4e00\u676f%d"
      }, {
        ID: 11,
        talk: "\u4f60\u89c1\u8fc7\u90a3\u4e2a\u732b\u7267\u4e86\u4e48\uff0c\u8111\u888b\u5c0f\u5c0f\u7684\uff0c\u5148\u7ed9\u6211\u6765\u4e00\u676f%d"
      }, {
        ID: 12,
        talk: "\u6765\u4e00\u676f%d\uff0c\u4f60\u6bcf\u5929\u7ad9\u5728\u8fd9\u91cc\u4e0d\u65e0\u804a\u4e48\uff0c\u5c31\u4e0d\u60f3\u51fa\u53bb\u8d70\u8d70\uff1f\u8981\u4e0d\u6211\u5e2e\u4f60\u770b\u4f1a\u5e97\uff1f"
      }, {
        ID: 13,
        talk: "\u96be\u5403\u6b7b\u4e86\uff0c\u7ed9\u6211\u6765\u4e00\u676f%d\u6f31\u6f31\u53e3\u3002\u54e6\u6211\u6ca1\u6709\u8bb2\u4f60\u7684%d\u96be\u559d\u2026\u55ef\u2026\u6211\u662f\u8bf4\u6211\u521a\u8e6d\u7684\u996d\u5f88\u96be\u5403\uff0c\u6211\u6f31\u5b8c\u53e3\u4f1a\u54bd\u4e0b\u53bb\u7684\u2026\u4e0d\u5410\u2026"
      }, {
        ID: 14,
        talk: "\u90a3\u7fa4\u54e5\u5e03\u6797\u6700\u8fd1\u86ee\u56a3\u5f20\u7684\uff0c\u5c11\u53bb\u83ab\u83ab\u5c71\u8c37\u3002\u54e6\u5bf9\uff0c\u4f60\u751a\u81f3\u6ca1\u65f6\u95f4\u53bb\uff0c\u6ca1\u6709\u5047\u671f\u7684\u5bb6\u4f19\uff0c\u6765\u4e00\u676f%d\u559d\u559d\uff0c\u901f\u5ea6\u5feb\u5feb\uff01"
      }, {
        ID: 15,
        talk: "%d\uff0c\u8c22\u8c22\u3002\u6211\u8ddf\u4f60\u8bf4\uff0c\u6211\u521a\u521a\u6253\u51fa\u4e86\u56db\u5341\u591a\u5200\u8fde\u51fb\uff0c\u6ca1\u65ad\uff01\u56db\u5341\u591a\u5200\u90a3\u53ef\u662f\uff0c\u4e00\u5200\u6ca1\u65ad\uff01"
      }, {
        ID: 16,
        talk: "\u8fd8\u6709%d\u4e48\uff0c\u6765\u4e00\u676f\u5427\uff0c\u521a\u521a\u6361\u4e86\u4e0d\u5c11\u4e8c\u7ea7\u98de\u5200\uff0c\u5356\u4e86\u4e9b\u94b1"
      }, {
        ID: 17,
        talk: "\u8fd8\u6709%d\u4e48\uff0c\u6765\u4e00\u676f\u5427\uff0c\u521a\u521a\u6361\u5230\u4e00\u628a\u4e09\u7ea7\u5f2f\u5200\uff0c\u5356\u4e86\u4e9b\u94b1"
      }, {
        ID: 18,
        talk: "\u5e2e\u5fd9\u641e\u4e00\u676f%d\uff0c\u521a\u521a\u6361\u5230\u4e86\u4e24\u4ef6\u4e00\u7ea7\u76d4\u7532\uff0c\u5356\u4e86\u4e9b\u94b1"
      }, {
        ID: 19,
        talk: "%d\uff0c\u8c22\u8c22\u3002\u521a\u521a\u505a\u4e86\u4e2a\u60ac\u8d4f\u4efb\u52a1\uff0c\u5956\u52b1\u81ea\u5df1\u4e00\u676f"
      }, {
        ID: 20,
        talk: "\u90a3\u7fa4\u54e5\u5e03\u6797\u505a\u7684\u996d\u662f\u8d8a\u6765\u8d8a\u96be\u5403\u4e86\uff0c\u6765\u676f%d"
      }, {
        ID: 21,
        talk: "\u4f60\u8fd9\u8fb9\u9700\u8981\u517c\u804c\u4e48\uff0c\u6bd4\u8d77\u53bb\u8ddf\u6076\u7075\u72ee\u9e6b\u5e72\u67b6\uff0c\u6211\u66f4\u60f3\u5728\u4f60\u8fd9\u626b\u626b\u5730\uff0c\u987a\u4fbf\u518d\u2026\u6765\u4e00\u676f%d\uff01"
      } ],
      "002": [ {
        ID: 1,
        talk: "\u563f\uff0c\u6765\u676f%d"
      }, {
        ID: 2,
        talk: "\u751f\u610f\u8fd8\u4e0d\u9519\u561b\uff1f\u6765\u676f%d"
      }, {
        ID: 3,
        talk: "\u8981\u6765\u4e00\u676f%d\uff0c\u5c31\u8fd9\u6837\uff0c\u55ef\u55ef"
      }, {
        ID: 4,
        talk: "\u8981\u4e0d\u662f\u8bf4\u5462\uff0c\u8fd8\u5f97\u662f\u6765\u4e00\u676f%d\u554a"
      }, {
        ID: 5,
        talk: "\u6bcf\u6b21\u5356\u88c5\u5907\u90fd\u8981\u53bb\u4e00\u8d9f\u83ab\u62c9\u66fc\u5c0f\u9547\uff0c\u771f\u7684\u8fdc\u554a\u3002\u6765\u676f%d\uff0c\u6211\u8981\u6b47\u4f1a\u4e86"
      }, {
        ID: 6,
        talk: "\u8bf6\uff0c\u5df2\u7ecf\u5230\u6211\u70b9\u5355\u4e86\u561b\uff1f\u90a3\u5c31\u2026\u554a\u2026\u559d\u4ec0\u4e48\u597d\u5462\u2026\u8fd9\u4e2a\u5427\uff0c%d"
      }, {
        ID: 7,
        talk: "\u5e2e\u5fd9\u641e\u676f%d\uff0c\u8c22\u8c22\uff01"
      }, {
        ID: 8,
        talk: "\u4e00\u676f%d\uff0c\u8c22\u8c22\uff0c\u5b69\u5b50\u7231\u559d\uff01"
      }, {
        ID: 9,
        talk: "\u55e8\uff0c\u6700\u8fd1\u5728\u5fd9\u4ec0\u4e48\u2026\u54e6\uff0c\u6765\u676f%d\u3002\u4e0d\u597d\u610f\u601d\uff0c\u95ee\u4e60\u60ef\u4e86"
      }, {
        ID: 10,
        talk: "\u559d\u70b9\u5565\u5462\uff1f%d\uff1f\u5c31\u8fd9\u4e2a\u5427"
      }, {
        ID: 11,
        talk: "%d\u53ef\u4ee5\u561b\uff1f\u8fd9\u4e2a\u505a\u8d77\u6765\u5feb\u5417\uff1f"
      }, {
        ID: 12,
        talk: "\u60f3\u559d\u676f%d\uff0c\u4f60\u53ef\u4ee5\u8bf7\u6211\u561b\u2026\u2026\u5f00\u73a9\u7b11\u5f00\u73a9\u7b11"
      }, {
        ID: 13,
        talk: "\u8fd9\u51e0\u5929\u83ab\u83ab\u5c71\u8c37\u7684\u4efb\u52a1\u592a\u591a\u4e86\uff0c\u8981\u662f\u80fd\u5728\u5c0f\u9547\u9644\u8fd1\u63a5\u4efb\u52a1\u5c31\u597d\u4e86\uff0c\u5e2e\u5fd9\u505a\u4e00\u676f%d\u5427\uff0c\u6211\u7684\u811a\u597d\u7d2f\u2026\u2026"
      }, {
        ID: 14,
        talk: "\u5e2e\u5fd9\u641e\u4e00\u676f%d\uff0c\u5f85\u4f1a\u8981\u53bb\u505a\u4efb\u52a1\u4e86\uff0c\u738b\u57ce\u90a3\u8fb9\u6d3e\u4e0b\u6765\u4e00\u4e2a\u5927\u6d3b\uff01\u8fd9\u56de\u5e94\u8be5\u80fd\u635e\u4e0d\u5c11"
      }, {
        ID: 15,
        talk: "\u563f\uff0c\u5728\u53d1\u5446\u4e48\uff1f\u6765\u676f%d\uff0c\u6211\u4e5f\u8981\u53bb\u53d1\u4f1a\u5446"
      }, {
        ID: 16,
        talk: "\u4e00\u676f%d\uff0c\u5c31\u8fd9\u6837\u3002\u4f60\u4e0d\u89c9\u5f97\u90a3\u4e2a\u85cf\u72d0\u602a\u602a\u7684\uff1f\u54e6\u2026\u6211\u7684\u610f\u601d\u662f\u773c\u775b\u5c0f\u5c0f\u7684"
      }, {
        ID: 17,
        talk: "\u597d\u997f\uff0c\u5148\u7ed9\u6211\u6765\u4e00\u676f%d\uff0c\u6211\u5f85\u4f1a\u8981\u53bb\u5403\u70b9\u4e1c\u897f\uff0c\u5e0c\u671b\u4e0d\u4f1a\u8ba9\u5c0f\u961f\u7b49\u592a\u4e45"
      }, {
        ID: 18,
        talk: "\u6765\u676f%d\uff0c\u6709\u9762\u5305\u5417\uff1f\u5514~\u597d\u50cf\u6ca1\u6709"
      }, {
        ID: 19,
        talk: "\u8001\u677f\uff0c\u6765\u4e00\u676f%d\uff0c\u53ef\u4ee5\u7ed9\u6211\u6362\u8d85\u5927\u676f\u4e0d\uff1f"
      }, {
        ID: 20,
        talk: "\u60f3\u559d%d\u4e86\uff0c\u6700\u8fd1\u597d\u50cf\u6ca1\u600e\u4e48\u559d\u8fc7\u8fd9\u4e2a\u5427\uff1f"
      }, {
        ID: 21,
        talk: "\u559d\uff01\u54e6\u5bf9\uff0c\u559d\u4e2a\u4ec0\u4e48\u5462\uff1f%d\u5427"
      } ],
      "003": [ {
        ID: 1,
        talk: "\u4e00\u676f%d\uff0c\u8c22\u8c22"
      }, {
        ID: 2,
        talk: "\u8001\u677f\uff1f\u5728\u4e48\uff0c\u5e2e\u5fd9\u5f04\u4e00\u676f%d"
      }, {
        ID: 3,
        talk: "\u4e00\u676f%d\u5566"
      }, {
        ID: 4,
        talk: "\u60f3\u559d\u676f%d\u2026\u2026\u6211\u6bcf\u5929\u90fd\u559d\u996e\u6599\u662f\u4e0d\u662f\u4e0d\u592a\u597d\uff1f"
      }, {
        ID: 5,
        talk: "\u6700\u8fd1\u9b54\u7269\u5165\u4fb5\u8d8a\u6765\u8d8a\u9891\u7e41\u4e86\u5462\uff0c\u6765\u4e00\u676f%d\uff0c\u6211\u770b\u770b\u6709\u6ca1\u6709\u4f4d\u7f6e\uff0c\u6211\u60f3\u5750\u7740\u559d"
      }, {
        ID: 6,
        talk: "\u738b\u57ce\u90a3\u7fa4\u5b8c\u86cb\u4e1c\u897f\u73b0\u5728\u5c45\u7136\u8fd8\u5728\u5efa\u65b0\u7684\u5267\u573a\uff1f\u4e00\u70b9\u90fd\u6ca1\u6709\u628a\u83ab\u62c9\u66fc\u4e8b\u4ef6\u5f53\u56de\u4e8b\u554a\uff0c\u54e6\u4e0d\u597d\u610f\u601d\uff0c\u6765\u676f%d"
      }, {
        ID: 7,
        talk: "\u6765\u676f%d\u3002\u6700\u8fd1\u6709\u4ec0\u4e48\u65b0\u95fb\u4e48\uff0c\u6211\u8fd9\u4e00\u628a\u5e74\u7eaa\u4e86\uff0c\u6ca1\u529e\u6cd5\u51fa\u53bb\u901b\u5c31\u53ea\u80fd\u9760\u542c\u70b9\u6545\u4e8b\u4e86"
      }, {
        ID: 8,
        talk: "\u6765\u676f%d\uff0c\u5594\u4f60\u770b\uff0c\u738b\u57ce\u53c8\u6709\u65b0\u52a8\u9759\u4e86"
      }, {
        ID: 9,
        talk: "\u6765\u676f%d\uff0c\u636e\u8bf4\u5c3c\u5c3c\u514b\u65af\u6700\u8fd1\u53c8\u5728\u5e72\u67b6\u4e86\uff0c\u4ed6\u4eec\u8fd8\u60f3\u7740\u9057\u4ea7\u5730\u7684\u5b9d\u85cf\u4e48\uff1f\u90a3\u4e9b\u662f\u4e0d\u662f\u771f\u7684\u90fd\u4e0d\u4e00\u5b9a"
      }, {
        ID: 10,
        talk: "\u8001\u677f\uff0c%d\u8c22\u8c22\uff0c\u54e6\u5bf9\u4e86\uff0c\u4f60\u53ef\u4ee5\u6765\u6211\u7684\u6742\u8d27\u5e97\u770b\u770b\uff0c\u8bf4\u4e0d\u5b9a\u53ef\u4ee5\u4e70\u70b9\u4ec0\u4e48"
      }, {
        ID: 11,
        talk: "\u8001\u677f\u6765\u676f%d\uff0c\u6211\u6bcf\u5929\u4e0b\u5348\u4e24\u70b9\u4f1a\u6362\u4e00\u6279\u8d27\uff0c\u5982\u679c\u4e0a\u5348\u4f60\u6ca1\u770b\u5230\u5565\u597d\u4e1c\u897f\uff0c\u53ef\u4ee5\u4e24\u70b9\u4e4b\u540e\u518d\u6765\u770b\u770b\u3002\u54e6\u2026\u8fd8\u6709\u665a\u4e0a\u516b\u70b9\u4e4b\u540e"
      }, {
        ID: 12,
        talk: "\u9f99\u767e\u5c71\u56fd\u90a3\u8fb9\u7684\u5730\u9707\u771f\u4e25\u91cd\u554a\uff0c\u6765\u676f%d\u538b\u538b\u60ca\u597d\u4e86\uff0c\u867d\u7136\u79bb\u8fd9\u4e48\u8fdc\u4e5f\u611f\u53d7\u4e0d\u5230\uff0c\u4f46\u662f\u8fd8\u662f\u540e\u80cc\u53d1\u51c9\u3002"
      }, {
        ID: 13,
        talk: "\u6765\u676f%d\uff0c\u7b49\u7b49\uff1f\u8fd9\u662f\u6628\u5929\u7684\u62a5\u7eb8\uff1f\uff01\u6211\u62ff\u9519\u4e86\uff1f"
      }, {
        ID: 14,
        talk: "\u90a3\u5934\u91ce\u732a\u771f\u6709\u6d3b\u529b\uff0c\u611f\u89c9\u8fd9\u624d\u662f\u5e74\u8f7b\u4eba\u8be5\u6709\u7684\u6837\u5b50\u554a\u3002\u6765\u4e00\u676f%d\u5427\uff0c\u8ba9\u6211\u4e5f\u70ed\u8840\u6cb8\u817e\u4e00\u4e0b"
      }, {
        ID: 15,
        talk: "\u6709\u70b9\u6e34\uff0c\u6765\u676f%d\u3002\u6211\u5e74\u8f7b\u7684\u65f6\u5019\u53bb\u81ea\u7531\u5730\u4e5f\u559d\u5230\u4f60\u5e97\u91cc\u8fd9\u79cd\u82e6\u82e6\u7684\u4e1c\u897f\uff0c\u4f46\u662f\u597d\u50cf\u53c8\u4e0d\u592a\u4e00\u6837"
      }, {
        ID: 16,
        talk: "\u6d41\u653e\u57ce\u6700\u8fd1\u600e\u4e48\u8fd9\u4e48\u5b89\u9759\uff1f\u662f\u53d1\u751f\u4ec0\u4e48\u4e8b\u4e86\u4e48\uff1f\u5148\u7ed9\u6211\u6765\u676f%d\uff0c\u6211\u518d\u770b\u770b\u554a"
      }, {
        ID: 17,
        talk: "\u6700\u8fd1\u559d\u996e\u6599\u559d\u7684\u4e0d\u5c11\uff0c\u4f46\u662f\u8fd8\u662f\u60f3\u653e\u7eb5\u4e00\u4e0b\u81ea\u5df1\uff0c\u867d\u7136\u5e74\u8f7b\u7684\u65f6\u5019\u6ca1\u6709\u4eab\u53d7\u5230\uff0c\u4e0d\u8fc7\u73b0\u5728\u4e0d\u80fd\u518d\u8fd9\u6837\u5566\uff01%d\uff0c\u901f\u901f\u53bb\u505a\uff01"
      }, {
        ID: 18,
        talk: "\u6765\u676f%d\uff0c\u6765\u676f%d\u3002\u6211\u521a\u521a\u662f\u53c8\u8bf4\u4e86\u4e00\u904d\u4e48\uff1f"
      }, {
        ID: 19,
        talk: "\u5c3c\u5c3c\u514b\u65af\u6700\u8fd1\u7684\u9a6f\u9f99\u4e1a\u771f\u7684\u5f88\u706b\u7206\u554a\uff0c\u6211\u8bb0\u5f97\u6211\u5e74\u8f7b\u7684\u65f6\u5019\u5c31\u60f3\u53bb\u8bd5\u8bd5\u6765\u7740\uff0c\u6765\u676f%d\uff0c\u6211\u8981\u4e00\u53e3\u6c14\u5e72\u4e86"
      }, {
        ID: 20,
        talk: "\u6765\u676f%d\uff0c\u8981\u597d\u597d\u6311\u4e0b\u660e\u5929\u4e0a\u4e9b\u4ec0\u4e48\u8d27\uff0c\u554a\u4e0d\u6253\u6270\u4f60\u4e86"
      }, {
        ID: 21,
        talk: "\u6211\u5728\u60f3\u2026\u5148\u6765\u676f%d\u5427\uff0c\u6211\u662f\u8bf4\u6211\u5728\u60f3\u8981\u4e0d\u8981\u591a\u8fdb\u4e00\u4e9b\u5bb6\u5177\uff0c\u611f\u89c9\u662f\u4e0d\u662f\u53ef\u9009\u7684\u79cd\u7c7b\u4e0d\u592a\u591a\uff1f"
      } ]
    };
    cc._RF.pop();
  }, {
    "../UIScript/UIBuild": "UIBuild"
  } ],
  RecipeCoffeeItem: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "a5ba60SK0FFq62iNvs8Fa7b", "RecipeCoffeeItem");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const CommonUtils_1 = require("../../Common/Utils/CommonUtils");
    const GlobalData_1 = require("../../Config/GlobalData");
    const {ccclass: ccclass, property: property} = cc._decorator;
    let RecipeCoffeeItem = class RecipeCoffeeItem extends cc.Component {
      constructor() {
        super(...arguments);
        this.tumbler_b = null;
        this.tumbler_f = null;
        this.coffee = null;
      }
      onLoad() {}
      onEnable() {}
      onDisable() {}
      initUi(data) {
        CommonUtils_1.CommonUtils.setItemSpriteFrame(this.coffee, `${GlobalData_1.GlobalData.coffeeTypePath}${data.ID}`);
        CommonUtils_1.CommonUtils.setItemSpriteFrame(this.tumbler_b, `${GlobalData_1.GlobalData.tumblerePath}${data["tumbler_b"]}`);
        CommonUtils_1.CommonUtils.setItemSpriteFrame(this.tumbler_f, `${GlobalData_1.GlobalData.tumblerePath}${data["tumbler_f"]}`);
      }
    };
    __decorate([ property(cc.Sprite) ], RecipeCoffeeItem.prototype, "tumbler_b", void 0);
    __decorate([ property(cc.Sprite) ], RecipeCoffeeItem.prototype, "tumbler_f", void 0);
    __decorate([ property(cc.Sprite) ], RecipeCoffeeItem.prototype, "coffee", void 0);
    RecipeCoffeeItem = __decorate([ ccclass ], RecipeCoffeeItem);
    exports.default = RecipeCoffeeItem;
    cc._RF.pop();
  }, {
    "../../Common/Utils/CommonUtils": "CommonUtils",
    "../../Config/GlobalData": "GlobalData"
  } ],
  RecipeItem: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "bbdd70BoJ9NkL0eV9lYN/kX", "RecipeItem");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var RecipeItem_1;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const lodash_1 = require("lodash");
    const ListItem_1 = require("../../Common/Components/ListItem");
    const CommonUtils_1 = require("../../Common/Utils/CommonUtils");
    const GlobalData_1 = require("../../Config/GlobalData");
    const UIRecipeInfo_1 = require("../../UIScript/UIRecipeInfo");
    const UIToast1_1 = require("../../UIScript/toast/UIToast1");
    const MessageInfo_1 = require("../../Config/MessageInfo");
    const RecipeCoffeeItem_1 = require("./RecipeCoffeeItem");
    const {ccclass: ccclass, property: property} = cc._decorator;
    let RecipeItem = RecipeItem_1 = class RecipeItem extends ListItem_1.default {
      constructor() {
        super(...arguments);
        this.itemData = null;
        this.desk = null;
        this.coffee = null;
      }
      onLoad() {
        super.onLoad();
      }
      onEnable() {
        this.registerEvent();
      }
      onDisable() {
        this.unRegisterEvent();
      }
      registerEvent() {
        this.node.on(cc.Node.EventType.TOUCH_END, this.clickRecipeInfo, this);
      }
      unRegisterEvent() {
        this.node.off(cc.Node.EventType.TOUCH_END, this.clickRecipeInfo, this);
      }
      initUi(data, desk) {
        this.itemData = data;
        this.desk = desk;
        if ("lock" == data["unlock"]) {
          this.title.getComponent(cc.Label).string = "\u672a\u89e3\u9501";
          CommonUtils_1.CommonUtils.setItemSpriteFrame(this.icon, `${GlobalData_1.GlobalData.coffeeTypePath}${data["unlock"]}`);
          this.icon.node.active = true;
          this.coffee.active = false;
        } else {
          this.title.getComponent(cc.Label).string = true == data["name"].includes("%s") ? data["name"].replace("%s", "") : data["name"];
          this.icon.node.active = false;
          this.coffee.getComponent(RecipeCoffeeItem_1.default).initUi(data);
          this.coffee.active = true;
        }
        "1001" == data["id"] && (this.selected = true);
      }
      clickRecipeInfo() {
        if ("lock" == this.itemData["unlock"]) {
          UIToast1_1.default.open({
            info: MessageInfo_1.MessageInfo.unlockRecipe
          });
          return;
        }
        let pNode = this.node.parent;
        lodash_1.forEach(pNode.children, item => {
          item.getComponent(RecipeItem_1).selected = false;
        });
        this.selected = true;
        UIRecipeInfo_1.default.open(this.itemData);
      }
    };
    __decorate([ property(cc.Node) ], RecipeItem.prototype, "coffee", void 0);
    RecipeItem = RecipeItem_1 = __decorate([ ccclass ], RecipeItem);
    exports.default = RecipeItem;
    cc._RF.pop();
  }, {
    "../../Common/Components/ListItem": "ListItem",
    "../../Common/Utils/CommonUtils": "CommonUtils",
    "../../Config/GlobalData": "GlobalData",
    "../../Config/MessageInfo": "MessageInfo",
    "../../UIScript/UIRecipeInfo": "UIRecipeInfo",
    "../../UIScript/toast/UIToast1": "UIToast1",
    "./RecipeCoffeeItem": "RecipeCoffeeItem",
    lodash: 1
  } ],
  RecipeModuleItem: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "1cef5Q0QUhHBZGIKgAq798N", "RecipeModuleItem");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const ListItem_1 = require("../../Common/Components/ListItem");
    const RawMaterial_1 = require("../../Config/RawMaterial");
    const {ccclass: ccclass, property: property} = cc._decorator;
    let RecipeModuleItem = class RecipeModuleItem extends ListItem_1.default {
      constructor() {
        super(...arguments);
        this.desk = null;
        this.itemData = null;
        this.moduleLength = 0;
        this.viewWidth = 750;
      }
      onEnable() {
        this.registerEvent();
      }
      onDisable() {
        this.unRegisterEvent();
      }
      initUi(curNumber, desk) {
        this.itemData = "UIRecipe" == desk.node.name ? RawMaterial_1.RecipeModule : RawMaterial_1.BackPackModule;
        this.desk = desk;
        this.node.color = cc.color(this.itemData[curNumber].color);
        this.title.getComponent(cc.Label).string = this.itemData[curNumber].name;
        this.setNodeSize();
        if (0 == curNumber) {
          this.node.height = this.desk.nodeHeight[1];
          this.title.y = this.desk.titlePos[1];
        }
      }
      setNodeSize() {
        this.moduleLength = this.itemData.length;
        for (let i = 0; i < this.moduleLength; i++) this.node.width = i > 5 ? this.viewWidth / 5 : this.viewWidth / this.moduleLength;
      }
      registerEvent() {
        this.node.on(cc.Node.EventType.TOUCH_END, this.clickModule, this);
      }
      unRegisterEvent() {
        this.node.off(cc.Node.EventType.TOUCH_END, this.clickModule, this);
      }
      clickModule(e) {
        let nodeName = e.target.name;
        this.desk.curModuleNumber = parseInt(nodeName);
        this.desk.initAllModule();
        "UIBackpack" == this.desk.node.name && this.desk.initTypeItem();
        this.desk.changeRecipeItem();
        this.node.height = this.desk.nodeHeight[1];
        this.title.y = this.desk.titlePos[1];
      }
    };
    RecipeModuleItem = __decorate([ ccclass ], RecipeModuleItem);
    exports.default = RecipeModuleItem;
    cc._RF.pop();
  }, {
    "../../Common/Components/ListItem": "ListItem",
    "../../Config/RawMaterial": "RawMaterial"
  } ],
  RecycleScroll: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "0d95cDuDTpNHL3GyMiGr8Cr", "RecycleScroll");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, menu = _a.menu;
    var createFlag = 0;
    var RecycleScroll = function(_super) {
      __extends(RecycleScroll, _super);
      function RecycleScroll() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.itemPrefab = null;
        _this.spacing = cc.Vec2.ZERO;
        _this.offsetContentHeight = 0;
        _this.parentContent = null;
        _this._numItems = 0;
        _this._tempContentHeight = 0;
        _this.isDown = true;
        _this._viewCol = 0;
        _this._viewRow = 0;
        _this._viewW = 0;
        _this._viewH = 0;
        _this._itemW = 0;
        _this._itemH = 0;
        _this._lastPosY = 0;
        _this._isInit = false;
        _this._itemsUUIDToIndex = {};
        _this._fleshInterval = .2;
        _this._fleshCounter = 0;
        _this._initTimer = .05;
        _this._initCounter = 0;
        _this._isResize = false;
        _this._itemStartPos = cc.Vec2.ZERO;
        _this._isResizeFinish = false;
        _this._lineIndex = -1;
        _this.itemList = [];
        _this.content = null;
        return _this;
      }
      Object.defineProperty(RecycleScroll.prototype, "numItems", {
        get: function() {
          return this._numItems;
        },
        set: function(value) {
          this._numItems = value;
          this._hideAllItems();
          this._initialize();
          this._updateContentHeight();
          this.updateAllItems();
        },
        enumerable: false,
        configurable: true
      });
      RecycleScroll.prototype.onItemRender = function(index, node) {};
      RecycleScroll.prototype.onItemClicked = function(index, node) {};
      RecycleScroll.prototype.updateAllItems = function() {
        var _this = this;
        this.itemList.forEach(function(item) {
          return _this._updateItem(_this._itemsUUIDToIndex[item.uuid], item, true);
        });
      };
      RecycleScroll.prototype.scrollToIndexVertical = function(index, duration) {
        void 0 === duration && (duration = .2);
        var contentUTF = this._getContentUTF();
        var p = this._itemH * index / (contentUTF.height - this._viewH);
        this.node.getComponent(cc.ScrollView).scrollToPercentVertical(1 - p, duration);
      };
      RecycleScroll.prototype.getItemDirPos = function(itemIndex) {
        var x = itemIndex % this._viewCol * this._itemW;
        var y = -Math.floor(itemIndex / this._viewCol) * this._itemH + (this.spacing.y >> 1);
        var contentUTF = this._getContentUTF();
        var wpos = contentUTF.convertToWorldSpaceAR(cc.v3(x, y));
        var parentUTF = this._getContentUTF().parent;
        var itemInViewPos = parentUTF.convertToNodeSpaceAR(wpos);
        var horizon = 0;
        var vertical = 0;
        horizon = itemInViewPos.x < -this._viewW / 2 ? -1 : itemInViewPos.x > this._viewW / 2 ? 1 : 0;
        vertical = itemInViewPos.y < -this._viewH / 2 ? -1 : itemInViewPos.y > this._viewH / 2 ? 1 : 0;
        return [ horizon, vertical ];
      };
      RecycleScroll.prototype.onLoad = function() {
        this.node.on(cc.Node.EventType.SIZE_CHANGED, this.onSizeChange, this);
      };
      RecycleScroll.prototype.onSizeChange = function() {
        this._isResize = true;
        this._initCounter = 0;
        this._itemsUUIDToIndex = {};
        this._getContentUTF().removeAllChildren();
      };
      RecycleScroll.prototype.onDestroy = function() {
        this.node.targetOff(this);
      };
      RecycleScroll.prototype._hideAllItems = function() {
        this.itemList.forEach(function(item, index) {
          return item.active = false;
        });
      };
      RecycleScroll.prototype._getContentUTF = function() {
        return this.node.getComponent(cc.ScrollView).content;
      };
      RecycleScroll.prototype._initialize = function() {
        var _this = this;
        if (this._isInit) return;
        var scroll = this.node.getComponent(cc.ScrollView);
        scroll.enabled = false;
        this._isInit = true;
        var content = this._getContentUTF();
        this.content = content;
        content.removeAllChildren();
        this.itemList = [];
        var viewUTF = content.parent;
        this._viewW = viewUTF.width;
        this._viewH = viewUTF.height;
        var itemData = this.itemPrefab.data;
        this._itemW = itemData.width + this.spacing.x;
        this._itemH = itemData.height + this.spacing.y;
        this._lastPosY = content.position.y;
        this._viewRow = Math.ceil(this._viewH / this._itemH) + 1;
        this._viewCol = Math.floor(this._viewW / this._itemW);
        var surplusW = this._viewW - this._viewCol * this._itemW;
        var startPos = cc.v2((-this._viewW >> 1) + (this._itemW >> 1) + (surplusW >> 1), -this._itemH >> 1);
        this._itemStartPos = startPos;
        var cNum = this._viewRow * this._viewCol;
        console.log("\u5b9e\u4f8b\u5316\u6570\u91cf:" + cNum);
        var createNum = 0;
        var createFunc = function(index) {
          if (!cc.isValid(content)) return;
          var item = cc.instantiate(_this.itemPrefab);
          item.parent = content;
          var x = index % _this._viewCol * _this._itemW;
          var y = -Math.floor(index / _this._viewCol) * _this._itemH + (_this.spacing.y >> 1);
          var pos = cc.v3(x + startPos.x, y + startPos.y);
          item.setPosition(pos);
          item.on(cc.Node.EventType.TOUCH_END, function() {
            _this.onItemClicked(_this._itemsUUIDToIndex[item.uuid], item);
          }, _this);
          _this.itemList[index] = item;
          item["needRender"] = true;
          _this._updateItem(index, item);
          _this._itemsUUIDToIndex[item.uuid] = index;
          createNum++;
          createNum == cNum && (scroll.enabled = true);
        };
        createFlag++;
        frameLoad(cNum, createFunc, 16, 0, createFlag);
      };
      RecycleScroll.prototype._updateContentHeight = function() {
        var content = this._getContentUTF();
        var col = Math.floor(this._viewW / this._itemW);
        var row = Math.ceil(this.numItems / col);
        content.height = (row + 4) * (this.itemPrefab.data.height + this.spacing.y) - this.spacing.y + this.offsetContentHeight;
      };
      RecycleScroll.prototype._getPosInView = function(item) {
        var content = this._getContentUTF();
        var viewUTF = content.parent;
        var wpos = content.convertToWorldSpaceAR(item.position);
        var lpos = viewUTF.convertToNodeSpaceAR(wpos);
        return lpos;
      };
      RecycleScroll.prototype._updateItem = function(index, item, force) {
        void 0 === force && (force = false);
        var isShow = index >= 0 && index < this.numItems;
        item.active = isShow;
        if (isShow && (item["needRender"] || force)) {
          this.onItemRender(index, item);
          item["needRender"] = false;
        }
      };
      RecycleScroll.prototype.update = function(dt) {
        if (this._isResize) {
          this._initCounter += dt;
          if (this._initCounter >= this._initTimer) {
            this._isInit = false;
            this._isResize = false;
            this.numItems = this._numItems;
            this._isResizeFinish = true;
          }
          return;
        }
        var content = this._getContentUTF();
        var currY = content.position.y;
        var dtY = currY - this._lastPosY;
        this._lastPosY = currY;
        this._fleshCounter += dt;
        if (0 == dtY && !this._isResizeFinish) return;
        var isDown = dtY < 0;
        this.isDown = isDown;
        var viewHalfH = this._viewH >> 1;
        var itemHalfH = this._itemH >> 1;
        var lineIndex = Math.floor((currY - viewHalfH) / this._itemH);
        var isLineChange = this._lineIndex != lineIndex;
        if (!isLineChange && !this._isResizeFinish) return;
        this._isResizeFinish = false;
        this._lineIndex = lineIndex;
        var pageHeight = this._itemH * this._viewRow;
        var pageLen = this._viewRow * this._viewCol;
        var pageIndex = Math.floor((currY - viewHalfH) / pageHeight);
        var itemsLen = this.itemList.length;
        for (var i = 0; i < itemsLen; ++i) {
          var index = i;
          var item = this.itemList[i];
          var x = index % this._viewCol * this._itemW;
          var y = -Math.floor(index / this._viewCol) * this._itemH + (this.spacing.y >> 1);
          var pos = cc.v3(x + this._itemStartPos.x, y + this._itemStartPos.y - pageIndex * pageHeight);
          item.setPosition(pos);
          var posInView = this._getPosInView(item);
          var lastIndex = this._itemsUUIDToIndex[item.uuid];
          var currIndex = pageIndex * pageLen + i;
          if (isDown) {
            if (posInView.y >= viewHalfH + itemHalfH) {
              item.setPosition(cc.v3(item.position.x, item.position.y - this._viewRow * this._itemH));
              currIndex += itemsLen;
            }
            if (isLineChange) {
              var posInView_1 = this._getPosInView(item);
              if (posInView_1.y <= -(viewHalfH + itemHalfH)) {
                item.setPosition(cc.v3(item.position.x, item.position.y + this._viewRow * this._itemH));
                currIndex -= itemsLen;
              }
            }
          } else if (posInView.y >= viewHalfH + itemHalfH) {
            item.setPosition(cc.v3(item.position.x, item.position.y - this._viewRow * this._itemH));
            currIndex += itemsLen;
          }
          if (currIndex != lastIndex) {
            item["needRender"] = true;
            this._updateItem(currIndex, item);
          }
          this._itemsUUIDToIndex[item.uuid] = currIndex;
        }
      };
      __decorate([ property(cc.Prefab) ], RecycleScroll.prototype, "itemPrefab", void 0);
      __decorate([ property(cc.Vec2) ], RecycleScroll.prototype, "spacing", void 0);
      __decorate([ property(Number) ], RecycleScroll.prototype, "offsetContentHeight", void 0);
      __decorate([ property(cc.Node) ], RecycleScroll.prototype, "parentContent", void 0);
      RecycleScroll = __decorate([ ccclass("RecycleScroll"), menu("\u6027\u80fd\u4f18\u5316/RecycleScroll") ], RecycleScroll);
      return RecycleScroll;
    }(cc.Component);
    exports.default = RecycleScroll;
    function frameLoad(loopTimes, func, frameTime, __index, flag) {
      void 0 === frameTime && (frameTime = 16);
      void 0 === __index && (__index = 0);
      void 0 === flag && (flag = 0);
      var loop = loopTimes;
      var start = new Date().getTime();
      var end = 0;
      var dt = 0;
      for (var i = 0; i < loop; ++i) {
        if (flag != createFlag) break;
        if (__index >= loop) break;
        try {
          func && func(__index);
        } catch (e) {
          cc.error(e);
        }
        __index++;
        end = new Date().getTime();
        dt = end - start;
        if (dt > frameTime) {
          setTimeout(function() {
            frameLoad(loop, func, frameTime, __index, flag);
          }, 10);
          break;
        }
      }
    }
    cc._RF.pop();
  }, {} ],
  RenderUtil: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "4bd3bJ9z/JCjJ33ca5fBEZA", "RenderUtil");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var RenderUtil = function() {
      function RenderUtil() {}
      RenderUtil.getRenderTexture = function(node, out) {
        if (!cc.isValid(node)) return null;
        out && out instanceof cc.RenderTexture || (out = new cc.RenderTexture());
        var width = Math.floor(node.width), height = Math.floor(node.height);
        out.initWithSize(width, height);
        var cameraNode = new cc.Node();
        cameraNode.parent = node;
        var camera = cameraNode.addComponent(cc.Camera);
        camera.clearFlags |= cc.Camera.ClearFlags.COLOR;
        camera.backgroundColor = cc.color(0, 0, 0, 0);
        camera.zoomRatio = cc.winSize.height / height;
        camera.targetTexture = out;
        camera.render(node);
        cameraNode.destroy();
        return out;
      };
      RenderUtil.renderWithMaterial = function(srcRT, dstRT, material) {
        if (dstRT instanceof cc.Material) {
          material = dstRT;
          dstRT = new cc.RenderTexture();
        }
        var tempNode = new cc.Node();
        tempNode.setParent(cc.Canvas.instance.node);
        var tempSprite = tempNode.addComponent(cc.Sprite);
        tempSprite.sizeMode = cc.Sprite.SizeMode.RAW;
        tempSprite.trim = false;
        tempSprite.spriteFrame = new cc.SpriteFrame(srcRT);
        var width = srcRT.width, height = srcRT.height;
        dstRT.initWithSize(width, height);
        material instanceof cc.Material && tempSprite.setMaterial(0, material);
        var cameraNode = new cc.Node();
        cameraNode.setParent(tempNode);
        var camera = cameraNode.addComponent(cc.Camera);
        camera.clearFlags |= cc.Camera.ClearFlags.COLOR;
        camera.backgroundColor = cc.color(0, 0, 0, 0);
        camera.zoomRatio = cc.winSize.height / height;
        camera.targetTexture = dstRT;
        camera.render(tempNode);
        cameraNode.destroy();
        tempNode.destroy();
        return dstRT;
      };
      RenderUtil.getPixelsData = function(node, flipY) {
        void 0 === flipY && (flipY = true);
        if (!cc.isValid(node)) return null;
        var width = Math.floor(node.width), height = Math.floor(node.height);
        var cameraNode = new cc.Node();
        cameraNode.parent = node;
        var camera = cameraNode.addComponent(cc.Camera);
        camera.clearFlags |= cc.Camera.ClearFlags.COLOR;
        camera.backgroundColor = cc.color(0, 0, 0, 0);
        camera.zoomRatio = cc.winSize.height / height;
        var renderTexture = new cc.RenderTexture();
        renderTexture.initWithSize(width, height, cc.RenderTexture.DepthStencilFormat.RB_FMT_S8);
        camera.targetTexture = renderTexture;
        camera.render(node);
        var pixelsData = renderTexture.readPixels();
        renderTexture.destroy();
        cameraNode.destroy();
        if (flipY) {
          var length = pixelsData.length, lineWidth = 4 * width, data = new Uint8Array(length);
          for (var i = 0, j = length - lineWidth; i < length; i += lineWidth, j -= lineWidth) for (var k = 0; k < lineWidth; k++) data[i + k] = pixelsData[j + k];
          return data;
        }
        return pixelsData;
      };
      RenderUtil.flipY = function(array, width) {
        var length = array.length, flipped = new Uint8Array(length);
        for (var i = 0, j = length - width; i < length; i += width, j -= width) for (var k = 0; k < width; k++) flipped[i + k] = array[j + k];
        return flipped;
      };
      return RenderUtil;
    }();
    exports.default = RenderUtil;
    cc._RF.pop();
  }, {} ],
  ResConfig: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "97044gds7tDBJR/h6CihizM", "ResConfig");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.RoleState = exports.EntityDirection = void 0;
    var EntityDirection;
    (function(EntityDirection) {
      EntityDirection[EntityDirection["LEFT_UP"] = 0] = "LEFT_UP";
      EntityDirection[EntityDirection["RIGHT_UP"] = 1] = "RIGHT_UP";
      EntityDirection[EntityDirection["LEFT_DOWN"] = 2] = "LEFT_DOWN";
      EntityDirection[EntityDirection["RIGHT_DOWN"] = 3] = "RIGHT_DOWN";
      EntityDirection[EntityDirection["DOWN"] = 4] = "DOWN";
      EntityDirection[EntityDirection["UP"] = 5] = "UP";
    })(EntityDirection = exports.EntityDirection || (exports.EntityDirection = {}));
    var RoleState;
    (function(RoleState) {
      RoleState["run"] = "run";
      RoleState["idle"] = "idle";
    })(RoleState = exports.RoleState || (exports.RoleState = {}));
    cc._RF.pop();
  }, {} ],
  ResMgr: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "de5dbVuBfFIMLLJqz5PKFHB", "ResMgr");
    "use strict";
    var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = this && this.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (1 & t[0]) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, "function" === typeof Symbol && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([ n, v ]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = 2 & op[0] ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 
          0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          (y = 0, t) && (op = [ 2 & op[0], t.value ]);
          switch (op[0]) {
           case 0:
           case 1:
            t = op;
            break;

           case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

           case 5:
            _.label++;
            y = op[1];
            op = [ 0 ];
            continue;

           case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;

           default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (6 === op[0] || 2 === op[0])) {
              _ = 0;
              continue;
            }
            if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (6 === op[0] && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop();
            _.trys.pop();
            continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [ 6, e ];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (5 & op[0]) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var CocosHelper_1 = require("./CocosHelper");
    var ResMgr = function() {
      function ResMgr() {
        this._prefabDepends = cc.js.createMap();
        this._dynamicTags = cc.js.createMap();
        this._tmpAssetsDepends = [];
        this._assetsReference = cc.js.createMap();
        this._prefabs = cc.js.createMap();
      }
      Object.defineProperty(ResMgr, "inst", {
        get: function() {
          null === this.instance && (this.instance = new ResMgr());
          return this.instance;
        },
        enumerable: false,
        configurable: true
      });
      ResMgr.prototype.getFormPrefab = function(fid) {
        return this._prefabs[fid];
      };
      ResMgr.prototype.loadFormPrefab = function(fid) {
        return __awaiter(this, void 0, void 0, function() {
          var _a, res, deps;
          return __generator(this, function(_b) {
            switch (_b.label) {
             case 0:
              if (this._prefabs[fid]) return [ 2, this._prefabs[fid] ];
              return [ 4, this._loadResWithReference(fid, cc.Prefab) ];

             case 1:
              _a = _b.sent(), res = _a.res, deps = _a.deps;
              this._prefabDepends[fid] = deps;
              this._prefabs[fid] = res;
              return [ 2, res ];
            }
          });
        });
      };
      ResMgr.prototype.destoryFormPrefab = function(fid) {
        if (this._prefabs[fid]) {
          this._prefabs[fid].destroy();
          this._prefabs[fid] = null;
          delete this._prefabs[fid];
        }
        this._destoryResWithReference(this._prefabDepends[fid]);
        this._prefabDepends[fid] = null;
        delete this._prefabDepends[fid];
      };
      ResMgr.prototype.loadDynamicRes = function(url, type, tag) {
        return __awaiter(this, void 0, void 0, function() {
          var _a, res, deps;
          var _b;
          return __generator(this, function(_c) {
            switch (_c.label) {
             case 0:
              return [ 4, this._loadResWithReference(url, type) ];

             case 1:
              _a = _c.sent(), res = _a.res, deps = _a.deps;
              this._dynamicTags[tag] || (this._dynamicTags[tag] = []);
              (_b = this._dynamicTags[tag]).push.apply(_b, deps);
              return [ 2, res ];
            }
          });
        });
      };
      ResMgr.prototype.destoryDynamicRes = function(tag) {
        if (!this._dynamicTags[tag]) return false;
        this._destoryResWithReference(this._dynamicTags[tag]);
        this._dynamicTags[tag] = null;
        delete this._dynamicTags[tag];
        return true;
      };
      ResMgr.prototype._loadResWithReference = function(url, type) {
        return __awaiter(this, void 0, void 0, function() {
          var res, deps;
          return __generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              return [ 4, CocosHelper_1.default.loadResSync(url, type, this._addTmpAssetsDepends.bind(this)) ];

             case 1:
              res = _a.sent();
              if (!res) {
                this._clearTmpAssetsDepends();
                return [ 2, null ];
              }
              this._clearTmpAssetsDepends();
              deps = cc.assetManager.dependUtil.getDepsRecursively(res["_uuid"]) || [];
              deps.push(res["_uuid"]);
              this.addAssetsDepends(deps);
              return [ 2, {
                res: res,
                deps: deps
              } ];
            }
          });
        });
      };
      ResMgr.prototype._destoryResWithReference = function(deps) {
        var _toDeletes = this.removeAssetsDepends(deps);
        this._destoryAssets(_toDeletes);
        return true;
      };
      ResMgr.prototype.addAssetsDepends = function(deps) {
        for (var _i = 0, deps_1 = deps; _i < deps_1.length; _i++) {
          var s = deps_1[_i];
          if (this._checkIsBuiltinAssets(s)) continue;
          this._assetsReference[s] ? this._assetsReference[s] += 1 : this._assetsReference[s] = 1;
        }
      };
      ResMgr.prototype.removeAssetsDepends = function(deps) {
        var _deletes = [];
        for (var _i = 0, deps_2 = deps; _i < deps_2.length; _i++) {
          var s = deps_2[_i];
          if (!this._assetsReference[s] || 0 === this._assetsReference[s]) continue;
          this._assetsReference[s]--;
          if (0 === this._assetsReference[s]) {
            _deletes.push(s);
            delete this._assetsReference[s];
          }
        }
        return _deletes;
      };
      ResMgr.prototype._destoryAssets = function(urls) {
        for (var _i = 0, urls_1 = urls; _i < urls_1.length; _i++) {
          var url = urls_1[_i];
          this._destoryAsset(url);
        }
      };
      ResMgr.prototype._destoryAsset = function(url) {
        if (this._checkIsBuiltinAssets(url)) return;
        var asset = cc.assetManager.assets.get(url);
        if (!asset) return;
        asset.destroy();
        cc.assetManager.assets.remove(url);
        cc.assetManager.dependUtil["remove"](url);
      };
      ResMgr.prototype._addTmpAssetsDepends = function(completedCount, totalCount, item) {
        var _a;
        var deps = cc.assetManager.dependUtil.getDepsRecursively(item.uuid) || [];
        deps.push(item.uuid);
        this.addAssetsDepends(deps);
        (_a = this._tmpAssetsDepends).push.apply(_a, deps);
      };
      ResMgr.prototype._clearTmpAssetsDepends = function() {
        for (var _i = 0, _a = this._tmpAssetsDepends; _i < _a.length; _i++) {
          var s = _a[_i];
          if (!this._assetsReference[s] || 0 === this._assetsReference[s]) continue;
          this._assetsReference[s]--;
          0 === this._assetsReference[s] && delete this._assetsReference[s];
        }
        this._tmpAssetsDepends = [];
      };
      ResMgr.prototype._checkIsBuiltinAssets = function(url) {
        var asset = cc.assetManager.assets.get(url);
        if (asset && -1 != asset["_name"].indexOf("builtin")) return true;
        return false;
      };
      ResMgr.prototype.computeTextureCache = function() {
        var cache = cc.assetManager.assets;
        var totalTextureSize = 0;
        var count = 0;
        cache.forEach(function(item, key) {
          var type = item && item["__classname__"] ? item["__classname__"] : "";
          if ("cc.Texture2D" == type) {
            var texture = item;
            var textureSize = texture.width * texture.height * ((".jpg" === texture["_native"] ? 3 : 4) / 1024 / 1024);
            totalTextureSize += textureSize;
            count++;
          }
        });
        return "\u7f13\u5b58 [\u7eb9\u7406\u603b\u6570:" + count + "][\u7eb9\u7406\u7f13\u5b58:" + totalTextureSize.toFixed(2) + "M]";
      };
      ResMgr.instance = null;
      return ResMgr;
    }();
    exports.default = ResMgr;
    cc._RF.pop();
  }, {
    "./CocosHelper": "CocosHelper"
  } ],
  RoleMgr: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "3b40fEGK7xLwYO1n0n2/Vh5", "RoleMgr");
    "use strict";
    var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const lodash_1 = require("lodash");
    const CommonUtils_1 = require("../../Common/Utils/CommonUtils");
    const utils_1 = require("../../Common/Utils/utils");
    const GlobalData_1 = require("../../Config/GlobalData");
    const InitGameData_1 = require("../../Config/InitGameData");
    class RoleMgr {
      constructor() {
        this._waitQueue = new Map();
        this._home = null;
        this._pos = null;
        this.sitRole = null;
      }
      static get ins() {
        RoleMgr._ins || (RoleMgr._ins = new RoleMgr());
        return RoleMgr._ins;
      }
      init(home, pos) {
        this._home = home;
        this._pos = pos;
      }
      get home() {
        return this._home;
      }
      welcome(role) {
        return this.enqueue(role);
      }
      get firstRole() {
        return this._waitQueue.get(1);
      }
      get waitSize() {
        return this._waitQueue.size;
      }
      enqueue(role) {
        let waitQueueSize = this._waitQueue.size;
        let queueIndex = waitQueueSize + 1;
        role.awaitIndex = queueIndex;
        role.toPos(utils_1.getPosByDesign(cc.v2(this._pos.x, this._pos.y - waitQueueSize * GlobalData_1.GlobalData.gameData.waitingSpeedY)));
        this._waitQueue.set(queueIndex, role);
        return true;
      }
      updateSpareRoles() {
        return __awaiter(this, void 0, void 0, function*() {
          let waitQueueSize = this._waitQueue.size;
          if (!waitQueueSize) return;
          for (let index = 1; index <= waitQueueSize; index++) {
            let waitRole = this._waitQueue.get(index);
            if (!waitRole) return;
            if (1 === index) {
              this._waitQueue.delete(index);
              waitRole.awaitIndex = 0;
            } else {
              waitRole.awaitIndex = index - 1;
              waitRole.toPos(utils_1.getPosByDesign(cc.v2(this._pos.x, this._pos.y - (index - 2) * GlobalData_1.GlobalData.gameData.waitingSpeedY)));
              this._waitQueue.set(index - 1, waitRole);
            }
          }
          this._waitQueue.delete(waitQueueSize);
        });
      }
      getNewRole() {
        let waitQueueSize = this._waitQueue.size;
        let i = 0;
        if (waitQueueSize) {
          let arr = lodash_1.map(InitGameData_1.InitGameData.Role, "name");
          for (let index = 1; index <= waitQueueSize; index++) {
            const waitRole = this._waitQueue.get(index);
            waitRole && lodash_1.pull(arr, waitRole.roleData.name);
          }
          this.sitRole && lodash_1.pull(arr, this.sitRole.roleData.name);
          if (0 === arr.length) return null;
          {
            i = 1 === arr.length ? 0 : CommonUtils_1.CommonUtils.randomIntClosedRange(0, arr.length - 1);
            let role = lodash_1.find(InitGameData_1.InitGameData.Role, item => item.name === arr[i]);
            return role;
          }
        }
        i = CommonUtils_1.CommonUtils.randomIntClosedRange(0, InitGameData_1.InitGameData.Role.length - 1);
        return InitGameData_1.InitGameData.Role[i];
      }
    }
    exports.default = RoleMgr;
    RoleMgr._ins = null;
    cc._RF.pop();
  }, {
    "../../Common/Utils/CommonUtils": "CommonUtils",
    "../../Common/Utils/utils": "utils",
    "../../Config/GlobalData": "GlobalData",
    "../../Config/InitGameData": "InitGameData",
    lodash: 1
  } ],
  SceneMgr: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "df3116tk7BDOqeyh6sIDQKE", "SceneMgr");
    "use strict";
    var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const SysDefine_1 = require("./config/SysDefine");
    const Struct_1 = require("./Struct");
    const TipsMgr_1 = require("./TipsMgr");
    const UIManager_1 = require("./UIManager");
    const TAG = "SceneMgr";
    class SceneMgr {
      constructor() {
        this._scenes = [];
      }
      getCurrScene() {
        return UIManager_1.default.getInstance().getForm(this._currScene.prefabUrl);
      }
      open(form, params, formData) {
        return __awaiter(this, void 0, void 0, function*() {
          form = Struct_1.GetForm(form);
          let scenePath = form.prefabUrl;
          if (this._currScene && this._currScene.prefabUrl == scenePath) {
            cc.warn(TAG, "\u5f53\u524d\u573a\u666f\u548c\u9700\u8981open\u7684\u573a\u666f\u662f\u540c\u4e00\u4e2a");
            return null;
          }
          yield this.openLoading(null === formData || void 0 === formData ? void 0 : formData.loadingForm, params, formData);
          if (this._scenes.length > 0) {
            let currScene = this._scenes[this._scenes.length - 1];
            yield UIManager_1.default.getInstance().closeForm(currScene);
          }
          let idx = -1;
          for (let i = 0; i < this._scenes.length; i++) {
            if (this._scenes[i].prefabUrl !== form.prefabUrl) continue;
            idx = i;
            break;
          }
          -1 == idx ? this._scenes.push(form) : this._scenes.length = idx + 1;
          this._currScene = form;
          let com = yield UIManager_1.default.getInstance().openForm(form, params, formData);
          yield this.closeLoading(null === formData || void 0 === formData ? void 0 : formData.loadingForm);
          return com;
        });
      }
      back(params, formData) {
        return __awaiter(this, void 0, void 0, function*() {
          if (this._scenes.length <= 1) {
            cc.warn(TAG, "\u5df2\u7ecf\u662f\u6700\u540e\u4e00\u4e2a\u573a\u666f\u4e86, \u65e0\u5904\u53ef\u9000");
            return;
          }
          yield this.openLoading(null === formData || void 0 === formData ? void 0 : formData.loadingForm, params, formData);
          let currScene = this._scenes.pop();
          yield UIManager_1.default.getInstance().closeForm(currScene);
          this._currScene = this._scenes[this._scenes.length - 1];
          yield UIManager_1.default.getInstance().openForm(this._currScene, params, formData);
          yield this.closeLoading(null === formData || void 0 === formData ? void 0 : formData.loadingForm);
        });
      }
      close(form, params, formData) {
        return __awaiter(this, void 0, void 0, function*() {
          form = Struct_1.GetForm(form);
          return UIManager_1.default.getInstance().closeForm(form, params, formData);
        });
      }
      openLoading(formConfig, params, formData) {
        return __awaiter(this, void 0, void 0, function*() {
          let form = formConfig || SysDefine_1.SysDefine.defaultLoadingForm;
          if (!form) return;
          yield TipsMgr_1.default.open(form.prefabUrl, params, formData);
        });
      }
      closeLoading(formConfig) {
        return __awaiter(this, void 0, void 0, function*() {
          let form = formConfig || SysDefine_1.SysDefine.defaultLoadingForm;
          if (!form) return;
          yield TipsMgr_1.default.close(form.prefabUrl);
        });
      }
    }
    exports.default = new SceneMgr();
    cc._RF.pop();
  }, {
    "./Struct": "Struct",
    "./TipsMgr": "TipsMgr",
    "./UIManager": "UIManager",
    "./config/SysDefine": "SysDefine"
  } ],
  Scene: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "b13f3yncLhOvJSRs1QLB0sR", "Scene");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = this && this.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (1 & t[0]) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, "function" === typeof Symbol && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([ n, v ]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = 2 & op[0] ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 
          0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          (y = 0, t) && (op = [ 2 & op[0], t.value ]);
          switch (op[0]) {
           case 0:
           case 1:
            t = op;
            break;

           case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

           case 5:
            _.label++;
            y = op[1];
            op = [ 0 ];
            continue;

           case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;

           default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (6 === op[0] || 2 === op[0])) {
              _ = 0;
              continue;
            }
            if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (6 === op[0] && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop();
            _.trys.pop();
            continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [ 6, e ];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (5 & op[0]) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var Game_1 = require("../Logic/Game");
    var AdapterMgr_1 = require("../UIFrame/AdapterMgr");
    var EventCenter_1 = require("../UIFrame/EventCenter");
    var EventType_1 = require("../UIFrame/EventType");
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
    var Scene = function(_super) {
      __extends(Scene, _super);
      function Scene() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.ndBlock = null;
        _this._block = 0;
        return _this;
      }
      Scene_1 = Scene;
      Scene.prototype.onLoad = function() {
        this.initBlockNode();
      };
      Scene.prototype.initBlockNode = function() {
        this.ndBlock = new cc.Node("block");
        this.ndBlock.addComponent(cc.BlockInputEvents);
        this.node.addChild(this.ndBlock, cc.macro.MAX_ZINDEX);
      };
      Scene.prototype.start = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              Scene_1.inst = this;
              AdapterMgr_1.default.inst.adapteByType(AdapterMgr_1.AdapterType.StretchHeight | AdapterMgr_1.AdapterType.StretchWidth, this.node);
              return [ 4, this.onGameInit() ];

             case 1:
              _a.sent();
              this.registerEvent();
              return [ 2 ];
            }
          });
        });
      };
      Scene.prototype.onGameInit = function() {
        return __awaiter(this, void 0, void 0, function() {
          return __generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              return [ 4, Game_1.default.init(this.node) ];

             case 1:
              _a.sent();
              return [ 2 ];
            }
          });
        });
      };
      Scene.prototype.registerEvent = function() {
        if (cc.sys.platform === cc.sys.WECHAT_GAME) {
          wx.onShow(this.onGameShow.bind(this));
          wx.onHide(this.onGameHide.bind(this));
        } else {
          cc.game.on(cc.game.EVENT_SHOW, this.onGameShow, this);
          cc.game.on(cc.game.EVENT_HIDE, this.onGameHide, this);
        }
      };
      Scene.prototype.onGameShow = function(param) {
        EventCenter_1.EventCenter.emit(EventType_1.EventType.GameShow, param);
        cc.director.resume();
      };
      Scene.prototype.onGameHide = function() {
        EventCenter_1.EventCenter.emit(EventType_1.EventType.GameHide);
        cc.director.pause();
      };
      Scene.prototype.update = function(dt) {
        Game_1.default.update(dt);
      };
      Scene.prototype.lateUpdate = function() {};
      Scene.prototype.setInputBlock = function(bool) {
        if (!this.ndBlock) {
          cc.warn("\u672a\u542f\u7528 block input");
          return;
        }
        bool ? ++this._block : --this._block;
        this.ndBlock.active = this._block > 0;
      };
      var Scene_1;
      Scene.inst = null;
      Scene = Scene_1 = __decorate([ ccclass ], Scene);
      return Scene;
    }(cc.Component);
    exports.default = Scene;
    cc._RF.pop();
  }, {
    "../Logic/Game": "Game",
    "../UIFrame/AdapterMgr": "AdapterMgr",
    "../UIFrame/EventCenter": "EventCenter",
    "../UIFrame/EventType": "EventType"
  } ],
  ScrollViewHelper: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "90448z1fXJKVppxfCvCjY6W", "ScrollViewHelper");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ScrollViewHelper = exports.ScrollViewElementProxy = exports.ScrollViewElementProxyState = void 0;
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
    var ScrollViewElementProxyState;
    (function(ScrollViewElementProxyState) {
      ScrollViewElementProxyState[ScrollViewElementProxyState["NoUI"] = 0] = "NoUI";
      ScrollViewElementProxyState[ScrollViewElementProxyState["HaveUI"] = 1] = "HaveUI";
    })(ScrollViewElementProxyState = exports.ScrollViewElementProxyState || (exports.ScrollViewElementProxyState = {}));
    var ScrollViewElementProxy = function() {
      function ScrollViewElementProxy() {
        this.state = ScrollViewElementProxyState.NoUI;
      }
      return ScrollViewElementProxy;
    }();
    exports.ScrollViewElementProxy = ScrollViewElementProxy;
    var ScrollViewHelper = function(_super) {
      __extends(ScrollViewHelper, _super);
      function ScrollViewHelper() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.syncInterval = .05;
        _this._proxys = [];
        _this._syncCounter = 0;
        _this._lastCheckX = 0;
        return _this;
      }
      Object.defineProperty(ScrollViewHelper.prototype, "scrollView", {
        get: function() {
          return this._svCachedScrollView;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ScrollViewHelper.prototype, "datas", {
        get: function() {
          return this._proxys;
        },
        enumerable: false,
        configurable: true
      });
      ScrollViewHelper.prototype.clearData = function() {
        for (var _i = 0, _a = this._proxys; _i < _a.length; _i++) {
          var proxy = _a[_i];
          proxy.ui && this.onFreeUI && this.onFreeUI(proxy);
        }
        this._proxys.length = 0;
      };
      ScrollViewHelper.prototype.addData = function(data) {
        this._initializeProxy(data);
        this._proxys.push(data);
      };
      ScrollViewHelper.prototype.setDebug = function(debug) {
        if (debug && !this._debugNode) {
          this._debugNode = new cc.Node().addComponent(cc.Graphics);
          this.scrollView.content.addChild(this._debugNode.node);
          this._debugNode.node.setPosition(cc.v2(0, 0));
        } else if (!debug && this._debugNode) {
          this._debugNode.node.removeFromParent();
          this._debugNode.node.destroy();
        }
        this._refreshDebug();
      };
      ScrollViewHelper.prototype.checkUI = function() {
        this._checkUIState();
        this._syncingUI = true;
      };
      ScrollViewHelper.prototype.setLoopHorizontal = function(loop) {
        if (loop != this._horizontalLoop) {
          if (loop) {
            for (var i = this._proxys.length - 1; i >= 0; i--) {
              var target = this._proxys[i];
              if (!target.horizontalLoop) {
                var copyed = new ScrollViewElementProxy();
                this._initializeProxy(copyed);
                copyed.src = target.src;
                copyed.region = new cc.Rect(target.region.x, target.region.y, target.region.width, target.region.height);
                copyed.horizontalLoop = true;
                copyed.verticalLoop = target.verticalLoop;
                copyed.region.x += this.scrollView.content.width;
                this._proxys.push(copyed);
              }
            }
            this.scrollView.content.setContentSize(2 * this.scrollView.content.width, this.scrollView.content.height);
          } else {
            for (var i = this._proxys.length - 1; i >= 0; i--) {
              var target = this._proxys[i];
              if (target.horizontalLoop && target.ui) {
                this.onFreeUI(target);
                target.ui = null;
                this._proxys.splice(i, 1);
              }
            }
            this.scrollView.content.setContentSize(this.scrollView.content.width / 2, this.scrollView.content.height);
          }
          this._horizontalLoop = loop;
        }
      };
      ScrollViewHelper.prototype.onLoad = function() {
        this._bindScrollView(this.getComponent(cc.ScrollView));
      };
      ScrollViewHelper.prototype.update = function(dt) {
        if (this._syncingUI) {
          this._syncCounter += dt;
          if (this._syncCounter >= this.syncInterval) {
            this._syncCounter = 0;
            this._syncUIState(1);
          }
        }
      };
      ScrollViewHelper.prototype._initializeProxy = function(proxy) {
        proxy.horizontalLoop = false;
        proxy.src = proxy;
        proxy.state = ScrollViewElementProxyState.NoUI;
        proxy.ui = null;
        proxy.verticalLoop = false;
      };
      ScrollViewHelper.prototype._checkLoopHorizontal = function() {
        var offset = this.scrollView.getScrollOffset();
        var delta = offset.x - this._lastCheckX;
        if (Math.abs(delta) > 2) {
          this._lastCheckX = offset.x;
          var originalWidth = this.scrollView.content.width / 2;
          if (delta < 0 && offset.x < -originalWidth) {
            offset.x += originalWidth;
            this._lastCheckX = offset.x;
            offset.x = -offset.x;
            this.scrollView.scrollToOffset(offset);
          } else if (delta > 0 && offset.x > 0) {
            offset.x -= originalWidth;
            this._lastCheckX = offset.x;
            offset.x = -offset.x;
            this.scrollView.scrollToOffset(offset);
          }
        }
      };
      ScrollViewHelper.prototype._bindScrollView = function(view) {
        this._svCachedScrollView = this.getComponent(cc.ScrollView);
        var eventHandler = new cc.Component.EventHandler();
        eventHandler.target = this.node;
        eventHandler.component = "ScrollViewHelper";
        eventHandler.handler = "_onScroll";
        this._svCachedScrollView.scrollEvents.push(eventHandler);
        this._svCachedScrollView.node.on(cc.Node.EventType.SIZE_CHANGED, this._refreshViewportRect, this);
        this._svCachedScrollView.content.on(cc.Node.EventType.ANCHOR_CHANGED, this._refreshViewportRect, this);
        this._svCachedScrollView.content.on(cc.Node.EventType.SIZE_CHANGED, this._refreshViewportRect, this);
        this._refreshViewportRect();
      };
      ScrollViewHelper.prototype._refreshViewportRect = function() {
        this._rectCachedViewport = cc.rect();
        this._rectCachedViewport.size = this._svCachedScrollView.node.getContentSize();
        this._rectCachedViewport.origin = cc.v2(-this._svCachedScrollView.content.anchorX * this._svCachedScrollView.content.width, (1 - this._svCachedScrollView.content.anchorY) * this._svCachedScrollView.content.height - this._rectCachedViewport.size.height);
        this._checkUIState();
        this._syncingUI = true;
      };
      ScrollViewHelper.prototype._checkUIState = function() {
        var delta = this._svCachedScrollView.getScrollOffset();
        var viewWidth = this._rectCachedViewport.width;
        var viewHeight = this._rectCachedViewport.height;
        var viewX = -delta.x + this._rectCachedViewport.x;
        var viewY = -delta.y + this._rectCachedViewport.y;
        for (var _i = 0, _a = this._proxys; _i < _a.length; _i++) {
          var proxy = _a[_i];
          var rect = proxy.region;
          var x = rect.x;
          var y = rect.y;
          x > viewX - rect.width && x < viewX + viewWidth && y > viewY - rect.height && y < viewY + viewHeight ? proxy.state = ScrollViewElementProxyState.HaveUI : proxy.state = ScrollViewElementProxyState.NoUI;
        }
      };
      ScrollViewHelper.prototype._syncUIState = function(maxAllocCount) {
        var changeCount = 0;
        for (var _i = 0, _a = this._proxys; _i < _a.length; _i++) {
          var proxy = _a[_i];
          if (proxy.state == ScrollViewElementProxyState.NoUI && proxy.ui) {
            this.onFreeUI(proxy);
            changeCount++;
            this._debugNode && cc.log("ScrollViewHelper._syncUIState ----\x3e free ui");
          }
        }
        for (var _b = 0, _c = this._proxys; _b < _c.length; _b++) {
          var proxy = _c[_b];
          if (proxy.state == ScrollViewElementProxyState.HaveUI && !proxy.ui) {
            var pooled = this.isUIPooled && this.isUIPooled(proxy);
            this.onAllocUI(proxy);
            changeCount++;
            pooled || maxAllocCount--;
            this._debugNode && cc.log("ScrollViewHelper._syncUIState ----\x3e alloc ui");
          }
          if (maxAllocCount <= 0) break;
        }
        changeCount <= 0 && (this._syncingUI = false);
      };
      ScrollViewHelper.prototype._onScroll = function() {
        this._horizontalLoop && this._checkLoopHorizontal();
        this._checkUIState();
        this._syncingUI = true;
      };
      ScrollViewHelper.prototype._refreshDebug = function() {
        if (this._debugNode) {
          this._debugNode.clear();
          this._debugNode.fillColor = cc.color(255, 0, 0, 255);
          for (var i = 0; i < this._proxys.length; i++) this._debugNode.fillRect(this._proxys[i].region.x, this._proxys[i].region.y, this._proxys[i].region.width, this._proxys[i].region.height);
        }
      };
      __decorate([ property() ], ScrollViewHelper.prototype, "syncInterval", void 0);
      ScrollViewHelper = __decorate([ ccclass ], ScrollViewHelper);
      return ScrollViewHelper;
    }(cc.Component);
    exports.ScrollViewHelper = ScrollViewHelper;
    cc._RF.pop();
  }, {} ],
  Shake: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "50dd1CK5CZDxKf4hgecFu92", "Shake");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
    var Shake = function(_super) {
      __extends(Shake, _super);
      function Shake() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this._initial_x = 0;
        _this._initial_y = 0;
        _this._strength_x = 0;
        _this._strength_y = 0;
        return _this;
      }
      Shake_1 = Shake;
      Shake.create = function(duration, strength_x, strength_y) {
        var act = new Shake_1();
        act.initWithDuration(duration, strength_x, strength_y);
        return act;
      };
      Shake.prototype.initWithDuration = function(duration, strength_x, strength_y) {
        cc.ActionInterval.prototype["initWithDuration"].apply(this, arguments);
        this._strength_x = strength_x;
        this._strength_y = strength_y;
        return true;
      };
      Shake.prototype.fgRangeRand = function(min, max) {
        var rnd = Math.random();
        return rnd * (max - min) + min;
      };
      Shake.prototype.update = function(time) {
        var randx = this.fgRangeRand(-this._strength_x, this._strength_x);
        var randy = this.fgRangeRand(-this._strength_y, this._strength_y);
        this.getTarget().setPosition(randx + this._initial_x, randy + this._initial_y);
      };
      Shake.prototype.startWithTarget = function(target) {
        cc.ActionInterval.prototype["startWithTarget"].apply(this, arguments);
        this._initial_x = target.x;
        this._initial_y = target.y;
      };
      Shake.prototype.stop = function() {
        this.getTarget().setPosition(new cc.Vec2(this._initial_x, this._initial_y));
        cc.ActionInterval.prototype["stop"].apply(this);
      };
      var Shake_1;
      Shake = Shake_1 = __decorate([ ccclass ], Shake);
      return Shake;
    }(cc.ActionInterval);
    exports.default = Shake;
    cc._RF.pop();
  }, {} ],
  SoundMgr: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "53a8cu6MiRDyaBRISmEhgTZ", "SoundMgr");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = this && this.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (1 & t[0]) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, "function" === typeof Symbol && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([ n, v ]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = 2 & op[0] ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 
          0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          (y = 0, t) && (op = [ 2 & op[0], t.value ]);
          switch (op[0]) {
           case 0:
           case 1:
            t = op;
            break;

           case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

           case 5:
            _.label++;
            y = op[1];
            op = [ 0 ];
            continue;

           case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;

           default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (6 === op[0] || 2 === op[0])) {
              _ = 0;
              continue;
            }
            if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (6 === op[0] && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop();
            _.trys.pop();
            continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [ 6, e ];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (5 & op[0]) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var CocosHelper_1 = require("./CocosHelper");
    var SysDefine_1 = require("./config/SysDefine");
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
    var SoundMgr = function(_super) {
      __extends(SoundMgr, _super);
      function SoundMgr() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.audioCache = cc.js.createMap();
        _this.currEffectId = -1;
        _this.currMusicId = -1;
        _this.volume = new Volume();
        return _this;
      }
      Object.defineProperty(SoundMgr, "inst", {
        get: function() {
          null == this._inst && (this._inst = cc.find(SysDefine_1.SysDefine.SYS_UIROOT_NAME).addComponent(this));
          return this._inst;
        },
        enumerable: false,
        configurable: true
      });
      SoundMgr.prototype.onLoad = function() {
        var volume = this.getVolumeToLocal();
        if (volume) this.volume = volume; else {
          this.volume.musicVolume = 1;
          this.volume.effectVolume = 1;
        }
        this.setVolumeToLocal();
        cc.game.on(cc.game.EVENT_HIDE, function() {
          cc.audioEngine.pauseAll();
        }, this);
        cc.game.on(cc.game.EVENT_SHOW, function() {
          cc.audioEngine.resumeAll();
        }, this);
      };
      SoundMgr.prototype.getVolume = function() {
        return this.volume;
      };
      SoundMgr.prototype.start = function() {};
      SoundMgr.prototype.setMusicVolume = function(musicVolume) {
        this.volume.musicVolume = musicVolume;
        this.setVolumeToLocal();
      };
      SoundMgr.prototype.setEffectVolume = function(effectVolume) {
        this.volume.effectVolume = effectVolume;
        this.setVolumeToLocal();
      };
      SoundMgr.prototype.playMusic = function(url, loop) {
        void 0 === loop && (loop = true);
        return __awaiter(this, void 0, void 0, function() {
          var sound;
          return __generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              if (!url || "" === url) return [ 2 ];
              if (this.audioCache[url]) {
                cc.audioEngine.playMusic(this.audioCache[url], loop);
                return [ 2 ];
              }
              return [ 4, CocosHelper_1.default.loadResSync(url, cc.AudioClip) ];

             case 1:
              sound = _a.sent();
              this.audioCache[url] = sound;
              this.currMusicId = cc.audioEngine.playMusic(sound, loop);
              return [ 2 ];
            }
          });
        });
      };
      SoundMgr.prototype.playEffect = function(url, loop) {
        void 0 === loop && (loop = false);
        return __awaiter(this, void 0, void 0, function() {
          var sound;
          return __generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              if (!url || "" === url) return [ 2 ];
              if (this.audioCache[url]) {
                cc.audioEngine.playEffect(this.audioCache[url], loop);
                return [ 2 ];
              }
              return [ 4, CocosHelper_1.default.loadResSync(url, cc.AudioClip) ];

             case 1:
              sound = _a.sent();
              this.audioCache[url] = sound;
              this.currEffectId = cc.audioEngine.playEffect(sound, loop);
              return [ 2 ];
            }
          });
        });
      };
      SoundMgr.prototype.getVolumeToLocal = function() {
        var objStr = cc.sys.localStorage.getItem("Volume_For_Creator");
        if (!objStr) return null;
        return JSON.parse(objStr);
      };
      SoundMgr.prototype.setVolumeToLocal = function() {
        cc.audioEngine.setMusicVolume(this.volume.musicVolume);
        cc.audioEngine.setEffectsVolume(this.volume.effectVolume);
        cc.sys.localStorage.setItem("Volume_For_Creator", JSON.stringify(this.volume));
      };
      SoundMgr.prototype.setEffectActive = function(active, id) {
        void 0 === id && (id = -1);
        active ? cc.audioEngine.stop(id < 0 ? this.currEffectId : id) : cc.audioEngine.resume(id < 0 ? this.currEffectId : id);
      };
      SoundMgr._inst = null;
      SoundMgr = __decorate([ ccclass ], SoundMgr);
      return SoundMgr;
    }(cc.Component);
    exports.default = SoundMgr;
    var Volume = function() {
      function Volume() {}
      return Volume;
    }();
    cc._RF.pop();
  }, {
    "./CocosHelper": "CocosHelper",
    "./config/SysDefine": "SysDefine"
  } ],
  SpinePlus: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "30062r80kNGeKSQLxsTnRWf", "SpinePlus");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property, executeInEditMode = _a.executeInEditMode, menu = _a.menu, help = _a.help, inspector = _a.inspector;
    var SpinePlus = function(_super) {
      __extends(SpinePlus, _super);
      function SpinePlus() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.paused = false;
        return _this;
      }
      SpinePlus.prototype.start = function() {};
      SpinePlus.prototype.update = function(dt) {
        true;
        _super.prototype.update.call(this, dt);
        return;
      };
      __decorate([ property({
        override: true,
        visible: true
      }) ], SpinePlus.prototype, "paused", void 0);
      SpinePlus = __decorate([ ccclass, menu("i18n:MAIN_MENU.component.ui/SpinePlus"), executeInEditMode, help("app://docs/html/components/spine.html"), inspector("packages://custom-inspector/inspector/spine.js") ], SpinePlus);
      return SpinePlus;
    }(sp.Skeleton);
    exports.default = SpinePlus;
    cc._RF.pop();
  }, {} ],
  StateMachine: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "a7054SKrgdF4Z4s5xp++8qZ", "StateMachine");
    "use strict";
    (function() {
      var StateMachine = {
        VERSION: "2.4.0",
        Result: {
          SUCCEEDED: 1,
          NOTRANSITION: 2,
          CANCELLED: 3,
          PENDING: 4
        },
        Error: {
          INVALID_TRANSITION: 100,
          PENDING_TRANSITION: 200,
          INVALID_CALLBACK: 300
        },
        WILDCARD: "*",
        ASYNC: "async",
        create: function create(cfg, target) {
          var initial = "string" == typeof cfg.initial ? {
            state: cfg.initial
          } : cfg.initial;
          var terminal = cfg.terminal || cfg["final"];
          var fsm = target || cfg.target || {};
          var events = cfg.events || [];
          var callbacks = cfg.callbacks || {};
          var map = {};
          var transitions = {};
          var add = function add(e) {
            var from = Array.isArray(e.from) ? e.from : e.from ? [ e.from ] : [ StateMachine.WILDCARD ];
            map[e.name] = map[e.name] || {};
            for (var n = 0; n < from.length; n++) {
              transitions[from[n]] = transitions[from[n]] || [];
              transitions[from[n]].push(e.name);
              map[e.name][from[n]] = e.to || from[n];
            }
            e.to && (transitions[e.to] = transitions[e.to] || []);
          };
          if (initial) {
            initial.event = initial.event || "startup";
            add({
              name: initial.event,
              from: "none",
              to: initial.state
            });
          }
          for (var n = 0; n < events.length; n++) add(events[n]);
          for (var name in map) map.hasOwnProperty(name) && (fsm[name] = StateMachine.buildEvent(name, map[name]));
          for (var name in callbacks) callbacks.hasOwnProperty(name) && (fsm[name] = callbacks[name]);
          fsm.current = "none";
          fsm.is = function(state) {
            return Array.isArray(state) ? state.indexOf(this.current) >= 0 : this.current === state;
          };
          fsm.can = function(event) {
            return !this.transition && void 0 !== map[event] && (map[event].hasOwnProperty(this.current) || map[event].hasOwnProperty(StateMachine.WILDCARD));
          };
          fsm.cannot = function(event) {
            return !this.can(event);
          };
          fsm.transitions = function() {
            return (transitions[this.current] || []).concat(transitions[StateMachine.WILDCARD] || []);
          };
          fsm.isFinished = function() {
            return this.is(terminal);
          };
          fsm.error = cfg.error || function(name, from, to, args, error, msg, e) {
            throw e || msg;
          };
          fsm.states = function() {
            return Object.keys(transitions).sort();
          };
          initial && !initial.defer && fsm[initial.event]();
          return fsm;
        },
        doCallback: function doCallback(fsm, func, name, from, to, args) {
          if (func) try {
            return func.apply(fsm, [ name, from, to ].concat(args));
          } catch (e) {
            return fsm.error(name, from, to, args, StateMachine.Error.INVALID_CALLBACK, "an exception occurred in a caller-provided callback function", e);
          }
        },
        beforeAnyEvent: function beforeAnyEvent(fsm, name, from, to, args) {
          return StateMachine.doCallback(fsm, fsm["onbeforeevent"], name, from, to, args);
        },
        afterAnyEvent: function afterAnyEvent(fsm, name, from, to, args) {
          return StateMachine.doCallback(fsm, fsm["onafterevent"] || fsm["onevent"], name, from, to, args);
        },
        leaveAnyState: function leaveAnyState(fsm, name, from, to, args) {
          return StateMachine.doCallback(fsm, fsm["onleavestate"], name, from, to, args);
        },
        enterAnyState: function enterAnyState(fsm, name, from, to, args) {
          return StateMachine.doCallback(fsm, fsm["onenterstate"] || fsm["onstate"], name, from, to, args);
        },
        changeState: function changeState(fsm, name, from, to, args) {
          return StateMachine.doCallback(fsm, fsm["onchangestate"], name, from, to, args);
        },
        beforeThisEvent: function beforeThisEvent(fsm, name, from, to, args) {
          return StateMachine.doCallback(fsm, fsm["onbefore" + name], name, from, to, args);
        },
        afterThisEvent: function afterThisEvent(fsm, name, from, to, args) {
          return StateMachine.doCallback(fsm, fsm["onafter" + name] || fsm["on" + name], name, from, to, args);
        },
        leaveThisState: function leaveThisState(fsm, name, from, to, args) {
          return StateMachine.doCallback(fsm, fsm["onleave" + from], name, from, to, args);
        },
        enterThisState: function enterThisState(fsm, name, from, to, args) {
          return StateMachine.doCallback(fsm, fsm["onenter" + to] || fsm["on" + to], name, from, to, args);
        },
        beforeEvent: function beforeEvent(fsm, name, from, to, args) {
          if (false === StateMachine.beforeThisEvent(fsm, name, from, to, args) || false === StateMachine.beforeAnyEvent(fsm, name, from, to, args)) return false;
        },
        afterEvent: function afterEvent(fsm, name, from, to, args) {
          StateMachine.afterThisEvent(fsm, name, from, to, args);
          StateMachine.afterAnyEvent(fsm, name, from, to, args);
        },
        leaveState: function leaveState(fsm, name, from, to, args) {
          var specific = StateMachine.leaveThisState(fsm, name, from, to, args), general = StateMachine.leaveAnyState(fsm, name, from, to, args);
          if (false === specific || false === general) return false;
          if (StateMachine.ASYNC === specific || StateMachine.ASYNC === general) return StateMachine.ASYNC;
        },
        enterState: function enterState(fsm, name, from, to, args) {
          StateMachine.enterThisState(fsm, name, from, to, args);
          StateMachine.enterAnyState(fsm, name, from, to, args);
        },
        buildEvent: function buildEvent(name, map) {
          return function() {
            var from = this.current;
            var to = map[from] || (map[StateMachine.WILDCARD] != StateMachine.WILDCARD ? map[StateMachine.WILDCARD] : from) || from;
            var args = Array.prototype.slice.call(arguments);
            if (this.transition) return this.error(name, from, to, args, StateMachine.Error.PENDING_TRANSITION, "event " + name + " inappropriate because previous transition did not complete");
            if (this.cannot(name)) return this.error(name, from, to, args, StateMachine.Error.INVALID_TRANSITION, "event " + name + " inappropriate in current state " + this.current);
            if (false === StateMachine.beforeEvent(this, name, from, to, args)) return StateMachine.Result.CANCELLED;
            if (from === to) {
              StateMachine.afterEvent(this, name, from, to, args);
              return StateMachine.Result.NOTRANSITION;
            }
            var fsm = this;
            this.transition = function() {
              fsm.transition = null;
              fsm.current = to;
              StateMachine.enterState(fsm, name, from, to, args);
              StateMachine.changeState(fsm, name, from, to, args);
              StateMachine.afterEvent(fsm, name, from, to, args);
              return StateMachine.Result.SUCCEEDED;
            };
            this.transition.cancel = function() {
              fsm.transition = null;
              StateMachine.afterEvent(fsm, name, from, to, args);
            };
            var leave = StateMachine.leaveState(this, name, from, to, args);
            if (false === leave) {
              this.transition = null;
              return StateMachine.Result.CANCELLED;
            }
            if (StateMachine.ASYNC === leave) return StateMachine.Result.PENDING;
            if (this.transition) return this.transition();
          };
        }
      };
      if ("undefined" !== typeof exports) {
        "undefined" !== typeof module && module.exports && (exports = module.exports = StateMachine);
        exports.StateMachine = StateMachine;
      } else "function" === typeof define && define.amd ? define(function(require) {
        return StateMachine;
      }) : "undefined" !== typeof window ? window.StateMachine = StateMachine : "undefined" !== typeof self && (self.StateMachine = StateMachine);
    })();
    cc._RF.pop();
  }, {} ],
  StorageManager: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "dd7a2IgIyVF7YOn30TqGHgN", "StorageManager");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.StorageManager = void 0;
    var EncryptUtil_1 = require("../Utils/EncryptUtil");
    var StorageManager = function() {
      function StorageManager() {
        this._key = null;
        this._iv = null;
        this._id = null;
      }
      StorageManager.prototype.init = function(key, iv) {
        EncryptUtil_1.EncryptUtil.initCrypto(key, iv);
        this._key = EncryptUtil_1.EncryptUtil.md5(key);
        this._iv = EncryptUtil_1.EncryptUtil.md5(iv);
      };
      StorageManager.prototype.setUser = function(id) {
        this._id = id;
      };
      StorageManager.prototype.set = function(key, value) {
        var keywords = this.getKey(key);
        if (null == key) {
          console.error("\u5b58\u50a8\u7684key\u4e0d\u80fd\u4e3a\u7a7a");
          return;
        }
        this.encrypted && (keywords = EncryptUtil_1.EncryptUtil.md5(keywords));
        if (null == value) {
          console.warn("\u5b58\u50a8\u7684\u503c\u4e3a\u7a7a\uff0c\u5219\u76f4\u63a5\u79fb\u9664\u8be5\u5b58\u50a8");
          this.remove(key);
          return;
        }
        if ("function" === typeof value) {
          console.error("\u50a8\u5b58\u7684\u503c\u4e0d\u80fd\u4e3a\u65b9\u6cd5");
          return;
        }
        if ("object" === typeof value) try {
          value = JSON.stringify(value);
        } catch (e) {
          console.error("\u89e3\u6790\u5931\u8d25\uff0cstr = " + value);
          return;
        } else "number" === typeof value && (value += "");
        this.encrypted && null != this._key && null != this._iv && (value = EncryptUtil_1.EncryptUtil.aesEncrypt("" + value, this._key, this._iv));
        cc.sys.localStorage.setItem(keywords, value);
      };
      StorageManager.prototype.get = function(key, defaultValue) {
        void 0 === defaultValue && (defaultValue = "");
        if (null == key) {
          console.error("\u5b58\u50a8\u7684key\u4e0d\u80fd\u4e3a\u7a7a");
          return null;
        }
        key = this.getKey(key);
        this.encrypted && (key = EncryptUtil_1.EncryptUtil.md5(key));
        var str = cc.sys.localStorage.getItem(key);
        null != str && "" !== str && this.encrypted && null != this._key && null != this._iv && (str = EncryptUtil_1.EncryptUtil.aesDecrypt(str, this._key, this._iv));
        if (null === str) return defaultValue;
        return str;
      };
      StorageManager.prototype.getNumber = function(key, defaultValue) {
        void 0 === defaultValue && (defaultValue = 0);
        var r = this.get(key);
        if ("0" == r) return Number(r);
        return Number(r) || defaultValue;
      };
      StorageManager.prototype.getBoolean = function(key) {
        var r = this.get(key);
        return "true" === r.toLowerCase();
      };
      StorageManager.prototype.getJson = function(key, defaultValue) {
        var r = this.get(key);
        return r && JSON.parse(r) || defaultValue;
      };
      StorageManager.prototype.remove = function(key) {
        if (null == key) {
          console.error("\u5b58\u50a8\u7684key\u4e0d\u80fd\u4e3a\u7a7a");
          return;
        }
        var keywords = this.getKey(key);
        this.encrypted && (keywords = EncryptUtil_1.EncryptUtil.md5(keywords));
        cc.sys.localStorage.removeItem(keywords);
      };
      StorageManager.prototype.clear = function() {
        cc.sys.localStorage.clear();
      };
      StorageManager.prototype.getKey = function(key) {
        if (null == this._id || "" == this._id) return key;
        return this._id + "_" + key;
      };
      Object.defineProperty(StorageManager.prototype, "encrypted", {
        get: function() {
          return true;
        },
        enumerable: false,
        configurable: true
      });
      return StorageManager;
    }();
    exports.StorageManager = StorageManager;
    cc._RF.pop();
  }, {
    "../Utils/EncryptUtil": "EncryptUtil"
  } ],
  Struct: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "10f94bOjGlIYIzXaowVjrbs", "Struct");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.ECloseType = exports.EPriority = exports.GetForm = exports.ModalType = void 0;
    var SysDefine_1 = require("./config/SysDefine");
    var ModalType = function() {
      function ModalType(opacity, ClickMaskClose, IsEasing, EasingTime) {
        void 0 === opacity && (opacity = SysDefine_1.ModalOpacity.OpacityHalf);
        void 0 === ClickMaskClose && (ClickMaskClose = false);
        void 0 === IsEasing && (IsEasing = true);
        void 0 === EasingTime && (EasingTime = .2);
        this.opacity = SysDefine_1.ModalOpacity.OpacityHalf;
        this.clickMaskClose = false;
        this.isEasing = true;
        this.easingTime = .2;
        this.dualBlur = false;
        this.opacity = opacity;
        this.clickMaskClose = ClickMaskClose;
        this.isEasing = IsEasing;
        this.easingTime = EasingTime;
      }
      ModalType.prototype.useBlur = function() {
        this.dualBlur = true;
        return this;
      };
      return ModalType;
    }();
    exports.ModalType = ModalType;
    function GetForm(form, type) {
      void 0 === type && (type = SysDefine_1.FormType.Screen);
      if ("string" === typeof form) return {
        prefabUrl: form,
        type: type
      };
      return form;
    }
    exports.GetForm = GetForm;
    var EPriority;
    (function(EPriority) {
      EPriority[EPriority["ZERO"] = 0] = "ZERO";
      EPriority[EPriority["ONE"] = 1] = "ONE";
      EPriority[EPriority["TWO"] = 2] = "TWO";
      EPriority[EPriority["THREE"] = 3] = "THREE";
      EPriority[EPriority["FOUR"] = 4] = "FOUR";
      EPriority[EPriority["FIVE"] = 5] = "FIVE";
      EPriority[EPriority["SIX"] = 6] = "SIX";
      EPriority[EPriority["SEVEN"] = 7] = "SEVEN";
      EPriority[EPriority["EIGHT"] = 8] = "EIGHT";
      EPriority[EPriority["NINE"] = 9] = "NINE";
    })(EPriority = exports.EPriority || (exports.EPriority = {}));
    var ECloseType;
    (function(ECloseType) {
      ECloseType[ECloseType["CloseAndHide"] = 0] = "CloseAndHide";
      ECloseType[ECloseType["CloseAndDestory"] = 1] = "CloseAndDestory";
      ECloseType[ECloseType["LRU"] = 2] = "LRU";
    })(ECloseType = exports.ECloseType || (exports.ECloseType = {}));
    cc._RF.pop();
  }, {
    "./config/SysDefine": "SysDefine"
  } ],
  SysConfig: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "9963eJiicZFX5wMEhMsIL+C", "SysConfig");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SysConfig = void 0;
    var SysConfig = function() {
      function SysConfig() {}
      SysConfig.useLRUCache = false;
      return SysConfig;
    }();
    exports.SysConfig = SysConfig;
    cc._RF.pop();
  }, {} ],
  SysDefine: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "7ef5dNjssZO34e85HHLM2ES", "SysDefine");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.SysDefine = exports.UIState = exports.LayerLevel = exports.ModalOpacity = exports.FormType = void 0;
    const UIConfig_1 = require("../../UIConfig");
    var FormType;
    (function(FormType) {
      FormType["Screen"] = "UIScreen";
      FormType["Drawer"] = "UIDrawer";
      FormType["Fixed"] = "UIFixed";
      FormType["Window"] = "UIWindow";
      FormType["Toast"] = "UIToast";
      FormType["Tips"] = "UITips";
    })(FormType = exports.FormType || (exports.FormType = {}));
    var ModalOpacity;
    (function(ModalOpacity) {
      ModalOpacity[ModalOpacity["None"] = 0] = "None";
      ModalOpacity[ModalOpacity["OpacityZero"] = 1] = "OpacityZero";
      ModalOpacity[ModalOpacity["OpacityLow"] = 2] = "OpacityLow";
      ModalOpacity[ModalOpacity["OpacityHalf"] = 3] = "OpacityHalf";
      ModalOpacity[ModalOpacity["OpacityHigh"] = 4] = "OpacityHigh";
      ModalOpacity[ModalOpacity["OpacityFull"] = 5] = "OpacityFull";
      ModalOpacity[ModalOpacity["GuassBlur"] = 6] = "GuassBlur";
    })(ModalOpacity = exports.ModalOpacity || (exports.ModalOpacity = {}));
    var LayerLevel;
    (function(LayerLevel) {
      LayerLevel[LayerLevel["DefaultLayer"] = 1] = "DefaultLayer";
      LayerLevel[LayerLevel["SiteRole"] = 888] = "SiteRole";
      LayerLevel[LayerLevel["SitTable"] = 999] = "SitTable";
    })(LayerLevel = exports.LayerLevel || (exports.LayerLevel = {}));
    var UIState;
    (function(UIState) {
      UIState[UIState["None"] = 0] = "None";
      UIState[UIState["Loading"] = 1] = "Loading";
      UIState[UIState["Showing"] = 2] = "Showing";
      UIState[UIState["Hiding"] = 3] = "Hiding";
    })(UIState = exports.UIState || (exports.UIState = {}));
    class SysDefine {}
    exports.SysDefine = SysDefine;
    SysDefine.defaultLoadingForm = UIConfig_1.default.UILoading;
    SysDefine.SYS_PATH_CANVAS = "Canvas";
    SysDefine.SYS_PATH_UIFORMS_CONFIG_INFO = "UIFormsConfigInfo";
    SysDefine.SYS_PATH_CONFIG_INFO = "SysConfigInfo";
    SysDefine.SYS_UIROOT_NAME = "Canvas/Scene/UIROOT";
    SysDefine.SYS_UIMODAL_NAME = "Canvas/Scene/UIROOT/UIModalManager";
    SysDefine.SYS_UIAdapter_NAME = "Canvas/Scene/UIROOT/UIAdapterManager";
    SysDefine.SYS_SCENE_NODE = "Scene";
    SysDefine.SYS_UIROOT_NODE = "UIROOT";
    SysDefine.SYS_SCREEN_NODE = "Screen";
    SysDefine.SYS_DRAWER_NODE = "Drawer";
    SysDefine.SYS_FIXED_NODE = "FixedUI";
    SysDefine.SYS_POPUP_NODE = "PopUp";
    SysDefine.SYS_TOPTIPS_NODE = "TopTips";
    SysDefine.SYS_TOAST_NODE = "Toast";
    SysDefine.SYS_MODAL_NODE = "UIModalNode";
    SysDefine.SYS_STANDARD_Prefix = "_";
    SysDefine.SYS_STANDARD_Separator = "$";
    SysDefine.SYS_STANDARD_End = "#";
    SysDefine.UI_PATH_ROOT = "UIForms/";
    SysDefine.SeparatorMap = {
      _Node: "cc.Node",
      _Label: "cc.Label",
      _Button: "cc.Button",
      _Sprite: "cc.Sprite",
      _RichText: "cc.RichText",
      _Mask: "cc.Mask",
      _MotionStreak: "cc.MotionStreak",
      _TiledMap: "cc.TiledMap",
      _TiledTile: "cc.TiledTile",
      _Spine: "sp.Skeleton",
      _Graphics: "cc.Graphics",
      _Animation: "cc.Animation",
      _WebView: "cc.WebView",
      _EditBox: "cc.EditBox",
      _ScrollView: "cc.ScrollView",
      _VideoPlayer: "cc.VideoPlayer",
      _ProgressBar: "cc.ProgressBar",
      _PageView: "cc.PageView",
      _Slider: "cc.Slider",
      _Toggle: "cc.Toggle",
      _ButtonPlus: "ButtonPlus"
    };
    cc._RF.pop();
  }, {
    "../../UIConfig": "UIConfig"
  } ],
  TableKey: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "2c9ccWoPjNC3ojqmpTBe2gS", "TableKey");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.TableKey = void 0;
    var TableKey;
    (function(TableKey) {
      TableKey["RECIPE"] = "RECIPE";
      TableKey["ROLE"] = "ROLE";
      TableKey["MATE"] = "MATE";
      TableKey["NPC"] = "NPC";
      TableKey["BACKPACK"] = "BACKPACK";
      TableKey["USER"] = "USER";
      TableKey["SHOP"] = "SHOP";
      TableKey["TABLE"] = "TABLE";
      TableKey["ORNAMENTS"] = "ORNAMENTS";
      TableKey["WARDROBE"] = "WARDROBE";
    })(TableKey = exports.TableKey || (exports.TableKey = {}));
    cc._RF.pop();
  }, {} ],
  TableMgr: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "9d6darNywdMQb+BzcUyTUVK", "TableMgr");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const lodash_1 = require("lodash");
    const GlobalData_1 = require("../../Config/GlobalData");
    const TableKey_1 = require("../../Config/TableKey");
    const MessageType_1 = require("../../Enum/MessageType");
    const Game_1 = require("../../Logic/Game");
    const BuildGrid_1 = require("../Item/BuildGrid");
    const BaseTable_1 = require("../base/BaseTable");
    class TableMgr {
      constructor() {
        this._home = null;
        this._tableArr = [];
      }
      static get ins() {
        TableMgr._ins || (TableMgr._ins = new TableMgr());
        return TableMgr._ins;
      }
      queryNullTable() {
        let nullTable = this._tableArr.find(item => item.state === MessageType_1.TableType.NONE);
        return nullTable;
      }
      init(home) {
        this._home = home;
      }
      addTable(dataArr, isInsert = false) {
        for (let data of dataArr) {
          let node = this._home.tablePool.get();
          if (!node) return;
          this._home.view.Obs.addChild(node);
          const gridNode = this._home.view.Build.children[data.index];
          const wpos = gridNode.convertToWorldSpaceAR(cc.v3(0, 0));
          const pos = this._home.view.Obs.convertToNodeSpaceAR(wpos);
          node.position = pos;
          let table = node.getComponent(BaseTable_1.default);
          table.init(this._home, data, gridNode.getComponent(BuildGrid_1.default));
          this._tableArr.push(table);
        }
        if (isInsert) {
          let storeData = lodash_1.cloneDeep(this._home.storeData);
          storeData.decorates = [ ...storeData.decorates, ...dataArr ];
          Game_1.default.dbMgr.update(TableKey_1.TableKey.SHOP, storeData, {
            uid: GlobalData_1.GlobalData.userId
          });
        }
        this._home.updateMap(...this._home.view.Obs.children);
      }
    }
    exports.default = TableMgr;
    TableMgr._ins = null;
    cc._RF.pop();
  }, {
    "../../Config/GlobalData": "GlobalData",
    "../../Config/TableKey": "TableKey",
    "../../Enum/MessageType": "MessageType",
    "../../Logic/Game": "Game",
    "../Item/BuildGrid": "BuildGrid",
    "../base/BaseTable": "BaseTable",
    lodash: 1
  } ],
  TaskMgr: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "a001c6UsFtNA5aXLrNhEDJy", "TaskMgr");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Command = exports.CommandType = void 0;
    var PriorityQueue_1 = require("./PriorityQueue");
    var CommandType;
    (function(CommandType) {})(CommandType = exports.CommandType || (exports.CommandType = {}));
    var Command = function() {
      function Command() {}
      return Command;
    }();
    exports.Command = Command;
    var TaskMgr = function() {
      function TaskMgr() {
        this._cmdMap = cc.js.createMap();
        this._debugHistory = [];
        this._debug = false;
      }
      Object.defineProperty(TaskMgr, "inst", {
        get: function() {
          this._instance || (this._instance = new TaskMgr());
          return this._instance;
        },
        enumerable: false,
        configurable: true
      });
      TaskMgr.prototype.setDebug = function(debug) {
        void 0 === debug && (debug = true);
        this._debug = debug;
      };
      TaskMgr.prototype.pushCommand = function(key, command, pIdx) {
        void 0 === pIdx && (pIdx = 0);
        this._debug && this._debugHistory.push(command);
        var cmdQueue = this._cmdMap[key];
        cmdQueue || (cmdQueue = this._cmdMap[key] = new PriorityQueue_1.default());
        cmdQueue.enqueue(command, pIdx);
      };
      TaskMgr.prototype.popCommand = function(key) {
        var cmdQueue = this._cmdMap[key];
        if (!cmdQueue) return null;
        return cmdQueue.dequeue();
      };
      TaskMgr.prototype.hasCommand = function(ele, key) {
        if (key) {
          var cmdQueue = this._cmdMap[key];
          return cmdQueue.hasElement(ele);
        }
        for (var key_1 in this._cmdMap) if (this._cmdMap[key_1].hasElement(ele)) return true;
        return false;
      };
      TaskMgr._instance = null;
      return TaskMgr;
    }();
    exports.default = TaskMgr;
    cc._RF.pop();
  }, {
    "./PriorityQueue": "PriorityQueue"
  } ],
  TextureAssembler: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "e0687tDW69CxalPcgT1Omra", "TextureAssembler");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var CommonUtils_1 = require("../Utils/CommonUtils");
    var gfx = cc["gfx"];
    var vfmtPosUvColor = new gfx.VertexFormat([ {
      name: gfx.ATTR_POSITION,
      type: gfx.ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: gfx.ATTR_UV0,
      type: gfx.ATTR_TYPE_FLOAT32,
      num: 2
    }, {
      name: gfx.ATTR_COLOR,
      type: gfx.ATTR_TYPE_UINT8,
      num: 4,
      normalize: true
    } ]);
    var TextureAssembler = function(_super) {
      __extends(TextureAssembler, _super);
      function TextureAssembler() {
        var _this = _super.call(this) || this;
        _this.verticesCount = 4;
        _this.indicesCount = 6;
        _this.floatsPerVert = 5;
        _this.uvOffset = 2;
        _this.colorOffset = 4;
        _this._renderData = null;
        _this._renderData = new cc.RenderData();
        _this._renderData.init(_this);
        _this.initData();
        return _this;
      }
      Object.defineProperty(TextureAssembler.prototype, "verticesFloats", {
        get: function() {
          return this.verticesCount * this.floatsPerVert;
        },
        enumerable: false,
        configurable: true
      });
      TextureAssembler.prototype.getVfmt = function() {
        return vfmtPosUvColor;
      };
      TextureAssembler.prototype.getBuffer = function() {
        return cc.renderer["_handle"].getBuffer("mesh", this.getVfmt());
      };
      TextureAssembler.prototype.initData = function() {
        var data = this._renderData;
        data.createQuadData(0, this.verticesFloats, this.indicesCount);
      };
      TextureAssembler.prototype.resetData = function(comp) {
        var points = comp.polygon;
        if (!points || points.length < 3) return;
        this.verticesCount = points.length;
        this.indicesCount = this.verticesCount + 2 * (this.verticesCount - 3);
        this._renderData["clear"]();
        this.initData();
      };
      TextureAssembler.prototype.initQuadIndices = function(indices, arr) {
        for (var i = 0; i < arr.length; i++) indices[i] = arr[i];
      };
      TextureAssembler.prototype.updateColor = function(comp, color) {
        var uintVerts = this._renderData.uintVDatas[0];
        if (!uintVerts) return;
        color = null != color ? color : comp.node.color["_val"];
        var floatsPerVert = this.floatsPerVert;
        var colorOffset = this.colorOffset;
        var polygon = comp.polygon;
        for (var i = 0; i < polygon.length; i++) uintVerts[colorOffset + i * floatsPerVert] = color;
      };
      TextureAssembler.prototype.updateUVs = function(comp) {
        var uvOffset = this.uvOffset;
        var floatsPerVert = this.floatsPerVert;
        var verts = this._renderData.vDatas[0];
        var uvs = CommonUtils_1.CommonUtils.computeUv(comp.polygon, comp.node.width, comp.node.height);
        var polygon = comp.polygon;
        for (var i = 0; i < polygon.length; i++) {
          var dstOffset = floatsPerVert * i + uvOffset;
          verts[dstOffset] = uvs[i].x;
          verts[dstOffset + 1] = uvs[i].y;
        }
      };
      TextureAssembler.prototype.updateWorldVertsWebGL = function(comp) {
        var verts = this._renderData.vDatas[0];
        var matrix = comp.node["_worldMatrix"];
        var matrixm = matrix.m, a = matrixm[0], b = matrixm[1], c = matrixm[4], d = matrixm[5], tx = matrixm[12], ty = matrixm[13];
        var justTranslate = 1 === a && 0 === b && 0 === c && 1 === d;
        var floatsPerVert = this.floatsPerVert;
        if (justTranslate) {
          var polygon = comp.polygon;
          for (var i = 0; i < polygon.length; i++) {
            verts[i * floatsPerVert] = polygon[i].x + tx;
            verts[i * floatsPerVert + 1] = polygon[i].y + ty;
          }
        } else {
          var polygon = comp.polygon;
          for (var i = 0; i < polygon.length; i++) {
            verts[i * floatsPerVert] = a * polygon[i].x + c * polygon[i].y + tx;
            verts[i * floatsPerVert + 1] = b * polygon[i].x + d * polygon[i].y + ty;
          }
        }
      };
      TextureAssembler.prototype.updateWorldVertsNative = function(comp) {
        var verts = this._renderData.vDatas[0];
        var floatsPerVert = this.floatsPerVert;
        var polygon = comp.polygon;
        for (var i = 0; i < polygon.length; i++) {
          verts[i * floatsPerVert] = polygon[i].x;
          verts[i * floatsPerVert + 1] = polygon[i].y;
        }
      };
      TextureAssembler.prototype.updateWorldVerts = function(comp) {
        false;
        this.updateWorldVertsWebGL(comp);
      };
      TextureAssembler.prototype.updateVerts = function(comp) {
        var indicesArr = CommonUtils_1.CommonUtils.splitePolygon(comp.polygon);
        this.initQuadIndices(this._renderData.iDatas[0], indicesArr);
        this.updateWorldVerts(comp);
      };
      TextureAssembler.prototype.updateRenderData = function(comp) {
        if (comp._vertsDirty) {
          this.resetData(comp);
          this.updateUVs(comp);
          this.updateVerts(comp);
          this.updateColor(comp, null);
          comp._vertsDirty = false;
        }
      };
      TextureAssembler.prototype.fillBuffers = function(comp, renderer) {
        renderer.worldMatDirty && this.updateWorldVerts(comp);
        var renderData = this._renderData;
        var vData = renderData.vDatas[0];
        var iData = renderData.iDatas[0];
        var buffer = this.getBuffer();
        var offsetInfo = buffer.request(this.verticesCount, this.indicesCount);
        var vertexOffset = offsetInfo.byteOffset >> 2, vbuf = buffer._vData;
        vData.length + vertexOffset > vbuf.length ? vbuf.set(vData.subarray(0, vbuf.length - vertexOffset), vertexOffset) : vbuf.set(vData, vertexOffset);
        var ibuf = buffer._iData, indiceOffset = offsetInfo.indiceOffset, vertexId = offsetInfo.vertexOffset;
        for (var i = 0, l = iData.length; i < l; i++) ibuf[indiceOffset++] = vertexId + iData[i];
      };
      TextureAssembler.prototype.packToDynamicAtlas = function(comp, frame) {
        false;
        if (!frame._original && cc.dynamicAtlasManager && frame._texture.packable) {
          var packedFrame = cc.dynamicAtlasManager.insertSpriteFrame(frame);
          packedFrame && frame._setDynamicAtlasFrame(packedFrame);
        }
        var material = comp["_materials"][0];
        if (!material) return;
        if (material.getProperty("texture") !== frame._texture) {
          comp._vertsDirty = true;
          comp._updateMaterial();
        }
      };
      return TextureAssembler;
    }(cc.Assembler);
    exports.default = TextureAssembler;
    cc._RF.pop();
  }, {
    "../Utils/CommonUtils": "CommonUtils"
  } ],
  TexturePlus: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "58ad8KR/hRJi7EtoZ+PAyOU", "TexturePlus");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var TextureAssembler_1 = require("../Assemblers/TextureAssembler");
    var CommonUtils_1 = require("../Utils/CommonUtils");
    var renderEngine = cc.renderer.renderEngine;
    var TextureType;
    (function(TextureType) {
      TextureType[TextureType["Cut"] = 0] = "Cut";
      TextureType[TextureType["Stretch"] = 1] = "Stretch";
    })(TextureType || (TextureType = {}));
    var _vec2_temp = new cc.Vec2();
    var _mat4_temp = new cc.Mat4();
    var _a = cc._decorator, ccclass = _a.ccclass, menu = _a.menu, executeInEditMode = _a.executeInEditMode, mixins = _a.mixins, property = _a.property;
    var TexturePlus = function(_super) {
      __extends(TexturePlus, _super);
      function TexturePlus() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this._texture = null;
        _this._polygon = [];
        _this.srcBlendFactor = cc.macro.BlendFactor.SRC_ALPHA;
        _this.dstBlendFactor = cc.macro.BlendFactor.ONE_MINUS_SRC_ALPHA;
        _this.editing = false;
        _this._assembler = null;
        return _this;
      }
      Object.defineProperty(TexturePlus.prototype, "texture", {
        get: function() {
          return this._texture;
        },
        set: function(val) {
          this._texture = val;
          var l = -val.width / 2, b = -val.height / 2, t = val.height / 2, r = val.width / 2;
          this.polygon = [ cc.v2(l, b), cc.v2(r, b), cc.v2(r, t), cc.v2(l, t) ];
          this.node.width = val.width;
          this.node.height = val.height;
          this._updateMaterial();
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(TexturePlus.prototype, "polygon", {
        get: function() {
          return this._polygon;
        },
        set: function(points) {
          this._polygon = points;
          this._updateVerts();
        },
        enumerable: false,
        configurable: true
      });
      TexturePlus.prototype.onLoad = function() {
        this.node["_hitTest"] = this._hitTest.bind(this);
      };
      TexturePlus.prototype.start = function() {
        var _this = this;
        this.node.on(cc.Node.EventType.TOUCH_START, function() {
          console.log("click texture plus");
        }, this);
        this.node.on(cc.Node.EventType.TOUCH_MOVE, function(e) {
          _this.node.x += e.getDeltaX();
          _this.node.y += e.getDeltaY();
        }, this);
      };
      TexturePlus.prototype._updateVerts = function() {
        this.setVertsDirty();
      };
      TexturePlus.prototype._updateMaterial = function() {
        var texture = this._texture;
        var material = this.getMaterial(0);
        if (material) {
          void 0 !== material.getDefine("USE_TEXTURE") && material.define("USE_TEXTURE", true);
          material.setProperty("texture", texture);
        }
        this["__proto__"]._updateBlendFunc.call(this);
        this.setVertsDirty();
      };
      TexturePlus.prototype._validateRender = function() {};
      TexturePlus.prototype._resetAssembler = function() {
        var assembler = this._assembler = new TextureAssembler_1.default();
        assembler.init(this);
        this._updateColor();
        this.setVertsDirty();
      };
      TexturePlus.prototype._hitTest = function(cameraPt) {
        var node = this.node;
        var size = node.getContentSize(), w = size.width, h = size.height, testPt = _vec2_temp;
        node["_updateWorldMatrix"]();
        if (!cc.Mat4.invert(_mat4_temp, node["_worldMatrix"])) return false;
        cc.Vec2.transformMat4(testPt, cameraPt, _mat4_temp);
        return CommonUtils_1.CommonUtils.isInPolygon(testPt, this.polygon);
      };
      TexturePlus.Type = TextureType;
      __decorate([ property(cc.Texture2D) ], TexturePlus.prototype, "_texture", void 0);
      __decorate([ property(cc.Texture2D) ], TexturePlus.prototype, "texture", null);
      __decorate([ property({
        type: [ cc.Vec2 ],
        serializable: true
      }) ], TexturePlus.prototype, "_polygon", void 0);
      __decorate([ property({
        type: [ cc.Vec2 ],
        serializable: true
      }) ], TexturePlus.prototype, "polygon", null);
      __decorate([ property({
        type: cc.Enum(cc.macro.BlendFactor),
        override: true
      }) ], TexturePlus.prototype, "srcBlendFactor", void 0);
      __decorate([ property({
        type: cc.Enum(cc.macro.BlendFactor),
        override: true
      }) ], TexturePlus.prototype, "dstBlendFactor", void 0);
      __decorate([ property(cc.Boolean) ], TexturePlus.prototype, "editing", void 0);
      TexturePlus = __decorate([ ccclass, executeInEditMode, menu("i18n:MAIN_MENU.component.ui/TexturePlus"), mixins(cc.BlendFunc) ], TexturePlus);
      return TexturePlus;
    }(cc.RenderComponent);
    exports.default = TexturePlus;
    cc._RF.pop();
  }, {
    "../Assemblers/TextureAssembler": "TextureAssembler",
    "../Utils/CommonUtils": "CommonUtils"
  } ],
  TipsMgr: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "f0adbheCVRBErVSp07wosNT", "TipsMgr");
    "use strict";
    var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const SysDefine_1 = require("./config/SysDefine");
    const Struct_1 = require("./Struct");
    const UIManager_1 = require("./UIManager");
    class TipsMgr {
      open(form, params, formData) {
        return __awaiter(this, void 0, void 0, function*() {
          form = Struct_1.GetForm(form, SysDefine_1.FormType.Tips);
          return yield UIManager_1.default.getInstance().openForm(form, params, formData);
        });
      }
      close(form, params, formData) {
        return __awaiter(this, void 0, void 0, function*() {
          form = Struct_1.GetForm(form, SysDefine_1.FormType.Tips);
          return yield UIManager_1.default.getInstance().closeForm(form, params, formData);
        });
      }
    }
    exports.default = new TipsMgr();
    cc._RF.pop();
  }, {
    "./Struct": "Struct",
    "./UIManager": "UIManager",
    "./config/SysDefine": "SysDefine"
  } ],
  ToastMgr: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "68e22m/kRFCA4LrPLsSxzY9", "ToastMgr");
    "use strict";
    var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = this && this.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (1 & t[0]) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, "function" === typeof Symbol && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([ n, v ]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = 2 & op[0] ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 
          0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          (y = 0, t) && (op = [ 2 & op[0], t.value ]);
          switch (op[0]) {
           case 0:
           case 1:
            t = op;
            break;

           case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

           case 5:
            _.label++;
            y = op[1];
            op = [ 0 ];
            continue;

           case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;

           default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (6 === op[0] || 2 === op[0])) {
              _ = 0;
              continue;
            }
            if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (6 === op[0] && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop();
            _.trys.pop();
            continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [ 6, e ];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (5 & op[0]) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var Pool_1 = require("../Common/Utils/Pool");
    var SysDefine_1 = require("./config/SysDefine");
    var EventCenter_1 = require("./EventCenter");
    var ResMgr_1 = require("./ResMgr");
    var Struct_1 = require("./Struct");
    var UIForm_1 = require("./UIForm");
    var UIManager_1 = require("./UIManager");
    var ToastMgr = function() {
      function ToastMgr() {
        this._pools = cc.js.createMap();
        this._showingToast = cc.js.createMap();
      }
      ToastMgr.prototype.open = function(form, params, formData) {
        return __awaiter(this, void 0, void 0, function() {
          var pool, toastBase, arr;
          return __generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              form = Struct_1.GetForm(form, SysDefine_1.FormType.Toast);
              pool = this._pools[form.prefabUrl];
              console.log(pool, form.prefabUrl);
              if (!!pool) return [ 3, 2 ];
              return [ 4, this.genPool(form.prefabUrl) ];

             case 1:
              pool = _a.sent();
              _a.label = 2;

             case 2:
              toastBase = pool.alloc();
              return [ 4, UIManager_1.default.getInstance().enterToToast(toastBase, params) ];

             case 3:
              _a.sent();
              arr = this._showingToast[form.prefabUrl];
              arr || (arr = this._showingToast[form.prefabUrl] = new Array());
              arr.push(toastBase);
              return [ 2, toastBase ];
            }
          });
        });
      };
      ToastMgr.prototype.close = function(com, params) {
        return __awaiter(this, void 0, void 0, function() {
          var arr, i;
          return __generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              return [ 4, UIManager_1.default.getInstance().exitToToast(com, params) ];

             case 1:
              _a.sent();
              console.log(com.fid);
              if (!this._pools[com.fid]) return [ 2 ];
              this._pools[com.fid].free(com);
              arr = this._showingToast[com.fid];
              if (!arr) return [ 2 ];
              for (i = arr.length - 1; i >= 0; i--) {
                if (arr[i].uuid !== com.uuid) continue;
                arr.splice(i, 1);
                break;
              }
              return [ 2 ];
            }
          });
        });
      };
      ToastMgr.prototype.genPool = function(prefabUrl) {
        return __awaiter(this, void 0, void 0, function() {
          var prefab, pool;
          return __generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              return [ 4, ResMgr_1.default.inst.loadFormPrefab(prefabUrl) ];

             case 1:
              prefab = _a.sent();
              pool = this._pools[prefabUrl] = new Pool_1.Pool(function() {
                var node = cc.instantiate(prefab);
                UIManager_1.default.getInstance().addNode(node);
                var com = node.getComponent(UIForm_1.UIToast);
                com.fid = prefabUrl;
                return com;
              }, 3);
              return [ 2, pool ];
            }
          });
        });
      };
      ToastMgr.prototype.clearToasts = function(prefabUrl) {
        var pool = this._pools[prefabUrl];
        if (!pool) return;
        var arr = this._showingToast[prefabUrl];
        if (!arr) return;
        for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
          var toast = arr_1[_i];
          pool.free(toast);
        }
        pool.clear(function(toastBase) {
          toastBase.node.destroy();
          EventCenter_1.EventCenter.targetOff(toastBase);
        });
        ResMgr_1.default.inst.destoryFormPrefab(prefabUrl);
        this._pools[prefabUrl] = null;
        delete this._pools[prefabUrl];
        this._showingToast[prefabUrl] = null;
        delete this._showingToast[prefabUrl];
      };
      ToastMgr.prototype.checkHasShowingToast = function(prefabUrl) {
        return this._showingToast[prefabUrl].length > 0;
      };
      return ToastMgr;
    }();
    exports.default = new ToastMgr();
    cc._RF.pop();
  }, {
    "../Common/Utils/Pool": "Pool",
    "./EventCenter": "EventCenter",
    "./ResMgr": "ResMgr",
    "./Struct": "Struct",
    "./UIForm": "UIForm",
    "./UIManager": "UIManager",
    "./config/SysDefine": "SysDefine"
  } ],
  TouchPlus: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "1c88eM+YFpH45yVr93vRF2l", "TouchPlus");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
    var TouchPlus = function(_super) {
      __extends(TouchPlus, _super);
      function TouchPlus() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.offset = 15;
        _this.isTouch = false;
        _this.isClick = true;
        return _this;
      }
      TouchPlus.prototype.addEvent = function(click, slide) {
        this.clickEvent = click;
        this.slideEvent = slide;
      };
      TouchPlus.prototype.start = function() {
        this.node.on(cc.Node.EventType.TOUCH_START, this.touchStart, this);
        this.node.on(cc.Node.EventType.TOUCH_MOVE, this.touchMove, this);
        this.node.on(cc.Node.EventType.TOUCH_END, this.touchEnd, this);
        this.node.on(cc.Node.EventType.TOUCH_CANCEL, this.touchCancel, this);
      };
      TouchPlus.prototype.touchStart = function(e) {
        this.isTouch = true;
        this.startPosition = e.getLocation();
      };
      TouchPlus.prototype.touchMove = function(e) {
        if (!this.isTouch) return;
        var pos = e.getLocation();
        var len = pos.sub(this.startPosition).mag();
        if (len > this.offset) {
          this.isClick = false;
          this.slideEvent && this.slideEvent(e);
        }
      };
      TouchPlus.prototype.touchEnd = function(e) {
        if (!this.isTouch) return;
        this.isTouch = false;
        this.isClick && this.clickEvent && this.clickEvent(e);
        this.isClick = true;
      };
      TouchPlus.prototype.touchCancel = function(e) {
        if (!this.isTouch) return;
        this.isTouch = false;
        this.isClick = true;
      };
      TouchPlus.prototype.onDestroy = function() {
        this.node.off(cc.Node.EventType.TOUCH_START, this.touchStart, this);
        this.node.off(cc.Node.EventType.TOUCH_MOVE, this.touchMove, this);
        this.node.off(cc.Node.EventType.TOUCH_END, this.touchEnd, this);
        this.node.off(cc.Node.EventType.TOUCH_CANCEL, this.touchCancel, this);
      };
      TouchPlus = __decorate([ ccclass ], TouchPlus);
      return TouchPlus;
    }(cc.Component);
    exports.default = TouchPlus;
    cc._RF.pop();
  }, {} ],
  UIBackpackInfo_Auto: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "752abhSRGJDt4p0O0PLGsev", "UIBackpackInfo_Auto");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const {ccclass: ccclass, property: property} = cc._decorator;
    let UIBackpackInfo_Auto = class UIBackpackInfo_Auto extends cc.Component {
      constructor() {
        super(...arguments);
        this.icon = null;
        this.title = null;
        this.numberNode = null;
        this.number = null;
        this.infoLabel = null;
      }
    };
    __decorate([ property(cc.Node) ], UIBackpackInfo_Auto.prototype, "icon", void 0);
    __decorate([ property(cc.Node) ], UIBackpackInfo_Auto.prototype, "title", void 0);
    __decorate([ property(cc.Node) ], UIBackpackInfo_Auto.prototype, "numberNode", void 0);
    __decorate([ property(cc.Label) ], UIBackpackInfo_Auto.prototype, "number", void 0);
    __decorate([ property(cc.Node) ], UIBackpackInfo_Auto.prototype, "infoLabel", void 0);
    UIBackpackInfo_Auto = __decorate([ ccclass ], UIBackpackInfo_Auto);
    exports.default = UIBackpackInfo_Auto;
    cc._RF.pop();
  }, {} ],
  UIBackpackInfo: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "2ba25JECwlBO5dm/Nelvbgu", "UIBackpackInfo");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var UIBackpackInfo_1;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const CommonUtils_1 = require("../Common/Utils/CommonUtils");
    const GlobalData_1 = require("../Config/GlobalData");
    const Struct_1 = require("../UIFrame/Struct");
    const UIForm_1 = require("../UIFrame/UIForm");
    const SysDefine_1 = require("../UIFrame/config/SysDefine");
    const {ccclass: ccclass, property: property} = cc._decorator;
    let UIBackpackInfo = UIBackpackInfo_1 = class UIBackpackInfo extends UIForm_1.UIWindow {
      constructor() {
        super(...arguments);
        this.modalType = new Struct_1.ModalType(SysDefine_1.ModalOpacity.OpacityHigh, true);
        this._data = null;
      }
      start() {
        console.log("UIRecipeInfo start...");
      }
      onShow(data) {
        this._data = data;
      }
      onEnable() {
        this.initUi(this._data);
      }
      onDisable() {}
      initUi(data) {
        let tempResPath = data["resPath"] ? data["resPath"] : GlobalData_1.GlobalData.rawPath;
        CommonUtils_1.CommonUtils.setItemSpriteFrame(this.view.icon.getComponent(cc.Sprite), `${tempResPath}${data["ID"]}`);
        this.view.title.getComponent(cc.Label).string = true == data["name"].includes("%s") ? data["name"].replace("%s", "") : data["name"];
        this.view.infoLabel.getComponent(cc.Label).string = data["intro"];
        this.view.numberNode.active = "item_raw" != data["type"];
        this.view.number.string = data["count"] ? data["count"] : "0";
        this.scheduleOnce(() => {
          CommonUtils_1.CommonUtils.checkIconSize(this.view.icon, 130);
        }, .1);
      }
      clickClose() {
        UIBackpackInfo_1.close();
      }
    };
    UIBackpackInfo = UIBackpackInfo_1 = __decorate([ ccclass ], UIBackpackInfo);
    exports.default = UIBackpackInfo;
    cc._RF.pop();
  }, {
    "../Common/Utils/CommonUtils": "CommonUtils",
    "../Config/GlobalData": "GlobalData",
    "../UIFrame/Struct": "Struct",
    "../UIFrame/UIForm": "UIForm",
    "../UIFrame/config/SysDefine": "SysDefine"
  } ],
  UIBackpack_Auto: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "5a0cb8IIqNGcZ/fFt+Fmcey", "UIBackpack_Auto");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var List_1 = require("./../Common/Components/List");
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
    var UIBackpack_Auto = function(_super) {
      __extends(UIBackpack_Auto, _super);
      function UIBackpack_Auto() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.BackpackScroll = null;
        _this.BackpackContent = null;
        _this.BackpackModule = null;
        _this.BackpackType = null;
        return _this;
      }
      __decorate([ property(List_1.default) ], UIBackpack_Auto.prototype, "BackpackScroll", void 0);
      __decorate([ property(cc.Node) ], UIBackpack_Auto.prototype, "BackpackContent", void 0);
      __decorate([ property(cc.Node) ], UIBackpack_Auto.prototype, "BackpackModule", void 0);
      __decorate([ property(cc.Node) ], UIBackpack_Auto.prototype, "BackpackType", void 0);
      UIBackpack_Auto = __decorate([ ccclass ], UIBackpack_Auto);
      return UIBackpack_Auto;
    }(cc.Component);
    exports.default = UIBackpack_Auto;
    cc._RF.pop();
  }, {
    "./../Common/Components/List": "List"
  } ],
  UIBackpack: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "f09b22/yVhCDYd+S3uq0x10", "UIBackpack");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var UIBackpack_1;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const RawMaterial_1 = require("../Config/RawMaterial");
    const TableKey_1 = require("../Config/TableKey");
    const BackpackContent_1 = require("../Game/Item/BackpackContent");
    const BackpackTypeItem_1 = require("../Game/Item/BackpackTypeItem");
    const RecipeModuleItem_1 = require("../Game/Item/RecipeModuleItem");
    const Game_1 = require("../Logic/Game");
    const Struct_1 = require("../UIFrame/Struct");
    const UIForm_1 = require("../UIFrame/UIForm");
    const SysDefine_1 = require("../UIFrame/config/SysDefine");
    const {ccclass: ccclass, property: property} = cc._decorator;
    let UIBackpack = UIBackpack_1 = class UIBackpack extends UIForm_1.UIWindow {
      constructor() {
        super(...arguments);
        this.modalType = new Struct_1.ModalType(SysDefine_1.ModalOpacity.OpacityHigh, true);
        this.moduleItem = null;
        this.typeItem = null;
        this.curModuleNumber = 0;
        this.curTypeNumber = 0;
        this.nodeHeight = [ 110, 130 ];
        this.titlePos = [ -50, -60 ];
        this.initBackpackContentHeight = 0;
      }
      start() {
        console.log("UIBackpack start...");
      }
      onEnable() {
        this.initData();
        this.curModuleNumber = 0;
        this.curTypeNumber = 0;
        this.initUi();
      }
      onAfterShow(params) {
        let self = this;
        this.view.BackpackScroll.numItems = RawMaterial_1.BackpackList[this.curModuleNumber].length;
        this.initBackpackContentHeight = this.view.BackpackContent.children[0].height;
        this.view.BackpackScroll.scrollTo(0, 0, .1);
        this.view.BackpackContent.getComponent(cc.Layout).enabled = true;
        this.scheduleOnce(() => {
          for (let i = 0; i < self.view.BackpackContent.children.length; i++) self.view.BackpackScroll._onItemAdaptive(self.view.BackpackContent.children[i]);
        }, .1);
      }
      onListGridRender(item, idx) {
        if (!idx && 0 !== idx) return;
        item.getComponent(BackpackContent_1.default).initUi(RawMaterial_1.BackpackType[this.curModuleNumber][idx], this.curModuleNumber, idx, this);
      }
      initData() {
        let tempData = Game_1.default.dbMgr.query(TableKey_1.TableKey.MATE);
        RawMaterial_1.BackpackList[0][0] = tempData;
        tempData = Game_1.default.dbMgr.query(TableKey_1.TableKey.WARDROBE);
        RawMaterial_1.BackpackList[1][0] = tempData;
        tempData = Game_1.default.dbMgr.query(TableKey_1.TableKey.TABLE);
        RawMaterial_1.BackpackList[2][0] = tempData;
        tempData = Game_1.default.dbMgr.query(TableKey_1.TableKey.ORNAMENTS);
        RawMaterial_1.BackpackList[2][1] = tempData;
      }
      initUi() {
        this.initModule();
        this.initTypeItem();
      }
      clickClose() {
        UIBackpack_1.close();
      }
      initModule() {
        this.initAllModule();
        for (let i = 0; i < RawMaterial_1.BackPackModule.length; i++) if (this.view.BackpackModule.children[i]) this.view.BackpackModule.children[i].getComponent(RecipeModuleItem_1.default).initUi(i, this); else {
          let recipeModuleItem = cc.instantiate(this.moduleItem);
          recipeModuleItem.parent = this.view.BackpackModule;
          recipeModuleItem.getComponent(RecipeModuleItem_1.default).initUi(i, this);
          recipeModuleItem.name = "" + i;
        }
      }
      initAllModule() {
        this.view.BackpackModule.children.forEach(element => {
          element.height = this.nodeHeight[0];
          element.getComponent(RecipeModuleItem_1.default).title.y = this.titlePos[0];
        });
      }
      changeRecipeItem() {
        this.view.BackpackScroll.numItems = RawMaterial_1.BackpackList[this.curModuleNumber].length;
        for (let i = 0; i < RawMaterial_1.BackpackList[this.curModuleNumber].length; i++) this.view.BackpackContent.children[i].height = this.initBackpackContentHeight;
        this.view.BackpackScroll.updateAll();
      }
      initTypeItem() {
        this.view.BackpackType.children.forEach(element => {
          element.active = false;
        });
        let tempItem;
        for (let i = 0; i < RawMaterial_1.BackpackType[this.curModuleNumber].length; i++) {
          if (this.view.BackpackType.children[i]) {
            tempItem = this.view.BackpackType.children[i];
            tempItem.active = true;
          } else {
            let typeItem = cc.instantiate(this.typeItem);
            typeItem.parent = this.view.BackpackType;
            tempItem = typeItem;
          }
          0 == i && (tempItem.getComponent(BackpackTypeItem_1.default).isSelected = true);
          tempItem.getComponent(BackpackTypeItem_1.default).initUi(RawMaterial_1.BackpackType[this.curModuleNumber][i], i, this);
        }
      }
      clickTypeNode() {
        this.view.BackpackType.children.forEach(element => {
          element.getComponent(BackpackTypeItem_1.default).isSelected = false;
          element.getComponent(BackpackTypeItem_1.default).isSelectedFunction();
        });
        this.view.BackpackScroll.scrollTo(this.curTypeNumber, .3, .1);
      }
    };
    __decorate([ property(cc.Prefab) ], UIBackpack.prototype, "moduleItem", void 0);
    __decorate([ property(cc.Prefab) ], UIBackpack.prototype, "typeItem", void 0);
    UIBackpack = UIBackpack_1 = __decorate([ ccclass ], UIBackpack);
    exports.default = UIBackpack;
    cc._RF.pop();
  }, {
    "../Config/RawMaterial": "RawMaterial",
    "../Config/TableKey": "TableKey",
    "../Game/Item/BackpackContent": "BackpackContent",
    "../Game/Item/BackpackTypeItem": "BackpackTypeItem",
    "../Game/Item/RecipeModuleItem": "RecipeModuleItem",
    "../Logic/Game": "Game",
    "../UIFrame/Struct": "Struct",
    "../UIFrame/UIForm": "UIForm",
    "../UIFrame/config/SysDefine": "SysDefine"
  } ],
  UIBase: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "e39bcXBPZZJwbPmOzg0+yw0", "UIBase");
    "use strict";
    var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const AdapterMgr_1 = require("./AdapterMgr");
    const FormMgr_1 = require("./FormMgr");
    const ResMgr_1 = require("./ResMgr");
    const Struct_1 = require("./Struct");
    class UIBase extends cc.Component {
      constructor() {
        super();
        this.fid = "";
        this.formData = null;
        this.formType = null;
        this.closeType = null;
        this._inited = false;
        this.view = null;
        this.model = null;
        this._blocker = null;
      }
      static open(param, formData) {
        let uiconfig = this["UIConfig"];
        if (!uiconfig) {
          cc.warn("sorry UIConfig is null, please check AutoConfig");
          return;
        }
        FormMgr_1.default.open(uiconfig, param, formData);
      }
      static close() {
        FormMgr_1.default.close(this["UIConfig"]);
      }
      _preInit(params) {
        return __awaiter(this, void 0, void 0, function*() {
          if (this._inited) return;
          this._inited = true;
          this.view = this.getComponent(`${this.node.name}_Auto`);
          let errorMsg = yield this.load(params);
          if (errorMsg) {
            cc.error(errorMsg);
            this.closeSelf();
            return;
          }
          this.onInit(params);
        });
      }
      load(params) {
        return __awaiter(this, void 0, void 0, function*() {
          return null;
        });
      }
      onInit(params) {}
      onShow(params) {}
      onAfterShow(params) {}
      onHide(params) {}
      onAfterHide(params) {}
      closeSelf(params) {
        return __awaiter(this, void 0, void 0, function*() {
          return yield FormMgr_1.default.close(Struct_1.GetForm(this.fid, this.formType), params);
        });
      }
      showEffect() {
        return __awaiter(this, void 0, void 0, function*() {});
      }
      hideEffect() {
        return __awaiter(this, void 0, void 0, function*() {});
      }
      setBlockInput(block) {
        if (!this._blocker) {
          let node = new cc.Node("block_input_events");
          this._blocker = node.addComponent(cc.BlockInputEvents);
          this._blocker.node.setContentSize(AdapterMgr_1.default.inst.visibleSize);
          this.node.addChild(this._blocker.node, cc.macro.MAX_ZINDEX);
        }
        this._blocker.node.active = block;
      }
      loadRes(url, type) {
        return __awaiter(this, void 0, void 0, function*() {
          return yield ResMgr_1.default.inst.loadDynamicRes(url, type, this.fid);
        });
      }
    }
    exports.default = UIBase;
    cc.UIBase = UIBase;
    cc._RF.pop();
  }, {
    "./AdapterMgr": "AdapterMgr",
    "./FormMgr": "FormMgr",
    "./ResMgr": "ResMgr",
    "./Struct": "Struct"
  } ],
  UIBuild_Auto: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "9e6ee/y3mxHxrFevj6R8E7S", "UIBuild_Auto");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const {ccclass: ccclass, property: property} = cc._decorator;
    let UIBuild_Auto = class UIBuild_Auto extends cc.Component {
      constructor() {
        super(...arguments);
        this.Type = null;
        this.BackpackModule = null;
      }
    };
    __decorate([ property(cc.Node) ], UIBuild_Auto.prototype, "Type", void 0);
    __decorate([ property(cc.Node) ], UIBuild_Auto.prototype, "BackpackModule", void 0);
    UIBuild_Auto = __decorate([ ccclass ], UIBuild_Auto);
    exports.default = UIBuild_Auto;
    cc._RF.pop();
  }, {} ],
  UIBuild: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "ad8a0g+YftNf52nP4S4J0Z6", "UIBuild");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.BuildType = void 0;
    const BroadcastCenter_1 = require("../Common/BroadCasts/BroadcastCenter");
    const List_1 = require("../Common/Components/List");
    const GPDrag_1 = require("../Common/GPDrag");
    const RawMaterial_1 = require("../Config/RawMaterial");
    const MessageType_1 = require("../Enum/MessageType");
    const BuildGrid_1 = require("../Game/Item/BuildGrid");
    const BuildItem_1 = require("../Game/Item/BuildItem");
    const BuildTypeItem_1 = require("../Game/Item/BuildTypeItem");
    const Game_1 = require("../Logic/Game");
    const AdapterMgr_1 = require("../UIFrame/AdapterMgr");
    const CocosHelper_1 = require("../UIFrame/CocosHelper");
    const Struct_1 = require("../UIFrame/Struct");
    const UIForm_1 = require("../UIFrame/UIForm");
    const SysDefine_1 = require("../UIFrame/config/SysDefine");
    const {ccclass: ccclass, property: property} = cc._decorator;
    var BuildType;
    (function(BuildType) {
      BuildType[BuildType["table"] = 0] = "table";
      BuildType[BuildType["ornaments"] = 1] = "ornaments";
      BuildType[BuildType["wallDecoration"] = 2] = "wallDecoration";
      BuildType[BuildType["special"] = 3] = "special";
    })(BuildType = exports.BuildType || (exports.BuildType = {}));
    let UIBuild = class UIBuild extends UIForm_1.UIWindow {
      constructor() {
        super(...arguments);
        this.typePrefab = null;
        this.itemPrefab = null;
        this.Scroll = null;
        this.modalType = new Struct_1.ModalType(SysDefine_1.ModalOpacity.OpacityZero, true);
        this.view = null;
        this.dragItem = null;
        this.itemNode = null;
        this.dragIndex = -1;
        this.stopDrag = false;
        this.curType = "";
        this.selNode = null;
        this.listData = [];
        this.home = null;
      }
      start() {
        this.initDragNode();
        this.initUi();
      }
      onEnable() {}
      showEffect() {
        return __awaiter(this, void 0, void 0, function*() {
          this.node.scale = 0;
          this.node.position = cc.v3(0, -800);
          yield CocosHelper_1.default.runTweenSync(this.node, cc.tween().by(.3, {
            position: cc.v3(0, 76),
            scale: 1
          }, cc.easeBackOut()));
        });
      }
      hideEffect() {
        return __awaiter(this, void 0, void 0, function*() {
          yield CocosHelper_1.default.runTweenSync(this.node, cc.tween().to(.3, {
            position: cc.v3(0, -800),
            scale: 0
          }, cc.easeBackOut()));
        });
      }
      onShow(home) {
        this.home = home;
        this.home.top.changeShopIcon(false);
        BroadcastCenter_1.BroadcastCenter.buildingState.dispatch({
          id: 0,
          state: MessageType_1.MessageType.BuildState
        });
        this.initData();
      }
      onAfterShow(params) {
        this.itemNode.active = false;
        AdapterMgr_1.default.inst.adapteByType(AdapterMgr_1.AdapterType.FullWidth, this.node);
      }
      onHide(params) {
        this.home.top.changeShopIcon(true);
      }
      onAfterHide(params) {
        BroadcastCenter_1.BroadcastCenter.buildingState.dispatch({
          id: 0,
          state: MessageType_1.MessageType.GameState
        });
      }
      initData() {}
      initUi() {
        for (let i = 0; i < RawMaterial_1.BuildData.length; i++) {
          let node = cc.instantiate(this.typePrefab);
          const BdType = node.getComponent(BuildTypeItem_1.default);
          BdType.initData(RawMaterial_1.BuildData[i], 0 == i);
          node.parent = this.view.Type;
          RawMaterial_1.BuildData[i].tableKey && (RawMaterial_1.BuildData[i].data = Game_1.default.dbMgr.query(RawMaterial_1.BuildData[i].tableKey));
          if (0 === i) {
            console.log(RawMaterial_1.BuildData[i].data);
            this.curType = RawMaterial_1.BuildData[i].type;
            this.scheduleOnce(() => {
              this.renderListData(RawMaterial_1.BuildData[i].data);
            }, 1);
          }
        }
      }
      initDragNode() {
        this.itemNode = cc.instantiate(this.itemPrefab);
        this.buildComp.enabled = false;
        this.buildComp.icon.node.opacity = 127;
        this.dragComp.succeedCheck = this.succkCheck.bind(this);
        this.dragComp.succeedCallback = this.succeedCallback.bind(this);
        this.itemNode.parent = this.node;
        this.buildComp.initDrag();
      }
      get buildComp() {
        return this.itemNode.getComponent(BuildItem_1.default);
      }
      get dragComp() {
        return this.itemNode.getComponent(GPDrag_1.GPDrag);
      }
      renderListData(data) {
        this.listData = data;
        this.List.numItems = data.length;
      }
      get List() {
        return this.Scroll.getComponent(List_1.default);
      }
      onListItemRender(item, idx) {
        item.getComponent(GPDrag_1.GPDrag).enabled = false;
        const BdItem = item.getComponent(BuildItem_1.default);
        BdItem.initUi(this.listData[idx], this.curType, this);
      }
      dragNode(e, item) {
        const val = item.updateVal();
        if (val <= 0) {
          e.stopPropagationImmediate();
          this.stopDrag = true;
          return;
        }
        this.dragItem = item;
        this.List.node.getComponent(cc.ScrollView).enabled = false;
        this.itemNode.setContentSize(cc.size(item.node.width, item.node.height));
        this.itemNode.children[0].getComponent(cc.Sprite).spriteFrame = item.icon.spriteFrame;
        const pos = this.node.convertToNodeSpaceAR(e.getLocation());
        this.itemNode.position = cc.v3(pos.x, pos.y);
        this.itemNode.active = true;
        e.target = this.itemNode;
        e.currentTarget = this.dragNode;
        this.dragComp.OnDragStart(e);
      }
      dragMove(e) {
        if (!this.itemNode || this.stopDrag) return;
        e.target = this.itemNode;
        e.currentTarget = this.itemNode;
        this.dragComp.OnDragMove(e);
        let node = this.home.getSelBuild(this.itemNode.convertToWorldSpace(cc.v2(0, 0)), 100);
        if (!node) {
          this.selNode && this.selComp.reset();
          this.selNode = null;
          return;
        }
        if (!this.selNode || node.uuid !== this.selNode.uuid) {
          this.selNode && this.selComp.reset();
          this.selNode = node;
          this.selComp.buildType !== BuildGrid_1.BuildGridTyoe.None ? this.selComp.warnAni() : this.selComp.rightAni(this.buildComp.icon);
        }
      }
      get selComp() {
        return this.selNode.getComponent(BuildGrid_1.default);
      }
      dragEnd(e) {
        if (!this.itemNode) {
          this.stopDrag = false;
          return;
        }
        e.target = this.itemNode;
        e.currentTarget = this.itemNode;
        this.dragComp.OnDragEnd(e);
      }
      succkCheck() {
        let isSucc = false;
        this.selNode && (isSucc = true);
        isSucc || this.resetDrag();
        return isSucc;
      }
      resetDrag() {
        this.selNode && this.selComp.reset();
        this.scheduleOnce(this.initDragData, this.dragComp.backTweenTime);
      }
      succeedCallback() {
        this.selComp.gridData = {
          ID: this.dragItem.itemData.ID,
          type: this.dragItem.type
        };
        this.selComp.reset(false);
        this.dragItem.updateVal();
        this.initDragData();
      }
      initDragData() {
        this.selNode = null;
        this.itemNode.active = false;
        this.dragIndex = -1;
        this.List.node.getComponent(cc.ScrollView).enabled = true;
      }
    };
    __decorate([ property(cc.Prefab) ], UIBuild.prototype, "typePrefab", void 0);
    __decorate([ property(cc.Prefab) ], UIBuild.prototype, "itemPrefab", void 0);
    __decorate([ property(List_1.default) ], UIBuild.prototype, "Scroll", void 0);
    UIBuild = __decorate([ ccclass ], UIBuild);
    exports.default = UIBuild;
    cc._RF.pop();
  }, {
    "../Common/BroadCasts/BroadcastCenter": "BroadcastCenter",
    "../Common/Components/List": "List",
    "../Common/GPDrag": "GPDrag",
    "../Config/RawMaterial": "RawMaterial",
    "../Enum/MessageType": "MessageType",
    "../Game/Item/BuildGrid": "BuildGrid",
    "../Game/Item/BuildItem": "BuildItem",
    "../Game/Item/BuildTypeItem": "BuildTypeItem",
    "../Logic/Game": "Game",
    "../UIFrame/AdapterMgr": "AdapterMgr",
    "../UIFrame/CocosHelper": "CocosHelper",
    "../UIFrame/Struct": "Struct",
    "../UIFrame/UIForm": "UIForm",
    "../UIFrame/config/SysDefine": "SysDefine"
  } ],
  UIConfig: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "146c1Cgz6VBgbdJJq7LiwWK", "UIConfig");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    class UIConfig {}
    exports.default = UIConfig;
    UIConfig.UIBackpack = {
      prefabUrl: "Prefab/Screen/UIBackpack",
      type: "UIWindow"
    };
    UIConfig.UIBackpackInfo = {
      prefabUrl: "Prefab/Screen/UIBackpackInfo",
      type: "UIWindow"
    };
    UIConfig.UIHome = {
      prefabUrl: "Prefab/Screen/UIHome",
      type: "UIScreen"
    };
    UIConfig.UIRecipe = {
      prefabUrl: "Prefab/Screen/UIRecipe",
      type: "UIWindow"
    };
    UIConfig.UIRecipeInfo = {
      prefabUrl: "Prefab/Screen/UIRecipeInfo",
      type: "UIWindow"
    };
    UIConfig.UITop = {
      prefabUrl: "Prefab/Screen/UITop",
      type: "UIFixed"
    };
    UIConfig.UIVariety = {
      prefabUrl: "Prefab/Screen/UIVariety",
      type: "UIDrawer"
    };
    UIConfig.UIVarietyInfo = {
      prefabUrl: "Prefab/Screen/UIVarietyInfo",
      type: "UIWindow"
    };
    UIConfig.UIWorkDesk = {
      prefabUrl: "Prefab/Screen/UIWorkDesk",
      type: "UIDrawer"
    };
    UIConfig.UILoading = {
      prefabUrl: "Prefab/Tips/UILoading",
      type: "UITips"
    };
    UIConfig.UIToast1 = {
      prefabUrl: "Prefab/Toast/UIToast1",
      type: "UIToast"
    };
    UIConfig.UIBuild = {
      prefabUrl: "Prefab/Screen/UIBuild",
      type: "UIWindow"
    };
    cc.game.on(cc.game.EVENT_GAME_INITED, () => {
      false;
      for (const key in UIConfig) {
        let constourt = cc.js.getClassByName(key);
        if (!constourt) {
          let urls = UIConfig[key].prefabUrl.split("/");
          if (!urls || urls.length <= 0) continue;
          let name = urls[urls.length - 1];
          constourt = cc.js.getClassByName(name);
        }
        constourt["UIConfig"] = UIConfig[key];
      }
    });
    cc._RF.pop();
  }, {} ],
  UIForm: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "c37basMGP5Pc7Er41uB3gdC", "UIForm");
    "use strict";
    var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.UIToast = exports.UITips = exports.UIFixed = exports.UIDrawer = exports.UIWindow = exports.UIScreen = void 0;
    const CocosHelper_1 = require("./CocosHelper");
    const SysDefine_1 = require("./config/SysDefine");
    const FormMgr_1 = require("./FormMgr");
    const Struct_1 = require("./Struct");
    const UIBase_1 = require("./UIBase");
    class UIScreen extends UIBase_1.default {
      constructor() {
        super(...arguments);
        this.formType = SysDefine_1.FormType.Screen;
        this.closeType = Struct_1.ECloseType.CloseAndDestory;
      }
    }
    exports.UIScreen = UIScreen;
    class UIWindow extends UIBase_1.default {
      constructor() {
        super(...arguments);
        this.formType = SysDefine_1.FormType.Window;
        this.modalType = new Struct_1.ModalType(SysDefine_1.ModalOpacity.OpacityFull);
        this.closeType = Struct_1.ECloseType.LRU;
      }
      showEffect() {
        return __awaiter(this, void 0, void 0, function*() {
          this.node.scale = 0;
          yield CocosHelper_1.default.runTweenSync(this.node, cc.tween().to(.3, {
            scale: 1
          }, cc.easeBackOut()));
        });
      }
    }
    exports.UIWindow = UIWindow;
    class UIDrawer extends UIBase_1.default {
      constructor() {
        super(...arguments);
        this.formType = SysDefine_1.FormType.Drawer;
        this.modalType = new Struct_1.ModalType(SysDefine_1.ModalOpacity.OpacityFull);
        this.closeType = Struct_1.ECloseType.CloseAndHide;
      }
      showEffect() {
        return __awaiter(this, void 0, void 0, function*() {
          this.node.scale = 0;
          yield CocosHelper_1.default.runTweenSync(this.node, cc.tween().to(.3, {
            scale: 1
          }, cc.easeBackOut()));
        });
      }
    }
    exports.UIDrawer = UIDrawer;
    class UIFixed extends UIBase_1.default {
      constructor() {
        super(...arguments);
        this.formType = SysDefine_1.FormType.Fixed;
        this.closeType = Struct_1.ECloseType.LRU;
      }
    }
    exports.UIFixed = UIFixed;
    class UITips extends UIBase_1.default {
      constructor() {
        super(...arguments);
        this.formType = SysDefine_1.FormType.Tips;
        this.closeType = Struct_1.ECloseType.CloseAndHide;
      }
    }
    exports.UITips = UITips;
    class UIToast extends UIBase_1.default {
      constructor() {
        super(...arguments);
        this.formType = SysDefine_1.FormType.Toast;
      }
      use() {}
      free() {}
      closeSelf() {
        return __awaiter(this, void 0, void 0, function*() {
          return yield FormMgr_1.default.close({
            prefabUrl: this.fid,
            type: this.formType
          });
        });
      }
    }
    exports.UIToast = UIToast;
    cc.UIScreen = UIScreen;
    cc.UIWindow = UIWindow;
    cc.UIFixed = UIFixed;
    cc.UITips = UITips;
    cc.UIToast = UIToast;
    cc._RF.pop();
  }, {
    "./CocosHelper": "CocosHelper",
    "./FormMgr": "FormMgr",
    "./Struct": "Struct",
    "./UIBase": "UIBase",
    "./config/SysDefine": "SysDefine"
  } ],
  UIHome_Auto: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "d0e1bIfKq5LxI9rGB9rijU4", "UIHome_Auto");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const {ccclass: ccclass, property: property} = cc._decorator;
    let UIHome_Auto = class UIHome_Auto extends cc.Component {
      constructor() {
        super(...arguments);
        this.Home = null;
        this.Player = null;
        this.Joystick = null;
        this.Backpack = null;
        this.Recipe = null;
        this.Map = null;
        this.Build = null;
        this.Obs = null;
        this.Start = null;
        this.End = null;
      }
    };
    __decorate([ property(cc.Node) ], UIHome_Auto.prototype, "Home", void 0);
    __decorate([ property(cc.Node) ], UIHome_Auto.prototype, "Player", void 0);
    __decorate([ property(cc.Node) ], UIHome_Auto.prototype, "Joystick", void 0);
    __decorate([ property(cc.Node) ], UIHome_Auto.prototype, "Backpack", void 0);
    __decorate([ property(cc.Node) ], UIHome_Auto.prototype, "Recipe", void 0);
    __decorate([ property(cc.Node) ], UIHome_Auto.prototype, "Map", void 0);
    __decorate([ property(cc.Node) ], UIHome_Auto.prototype, "Build", void 0);
    __decorate([ property(cc.Node) ], UIHome_Auto.prototype, "Obs", void 0);
    __decorate([ property(cc.Node) ], UIHome_Auto.prototype, "Start", void 0);
    __decorate([ property(cc.Node) ], UIHome_Auto.prototype, "End", void 0);
    UIHome_Auto = __decorate([ ccclass ], UIHome_Auto);
    exports.default = UIHome_Auto;
    cc._RF.pop();
  }, {} ],
  UIHome: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "b0a0dOekNZK/7MwbDKjiuCe", "UIHome");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const lodash_1 = require("lodash");
    const BroadcastCenter_1 = require("../Common/BroadCasts/BroadcastCenter");
    const utils_1 = require("../Common/Utils/utils");
    const GlobalData_1 = require("../Config/GlobalData");
    const TableKey_1 = require("../Config/TableKey");
    const MessageType_1 = require("../Enum/MessageType");
    const AutoFindPath_1 = require("../Extra/AutoFindPath");
    const Joystick_1 = require("../Extra/Joystick");
    const RoleMgr_1 = require("../Game/Manager/RoleMgr");
    const TableMgr_1 = require("../Game/Manager/TableMgr");
    const BaseRole_1 = require("../Game/base/BaseRole");
    const BaseTable_1 = require("../Game/base/BaseTable");
    const Game_1 = require("../Logic/Game");
    const UIForm_1 = require("../UIFrame/UIForm");
    const SysDefine_1 = require("../UIFrame/config/SysDefine");
    const UIBuild_1 = require("./UIBuild");
    const UITop_1 = require("./UITop");
    const UIWorkDesk_1 = require("./UIWorkDesk");
    const {ccclass: ccclass, property: property} = cc._decorator;
    let UIHome = class UIHome extends UIForm_1.UIScreen {
      constructor() {
        super(...arguments);
        this.rolePool = null;
        this.tablePool = null;
        this._storeData = null;
        this.model = 5;
      }
      load() {
        return __awaiter(this, void 0, void 0, function*() {
          return null;
        });
      }
      refreshView() {
        console.log(this.model);
      }
      onLoad() {
        this.onGameInit();
      }
      start() {
        return __awaiter(this, void 0, void 0, function*() {
          this.homeInit();
          this.initMap();
          this.autoCreatRole();
          this.register();
        });
      }
      register() {
        BroadcastCenter_1.BroadcastCenter.buildingState.on(data => {
          this.node && this.node.active && (data.state === MessageType_1.MessageType.BuildState ? this.view.Build.active = true : data.state === MessageType_1.MessageType.GameState && (this.view.Build.active = false));
        }, this);
      }
      getSelBuild(pos, maxLen) {
        if (!this.view.Build || !this.view.Build.active) return;
        for (let node of this.view.Build.children) {
          const worldPos = node.convertToWorldSpaceAR(cc.v2(0, 0));
          const len = cc.Vec2.distance(worldPos, pos);
          if (len < maxLen) return node;
        }
        return;
      }
      onShow(params) {
        UITop_1.default.open({
          home: this,
          callBack: this.getTop.bind(this)
        });
      }
      getTop(top) {
        this.top = top;
      }
      onGameInit() {
        this.rolePool = new cc.NodePool();
        this.tablePool = new cc.NodePool();
        this.initRolePool();
        this.initTablePool();
      }
      homeInit() {}
      clickDesk() {
        this.top.toggleHome(true);
        UIWorkDesk_1.default.open(this.top);
      }
      initMap() {
        this.view.Map.setContentSize(cc.winSize);
        this.view.Obs.setContentSize(cc.winSize);
        let mapData = AutoFindPath_1.AutoFindPath.formatToMapData(this.view.Map, 15);
        new AutoFindPath_1.AutoFindPath(mapData);
      }
      leave(role) {
        let isUpdate = false;
        if (!role) {
          role = RoleMgr_1.default.ins.firstRole;
          isUpdate = true;
        }
        role.state = MessageType_1.RoleType.LEAVE;
        let isSite = utils_1.getOddsByNum(1);
        let table = TableMgr_1.default.ins.queryNullTable();
        if (isSite && table && !role.isSite) {
          role.node.parent = table.node.parent;
          table.node.zIndex = SysDefine_1.LayerLevel.SitTable;
          role.toPos(utils_1.getPosByDesign(cc.v2(table.node.x + 10, table.node.y + 70)));
          role.state = MessageType_1.RoleType.SIT;
        } else role.toPos(utils_1.getPosByDesign(cc.v2(this.view.Start.position)));
        isUpdate && RoleMgr_1.default.ins.updateSpareRoles();
      }
      autoCreatRole() {
        this.schedule(this.createRole, GlobalData_1.GlobalData.gameData.roleCreateTime);
      }
      useFixedType() {
        Joystick_1.instance.emit("set_joystick_type", Joystick_1.JoystickType.FIXED);
      }
      useFollowType() {
        Joystick_1.instance.emit("set_joystick_type", Joystick_1.JoystickType.FOLLOW);
      }
      createRole() {
        let roleData = RoleMgr_1.default.ins.getNewRole();
        if (RoleMgr_1.default.ins.waitSize >= GlobalData_1.GlobalData.gameData.waitMaxNumber) return;
        if (!roleData) return;
        let node = this.rolePool.get();
        if (!node) return;
        node.setPosition(utils_1.getPosByDesign(cc.v2(this.view.Start.position)));
        this.node.addChild(node);
        let role = node.getComponent(BaseRole_1.default);
        role.roleData = roleData;
        role.init(this, () => {
          RoleMgr_1.default.ins.welcome(role);
        });
      }
      initRolePool() {
        return __awaiter(this, void 0, void 0, function*() {
          for (let index = 0; index < 24; index++) {
            let prefab = yield this.loadRes(BaseRole_1.default.prefabPath, cc.Prefab);
            let node = cc.instantiate(prefab);
            this.rolePool.put(node);
          }
          const end = this.view.End.position;
          RoleMgr_1.default.ins.init(this, cc.v2(end));
          return null;
        });
      }
      initTablePool() {
        return __awaiter(this, void 0, void 0, function*() {
          for (let index = 0; index < 24; index++) {
            let prefab = yield this.loadRes(BaseTable_1.default.prefabPath, cc.Prefab);
            let node = cc.instantiate(prefab);
            this.tablePool.put(node);
          }
          TableMgr_1.default.ins.init(this);
          TableMgr_1.default.ins.addTable(this.storeData.decorates);
          return null;
        });
      }
      updateMap(...nodes) {
        AutoFindPath_1.AutoFindPath.ins.updateMap(...nodes);
      }
      updateNodeZindex(node) {
        AutoFindPath_1.AutoFindPath.ins.setNodeZindex(node);
      }
      updateObsZindex(node) {
        AutoFindPath_1.AutoFindPath.ins.setNodeZindex(node);
        this.updateMap(node);
      }
      get storeData() {
        this._storeData || (this._storeData = Game_1.default.dbMgr.query(TableKey_1.TableKey.SHOP, {
          uid: GlobalData_1.GlobalData.userId
        }));
        return this._storeData;
      }
      set storeData(value) {
        if (!lodash_1.isEqual(this._storeData, value)) {
          lodash_1.merge(this._storeData, value);
          Game_1.default.dbMgr.update(TableKey_1.TableKey.SHOP, this._storeData, {
            uid: GlobalData_1.GlobalData.userId
          });
        }
      }
      addDecorate(data) {
        switch (data.type) {
         case UIBuild_1.BuildType.table:
          TableMgr_1.default.ins.addTable([ data ], true);
        }
      }
    };
    UIHome = __decorate([ ccclass ], UIHome);
    exports.default = UIHome;
    cc._RF.pop();
  }, {
    "../Common/BroadCasts/BroadcastCenter": "BroadcastCenter",
    "../Common/Utils/utils": "utils",
    "../Config/GlobalData": "GlobalData",
    "../Config/TableKey": "TableKey",
    "../Enum/MessageType": "MessageType",
    "../Extra/AutoFindPath": "AutoFindPath",
    "../Extra/Joystick": "Joystick",
    "../Game/Manager/RoleMgr": "RoleMgr",
    "../Game/Manager/TableMgr": "TableMgr",
    "../Game/base/BaseRole": "BaseRole",
    "../Game/base/BaseTable": "BaseTable",
    "../Logic/Game": "Game",
    "../UIFrame/UIForm": "UIForm",
    "../UIFrame/config/SysDefine": "SysDefine",
    "./UIBuild": "UIBuild",
    "./UITop": "UITop",
    "./UIWorkDesk": "UIWorkDesk",
    lodash: 1
  } ],
  UILoading_Auto: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "4d6bb9pFodPV7XeR1g04cy3", "UILoading_Auto");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
    var UILoading_Auto = function(_super) {
      __extends(UILoading_Auto, _super);
      function UILoading_Auto() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.Bar = null;
        _this.Tip = null;
        _this.Ani = null;
        return _this;
      }
      __decorate([ property(cc.ProgressBar) ], UILoading_Auto.prototype, "Bar", void 0);
      __decorate([ property(cc.Label) ], UILoading_Auto.prototype, "Tip", void 0);
      __decorate([ property(cc.Animation) ], UILoading_Auto.prototype, "Ani", void 0);
      UILoading_Auto = __decorate([ ccclass ], UILoading_Auto);
      return UILoading_Auto;
    }(cc.Component);
    exports.default = UILoading_Auto;
    cc._RF.pop();
  }, {} ],
  UILoading: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "f5535NOnxVA4oA5HsMZ5MRw", "UILoading");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const lodash_1 = require("lodash");
    const GlobalData_1 = require("../Config/GlobalData");
    const InitGameData_1 = require("../Config/InitGameData");
    const ResConfig_1 = require("../Config/ResConfig");
    const TableKey_1 = require("../Config/TableKey");
    const Game_1 = require("../Logic/Game");
    const UIConfig_1 = require("../UIConfig");
    const AdapterMgr_1 = require("../UIFrame/AdapterMgr");
    const CocosHelper_1 = require("../UIFrame/CocosHelper");
    const UIForm_1 = require("../UIFrame/UIForm");
    const {ccclass: ccclass, property: property} = cc._decorator;
    let UILoading = class UILoading extends UIForm_1.UITips {
      constructor() {
        super(...arguments);
        this.prefabMap = new Map();
      }
      start() {}
      onShow(params) {
        var GameBG = document.getElementById("GameBg");
        GameBG && (GameBG.style.display = "none");
        AdapterMgr_1.default.inst.adapteByType(AdapterMgr_1.AdapterType.StretchHeight | AdapterMgr_1.AdapterType.StretchWidth, this.node);
        this.view.Ani.playAdditive(ResConfig_1.RoleState.run);
        this.getPreloadPrefab();
        this.initGameData();
        this.initProgress();
      }
      getPreloadPrefab() {
        const staticPropertyNames = Object.getOwnPropertyNames(UIConfig_1.default);
        for (const propertyName of staticPropertyNames) "prototype" !== propertyName && UIConfig_1.default[propertyName] && UIConfig_1.default[propertyName]["prefabUrl"] && this.prefabMap.set(propertyName, UIConfig_1.default[propertyName].prefabUrl);
      }
      initProgress() {
        return __awaiter(this, void 0, void 0, function*() {
          let i = 0;
          this.view.Bar.progress = i;
          if (this.prefabMap.size) for (let [key, path] of this.prefabMap) {
            i++;
            yield CocosHelper_1.default.preLoadResSync(path, cc.Prefab).then(prefab => {
              this.view.Bar.progress = i / this.prefabMap.size;
              this.view.Bar.progress >= 1 && this.closeSelf();
            });
          }
        });
      }
      initGameData() {
        let tableData = {};
        tableData[TableKey_1.TableKey.MATE] = InitGameData_1.InitGameData.RawMaterial;
        tableData[TableKey_1.TableKey.USER] = InitGameData_1.InitGameData.UserData;
        tableData[TableKey_1.TableKey.RECIPE] = InitGameData_1.InitGameData.RecipeList;
        tableData[TableKey_1.TableKey.SHOP] = InitGameData_1.InitGameData.StoreData;
        tableData[TableKey_1.TableKey.TABLE] = InitGameData_1.InitGameData.Table;
        for (let key of Object.keys(tableData)) this.insertTabel(key, tableData[key]);
      }
      insertTabel(TableKey, data) {
        let tableData = Game_1.default.dbMgr.query(TableKey);
        if (0 == tableData.length || GlobalData_1.GlobalData.forceUpdateTable) {
          tableData = this.addUid(data);
          GlobalData_1.GlobalData.forceUpdateTable && Game_1.default.dbMgr.delete(TableKey);
          Game_1.default.dbMgr.insertInitData(TableKey, tableData);
        }
      }
      addUid(arr) {
        arr = lodash_1.map(arr, (item, index) => Object.assign(Object.assign({}, item), {
          uid: index + 1
        }));
        return arr;
      }
    };
    UILoading = __decorate([ ccclass ], UILoading);
    exports.default = UILoading;
    cc._RF.pop();
  }, {
    "../Config/GlobalData": "GlobalData",
    "../Config/InitGameData": "InitGameData",
    "../Config/ResConfig": "ResConfig",
    "../Config/TableKey": "TableKey",
    "../Logic/Game": "Game",
    "../UIConfig": "UIConfig",
    "../UIFrame/AdapterMgr": "AdapterMgr",
    "../UIFrame/CocosHelper": "CocosHelper",
    "../UIFrame/UIForm": "UIForm",
    lodash: 1
  } ],
  UIManager: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "e31dcGQp2pBEaii62Cywsyt", "UIManager");
    "use strict";
    var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const LRUCache_1 = require("../Common/Utils/LRUCache");
    const Scene_1 = require("../Scene/Scene");
    const AdapterMgr_1 = require("./AdapterMgr");
    const EventCenter_1 = require("./EventCenter");
    const EventType_1 = require("./EventType");
    const ModalMgr_1 = require("./ModalMgr");
    const ModalMgr1_1 = require("./ModalMgr1");
    const ResMgr_1 = require("./ResMgr");
    const Struct_1 = require("./Struct");
    const SysDefine_1 = require("./config/SysDefine");
    const TAG = "UIManager";
    class UIManager {
      constructor() {
        this._UIROOT = null;
        this._ndScreen = null;
        this._ndDrawer = null;
        this._ndFixed = null;
        this._ndPopUp = null;
        this._ndToast = null;
        this._ndTips = null;
        this._windows = [];
        this._drawers = [];
        this._allForms = cc.js.createMap();
        this._showingForms = cc.js.createMap();
        this._tipsForms = cc.js.createMap();
        this._loadingForm = cc.js.createMap();
        this._closingForm = cc.js.createMap();
        this._LRUCache = new LRUCache_1.LRUCache(3);
      }
      static getInstance() {
        if (null == this.instance) {
          this.instance = new UIManager();
          let canvas = cc.director.getScene().getChildByName("Canvas");
          let scene = canvas.getChildByName(SysDefine_1.SysDefine.SYS_SCENE_NODE);
          if (scene) !scene.getComponent(Scene_1.default) && scene.addComponent(Scene_1.default); else {
            scene = new cc.Node(SysDefine_1.SysDefine.SYS_SCENE_NODE);
            scene.addComponent(Scene_1.default);
            scene.parent = canvas;
          }
          let UIROOT = this.instance._UIROOT = new cc.Node(SysDefine_1.SysDefine.SYS_UIROOT_NODE);
          scene.addChild(UIROOT);
          UIROOT.addChild(this.instance._ndScreen = new cc.Node(SysDefine_1.SysDefine.SYS_SCREEN_NODE));
          UIROOT.addChild(this.instance._ndDrawer = new cc.Node(SysDefine_1.SysDefine.SYS_DRAWER_NODE));
          UIROOT.addChild(this.instance._ndFixed = new cc.Node(SysDefine_1.SysDefine.SYS_FIXED_NODE));
          UIROOT.addChild(this.instance._ndPopUp = new cc.Node(SysDefine_1.SysDefine.SYS_POPUP_NODE));
          UIROOT.addChild(this.instance._ndToast = new cc.Node(SysDefine_1.SysDefine.SYS_TOAST_NODE));
          UIROOT.addChild(this.instance._ndTips = new cc.Node(SysDefine_1.SysDefine.SYS_TOPTIPS_NODE));
          cc.director.once(cc.Director.EVENT_BEFORE_SCENE_LAUNCH, () => {
            this.instance = null;
          });
        }
        return this.instance;
      }
      loadUIForm(prefabPath) {
        return __awaiter(this, void 0, void 0, function*() {
          let uiBase = yield this._loadForm(prefabPath);
          if (!uiBase) {
            console.warn(`${uiBase}\u6ca1\u6709\u88ab\u6210\u529f\u52a0\u8f7d`);
            return null;
          }
          return uiBase;
        });
      }
      openForm(form, params, formData) {
        return __awaiter(this, void 0, void 0, function*() {
          let prefabPath = form.prefabUrl;
          if (!prefabPath || prefabPath.length <= 0) {
            cc.warn(`${prefabPath}, \u53c2\u6570\u9519\u8bef`);
            return;
          }
          if (this.checkFormShowing(prefabPath)) {
            cc.warn(`${prefabPath}, \u7a97\u4f53\u6b63\u5728\u663e\u793a\u4e2d`);
            return null;
          }
          let com = yield this._loadForm(prefabPath);
          if (!com) {
            cc.warn(`${prefabPath} \u52a0\u8f7d\u5931\u8d25\u4e86!`);
            return null;
          }
          com.fid = prefabPath;
          com.formData = formData;
          switch (com.formType) {
           case SysDefine_1.FormType.Screen:
            yield this.enterToScreen(com.fid, params);
            break;

           case SysDefine_1.FormType.Fixed:
            yield this.enterToFixed(com.fid, params);
            break;

           case SysDefine_1.FormType.Window:
            yield this.enterToPopup(com.fid, params);
            break;

           case SysDefine_1.FormType.Drawer:
            yield this.enterToDrawer(com.fid, params);
            break;

           case SysDefine_1.FormType.Tips:
            yield this.enterToTips(com.fid, params);
          }
          com.closeType === Struct_1.ECloseType.LRU && this._LRUCache.remove(com.fid);
          return com;
        });
      }
      closeForm(form, params, formData) {
        return __awaiter(this, void 0, void 0, function*() {
          let prefabPath = form.prefabUrl;
          if (!prefabPath || prefabPath.length <= 0) {
            cc.warn(TAG, `${prefabPath}, \u53c2\u6570\u9519\u8bef`);
            return false;
          }
          let com = this._allForms[prefabPath];
          if (!com) return false;
          if (!this.checkFormShowing(prefabPath) && form.type !== SysDefine_1.FormType.Tips) {
            cc.warn(TAG, `${prefabPath}, \u5df2\u7ecf\u5173\u95ed\u4e86, \u8bf7\u4e0d\u8981\u91cd\u590d\u5173\u95ed`);
            return false;
          }
          if (this._closingForm[prefabPath]) {
            cc.warn(TAG, `${prefabPath}, form\u6b63\u5728\u5173\u95ed\u4e2d`);
            return;
          }
          this._closingForm[prefabPath] = com;
          switch (com.formType) {
           case SysDefine_1.FormType.Screen:
            yield this.exitToScreen(prefabPath, params);
            break;

           case SysDefine_1.FormType.Fixed:
            yield this.exitToFixed(prefabPath, params);
            break;

           case SysDefine_1.FormType.Drawer:
            yield this.exitToDrawer(prefabPath, params);
            break;

           case SysDefine_1.FormType.Window:
            yield this.exitToPopup(prefabPath, params);
            EventCenter_1.EventCenter.emit(EventType_1.EventType.WindowClosed, prefabPath);
            break;

           case SysDefine_1.FormType.Tips:
            yield this.exitToTips(prefabPath, params);
          }
          EventCenter_1.EventCenter.emit(EventType_1.EventType.FormClosed, prefabPath);
          com.formData && com.formData.onClose && com.formData.onClose();
          switch (com.closeType) {
           case Struct_1.ECloseType.CloseAndDestory:
            this.destoryForm(com);
            break;

           case Struct_1.ECloseType.LRU:
            this.putLRUCache(com);
          }
          this._closingForm[prefabPath] = null;
          delete this._closingForm[prefabPath];
          return true;
        });
      }
      _loadForm(prefabPath) {
        return __awaiter(this, void 0, void 0, function*() {
          let com = this._allForms[prefabPath];
          if (com) return com;
          return new Promise((resolve, reject) => {
            if (this._loadingForm[prefabPath]) {
              this._loadingForm[prefabPath].push(resolve);
              return;
            }
            this._loadingForm[prefabPath] = [ resolve ];
            this._doLoadUIForm(prefabPath).then(com => {
              for (const func of this._loadingForm[prefabPath]) func(com);
              this._loadingForm[prefabPath] = null;
              delete this._loadingForm[prefabPath];
            });
          });
        });
      }
      _doLoadUIForm(prefabPath) {
        return __awaiter(this, void 0, void 0, function*() {
          let prefab = yield ResMgr_1.default.inst.loadFormPrefab(prefabPath);
          let node = cc.instantiate(prefab);
          let com = this.addNode(node);
          this._allForms[prefabPath] = com;
          return com;
        });
      }
      addNode(node) {
        let com = node.getComponent(cc.UIBase);
        if (!com) {
          cc.warn(`${node.name} \u7ed3\u70b9\u6ca1\u6709\u7ed1\u5b9aUIBase`);
          return null;
        }
        node.active = false;
        switch (com.formType) {
         case SysDefine_1.FormType.Screen:
          this._ndScreen.addChild(node);
          break;

         case SysDefine_1.FormType.Fixed:
          this._ndFixed.addChild(node);
          break;

         case SysDefine_1.FormType.Window:
          this._ndPopUp.addChild(node);
          break;

         case SysDefine_1.FormType.Drawer:
          this._ndDrawer.addChild(node);
          break;

         case SysDefine_1.FormType.Toast:
          this._ndToast.addChild(node);
          break;

         case SysDefine_1.FormType.Tips:
          this._ndTips.addChild(node);
        }
        return com;
      }
      enterToScreen(fid, params) {
        return __awaiter(this, void 0, void 0, function*() {
          let arr = [];
          for (let key in this._showingForms) arr.push(this._showingForms[key].closeSelf());
          yield Promise.all(arr);
          let com = this._allForms[fid];
          if (!com) return;
          this._showingForms[fid] = com;
          AdapterMgr_1.default.inst.adapteByType(AdapterMgr_1.AdapterType.StretchHeight | AdapterMgr_1.AdapterType.StretchWidth, com.node);
          yield com._preInit(params);
          com.onShow(params);
          yield this.showEffect(com);
          com.onAfterShow(params);
        });
      }
      enterToFixed(fid, params) {
        return __awaiter(this, void 0, void 0, function*() {
          let com = this._allForms[fid];
          if (!com) return;
          yield com._preInit(params);
          com.onShow(params);
          this._showingForms[fid] = com;
          yield this.showEffect(com);
          com.onAfterShow(params);
        });
      }
      enterToPopup(fid, params) {
        return __awaiter(this, void 0, void 0, function*() {
          let com = this._allForms[fid];
          if (!com) return;
          yield com._preInit(params);
          this._windows.push(com);
          for (let i = 0; i < this._windows.length; i++) this._windows[i].node.zIndex = i + 1;
          com.onShow(params);
          this._showingForms[fid] = com;
          ModalMgr_1.default.inst.checkModalWindow(this._windows);
          yield this.showEffect(com);
          com.onAfterShow(params);
        });
      }
      enterToDrawer(fid, params) {
        return __awaiter(this, void 0, void 0, function*() {
          let com = this._allForms[fid];
          if (!com) return;
          yield com._preInit(params);
          this._drawers.push(com);
          for (let i = 0; i < this._drawers.length; i++) this._drawers[i].node.zIndex = i + 1;
          com.onShow(params);
          this._showingForms[fid] = com;
          ModalMgr1_1.default.inst.checkModalWindow(this._drawers);
          yield this.showEffect(com);
          com.onAfterShow(params);
        });
      }
      enterToTips(fid, params) {
        return __awaiter(this, void 0, void 0, function*() {
          let com = this._allForms[fid];
          if (!com) return;
          yield com._preInit(params);
          this._tipsForms[fid] = com;
          com.onShow(params);
          yield this.showEffect(com);
          com.onAfterShow(params);
        });
      }
      enterToToast(com, params) {
        return __awaiter(this, void 0, void 0, function*() {
          yield com._preInit(params);
          com.onShow(params);
          yield this.showEffect(com);
          com.onAfterShow(params);
        });
      }
      exitToScreen(fid, params) {
        return __awaiter(this, void 0, void 0, function*() {
          let com = this._showingForms[fid];
          if (!com) return;
          com.onHide(params);
          yield this.hideEffect(com);
          com.onAfterHide(params);
          this._showingForms[fid] = null;
          delete this._showingForms[fid];
        });
      }
      exitToFixed(fid, params) {
        return __awaiter(this, void 0, void 0, function*() {
          let com = this._allForms[fid];
          if (!com) return;
          com.onHide(params);
          yield this.hideEffect(com);
          com.onAfterHide(params);
          this._showingForms[fid] = null;
          delete this._showingForms[fid];
        });
      }
      exitToPopup(fid, params) {
        return __awaiter(this, void 0, void 0, function*() {
          if (this._windows.length <= 0) return;
          let com = null;
          for (let i = this._windows.length - 1; i >= 0; i--) if (this._windows[i].fid === fid) {
            com = this._windows[i];
            this._windows.splice(i, 1);
          }
          if (!com) return;
          com.onHide(params);
          ModalMgr_1.default.inst.checkModalWindow(this._windows);
          yield this.hideEffect(com);
          com.onAfterHide(params);
          this._showingForms[fid] = null;
          delete this._showingForms[fid];
        });
      }
      exitToDrawer(fid, params) {
        return __awaiter(this, void 0, void 0, function*() {
          if (this._drawers.length <= 0) return;
          let com = null;
          for (let i = this._drawers.length - 1; i >= 0; i--) if (this._drawers[i].fid === fid) {
            com = this._drawers[i];
            this._drawers.splice(i, 1);
          }
          if (!com) return;
          com.onHide(params);
          ModalMgr1_1.default.inst.checkModalWindow(this._drawers);
          yield this.hideEffect(com);
          com.onAfterHide(params);
          this._showingForms[fid] = null;
          delete this._showingForms[fid];
        });
      }
      exitToTips(fid, params) {
        return __awaiter(this, void 0, void 0, function*() {
          let com = this._allForms[fid];
          if (!com) return;
          com.onHide(params);
          yield this.hideEffect(com);
          com.onAfterHide(params);
          this._tipsForms[fid] = null;
          delete this._tipsForms[fid];
        });
      }
      exitToToast(com, params) {
        return __awaiter(this, void 0, void 0, function*() {
          com.onHide(params);
          yield this.hideEffect(com);
          com.onAfterHide(params);
        });
      }
      showEffect(baseUI) {
        var _a;
        return __awaiter(this, void 0, void 0, function*() {
          baseUI.node.active = true;
          !(null === (_a = baseUI.formData) || void 0 === _a ? void 0 : _a.quick) && (yield baseUI.showEffect());
        });
      }
      hideEffect(baseUI) {
        var _a;
        return __awaiter(this, void 0, void 0, function*() {
          !(null === (_a = baseUI.formData) || void 0 === _a ? void 0 : _a.quick) && (yield baseUI.hideEffect());
          baseUI.node.active = false;
        });
      }
      destoryForm(com) {
        EventCenter_1.EventCenter.targetOff(com);
        com.node.destroy();
        ResMgr_1.default.inst.destoryFormPrefab(com.fid);
        ResMgr_1.default.inst.destoryDynamicRes(com.fid);
        this._allForms[com.fid] = null;
        delete this._allForms[com.fid];
      }
      putLRUCache(com) {
        this._LRUCache.put(com.fid);
        if (!this._LRUCache.needDelete()) return;
        let deleteFid = this._LRUCache.deleteLastNode();
        if (deleteFid) {
          true, console.log("close form id:", deleteFid, this._LRUCache.toString());
          let com = this.getForm(deleteFid);
          if (!com || !com.node) return;
          com && this.destoryForm(com);
        }
      }
      checkFormShowing(fid) {
        return !!this._showingForms[fid];
      }
      checkFormLoading(prefabPath) {
        let com = this._loadingForm[prefabPath];
        return !!com;
      }
      getForm(fId) {
        return this._allForms[fId];
      }
      getUIROOT() {
        return this._UIROOT;
      }
    }
    exports.default = UIManager;
    UIManager.instance = null;
    true;
    window["UIManager"] = UIManager;
    cc._RF.pop();
  }, {
    "../Common/Utils/LRUCache": "LRUCache",
    "../Scene/Scene": "Scene",
    "./AdapterMgr": "AdapterMgr",
    "./EventCenter": "EventCenter",
    "./EventType": "EventType",
    "./ModalMgr": "ModalMgr",
    "./ModalMgr1": "ModalMgr1",
    "./ResMgr": "ResMgr",
    "./Struct": "Struct",
    "./config/SysDefine": "SysDefine"
  } ],
  UIModalScript: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "80f365N6pFApJ6MlMUc+H9D", "UIModalScript");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = this && this.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (1 & t[0]) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, "function" === typeof Symbol && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([ n, v ]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = 2 & op[0] ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 
          0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          (y = 0, t) && (op = [ 2 & op[0], t.value ]);
          switch (op[0]) {
           case 0:
           case 1:
            t = op;
            break;

           case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

           case 5:
            _.label++;
            y = op[1];
            op = [ 0 ];
            continue;

           case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;

           default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (6 === op[0] || 2 === op[0])) {
              _ = 0;
              continue;
            }
            if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (6 === op[0] && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop();
            _.trys.pop();
            continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [ 6, e ];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (5 & op[0]) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var RenderUtil_1 = require("../Common/Utils/RenderUtil");
    var CocosHelper_1 = require("./CocosHelper");
    var UIManager_1 = require("./UIManager");
    var WindowMgr_1 = require("./WindowMgr");
    var SysDefine_1 = require("./config/SysDefine");
    var BAN_FALG = cc.RenderFlow.FLAG_RENDER | cc.RenderFlow.FLAG_POST_RENDER;
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
    var UIModalScript = function(_super) {
      __extends(UIModalScript, _super);
      function UIModalScript() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.sprite = null;
        _this.camera = null;
        _this._texture = null;
        _this._renderTexture = null;
        _this._renderTextures = [];
        return _this;
      }
      UIModalScript.prototype.init = function() {
        var size = cc.view.getVisibleSize();
        this.node.height = size.height;
        this.node.width = size.width;
        this.node.addComponent(cc.Button);
        this.node.on("click", this.clickMaskWindow, this);
        this.sprite = this.node.addComponent(cc.Sprite);
        this.useNormalSprite(this.sprite);
        this.node.color = new cc.Color(255, 255, 255);
        this.node.opacity = 0;
        this.node.active = false;
      };
      UIModalScript.prototype.showModal = function(lucenyType, time, isEasing, dualBlur) {
        void 0 === time && (time = .6);
        void 0 === isEasing && (isEasing = true);
        void 0 === dualBlur && (dualBlur = false);
        return __awaiter(this, void 0, void 0, function() {
          var node, o;
          return __generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              if (dualBlur) {
                if (!this.camera) {
                  node = new cc.Node("BlurCamera");
                  this.camera = node.addComponent(cc.Camera);
                  cc.find("Canvas").addChild(node);
                }
                this.useDualBlurSprite(this.camera);
                this.node.color = cc.Color.WHITE;
              } else if (lucenyType === SysDefine_1.ModalOpacity.GuassBlur) {
                this.useBlurSprite(this.sprite);
                lucenyType = SysDefine_1.ModalOpacity.OpacityFull;
              } else {
                this.useNormalSprite(this.sprite);
                this.node.color = cc.Color.BLACK;
              }
              o = 0;
              switch (lucenyType) {
               case SysDefine_1.ModalOpacity.None:
                this.node.active = false;
                break;

               case SysDefine_1.ModalOpacity.OpacityZero:
                o = 0;
                break;

               case SysDefine_1.ModalOpacity.OpacityLow:
                o = 63;
                break;

               case SysDefine_1.ModalOpacity.OpacityHalf:
                o = 126;
                break;

               case SysDefine_1.ModalOpacity.OpacityHigh:
                o = 189;
                break;

               case SysDefine_1.ModalOpacity.OpacityFull:
                o = 255;
              }
              if (!this.node.active) return [ 2 ];
              if (!isEasing) return [ 3, 2 ];
              return [ 4, CocosHelper_1.default.runTweenSync(this.node, cc.tween().to(time, {
                opacity: o
              })) ];

             case 1:
              _a.sent();
              return [ 3, 3 ];

             case 2:
              this.node.opacity = o;
              _a.label = 3;

             case 3:
              return [ 2 ];
            }
          });
        });
      };
      UIModalScript.prototype.clickMaskWindow = function() {
        return __awaiter(this, void 0, void 0, function() {
          var com;
          return __generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              com = UIManager_1.default.getInstance().getForm(this.fid);
              if (!(com && com.modalType.clickMaskClose)) return [ 3, 2 ];
              return [ 4, WindowMgr_1.default.close(this.fid) ];

             case 1:
              _a.sent();
              _a.label = 2;

             case 2:
              return [ 2 ];
            }
          });
        });
      };
      UIModalScript.prototype.getSingleTexture = function() {
        if (this._texture) return this._texture;
        var data = new Uint8Array(16);
        for (var i = 0; i < 2; i++) for (var j = 0; j < 2; j++) {
          data[2 * i * 4 + 4 * j + 0] = 255;
          data[2 * i * 4 + 4 * j + 1] = 255;
          data[2 * i * 4 + 4 * j + 2] = 255;
          data[2 * i * 4 + 4 * j + 3] = 255;
        }
        var texture = new cc.Texture2D();
        texture.name = "single color";
        texture.initWithData(data, cc.Texture2D.PixelFormat.RGBA8888, 2, 2);
        texture.handleLoadedTexture();
        this._texture = texture;
        texture.addRef();
        return this._texture;
      };
      UIModalScript.prototype.useNormalSprite = function(sprite) {
        sprite.sizeMode = cc.Sprite.SizeMode.CUSTOM;
        sprite.type = cc.Sprite.Type.SIMPLE;
        sprite.spriteFrame = new cc.SpriteFrame(this.getSingleTexture());
      };
      UIModalScript.prototype.useBlurSprite = function(sprite) {
        sprite.sizeMode = cc.Sprite.SizeMode.CUSTOM;
        sprite.type = cc.Sprite.Type.SIMPLE;
        var data = RenderUtil_1.default.getPixelsData(cc.find("Canvas"), true);
        var texture = new cc.Texture2D();
        texture.initWithData(data, cc.Texture2D.PixelFormat.RGBA8888, sprite.node.width, sprite.node.height);
        sprite.spriteFrame = new cc.SpriteFrame(texture);
      };
      UIModalScript.prototype.useDualBlurSprite = function(camera) {
        var _this = this;
        var dirtyNodes = [];
        var disRenderChildren = function() {
          var tips = UIManager_1.default.getInstance().getUIROOT().getChildByName(SysDefine_1.SysDefine.SYS_TOPTIPS_NODE).children;
          for (var _i = 0, tips_1 = tips; _i < tips_1.length; _i++) {
            var node = tips_1[_i];
            if (!node._activeInHierarchy || 0 == node.opacity) continue;
            node["_dirtyRenderFlag"] = node._renderFlag;
            node._renderFlag &= ~(cc.RenderFlow.FLAG_CHILDREN | cc.RenderFlow.FLAG_RENDER);
            dirtyNodes.push(node);
          }
          _this.node._renderFlag &= ~cc.RenderFlow.FLAG_RENDER;
          var windows = UIManager_1.default.getInstance().getUIROOT().getChildByName(SysDefine_1.SysDefine.SYS_POPUP_NODE).children;
          for (var i = windows.length - 1; i >= 0; i--) if (windows[i].zIndex > _this.node.zIndex) {
            var node = windows[i];
            if (!node._activeInHierarchy || 0 == node.opacity) continue;
            node["_dirtyRenderFlag"] = node._renderFlag;
            node._renderFlag &= ~(cc.RenderFlow.FLAG_CHILDREN | cc.RenderFlow.FLAG_RENDER);
            dirtyNodes.push(node);
          }
        };
        var rerenderChildren = function() {
          for (var _i = 0, dirtyNodes_1 = dirtyNodes; _i < dirtyNodes_1.length; _i++) {
            var node = dirtyNodes_1[_i];
            node._renderFlag = node["_dirtyRenderFlag"];
          }
        };
        if (!this._renderTexture) {
          var renderTexture = this._renderTexture = new cc.RenderTexture();
          renderTexture.initWithSize(cc.visibleRect.width, cc.visibleRect.height, cc.game._renderContext.STENCIL_INDEX8);
        }
        camera.enabled = true;
        camera.targetTexture = this._renderTexture;
        disRenderChildren();
        camera.render();
        rerenderChildren();
        this.sprite.spriteFrame.setTexture(camera.targetTexture);
        this.sprite.markForRender(true);
        this.renderDualBlur(camera, 3);
        camera.enabled = false;
      };
      UIModalScript.prototype.renderDualBlur = function(camera, iterations) {
        var size = cc.view.getVisibleSize();
        if (this._renderTextures.length <= 0) for (var i = 0; i < iterations; i++) {
          var r = Math.pow(2, i);
          var renderTexture = new cc.RenderTexture();
          renderTexture.initWithSize(cc.visibleRect.width / r | 0, cc.visibleRect.height / r | 0);
          this._renderTextures.push(renderTexture);
        }
        if (!MaterialDown) {
          MaterialDown = this.genMaterial(EFFECT_DOWN);
          MaterialDown.setProperty("v_halfpixel", [ .5 / size.width, .5 / size.height ]);
          MaterialDown.setProperty("v_offset", [ 4, 4 ]);
        }
        this.sprite.setMaterial(0, MaterialDown);
        for (var i = 0; i < iterations; i++) {
          camera.targetTexture = this._renderTextures[i];
          camera.render(this.sprite.node);
          this.sprite.spriteFrame.setTexture(camera.targetTexture);
          this.sprite.markForRender(true);
        }
        if (!MaterialUp) {
          MaterialUp = this.genMaterial(EFFECT_UP);
          MaterialUp.setProperty("v_halfpixel", [ .5 / size.width, .5 / size.height ]);
          MaterialUp.setProperty("v_offset", [ 4, 4 ]);
        }
        this.sprite.setMaterial(0, MaterialUp);
        for (var i = iterations - 1; i > 0; i--) {
          camera.targetTexture = this._renderTextures[i - 1];
          camera.render(this.sprite.node);
          this.sprite.spriteFrame.setTexture(camera.targetTexture);
          this.sprite.markForRender(true);
        }
        this.sprite.setMaterial(0, cc.Material.getBuiltinMaterial("2d-sprite"));
      };
      UIModalScript.prototype.genMaterial = function(effect) {
        var asset = cc.deserialize(effect, {
          priority: 0,
          responseType: "json"
        });
        asset.onLoad && asset.onLoad();
        asset.__onLoadInvoked__ = true;
        return cc.Material.create(asset, 0);
      };
      UIModalScript = __decorate([ ccclass ], UIModalScript);
      return UIModalScript;
    }(cc.Component);
    exports.default = UIModalScript;
    var MaterialDown = null;
    var MaterialUp = null;
    var EFFECT_UP = {
      __type__: "cc.EffectAsset",
      _name: "BlurUp",
      _objFlags: 0,
      _native: "",
      properties: null,
      techniques: [ {
        passes: [ {
          blendState: {
            targets: [ {
              blend: true
            } ]
          },
          rasterizerState: {
            cullMode: 0
          },
          properties: {
            texture: {
              value: "white",
              type: 29
            },
            alphaThreshold: {
              value: [ .5 ],
              type: 13
            }
          },
          program: "BlurUp|vs|fs"
        } ]
      } ],
      shaders: [ {
        hash: 3005313742,
        glsl3: {
          vert: "\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}",
          frag: "\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nin vec4 v_color;\n#if USE_TEXTURE\nin vec2 v_uv0;\nuniform sampler2D texture;\n#endif\nuniform CustomUniform {\n  vec2 v_halfpixel;\n  vec2 v_offset;\n};\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  vec4 sum = texture2D(texture, v_uv0) * 4.0;\n  sum += texture2D(texture, v_uv0 - v_halfpixel.xy * v_offset);\n  sum += texture2D(texture, v_uv0 + v_halfpixel.xy * v_offset);\n  sum += texture2D(texture, v_uv0 + vec2(v_halfpixel.x, -v_halfpixel.y) * v_offset);\n  sum += texture2D(texture, v_uv0 - vec2(v_halfpixel.x, -v_halfpixel.y) * v_offset);\n  o = sum / 8.0;\n  o *= v_color;\n  ALPHA_TEST(o);\n  #if USE_BGRA\n    gl_FragColor = o.bgra;\n  #else\n    gl_FragColor = o.rgba;\n  #endif\n}"
        },
        glsl1: {
          vert: "\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}",
          frag: "\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nvarying vec4 v_color;\n#if USE_TEXTURE\nvarying vec2 v_uv0;\nuniform sampler2D texture;\n#endif\nuniform vec2 v_halfpixel;\nuniform vec2 v_offset;\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  vec4 sum = texture2D(texture, v_uv0) * 4.0;\n  sum += texture2D(texture, v_uv0 - v_halfpixel.xy * v_offset);\n  sum += texture2D(texture, v_uv0 + v_halfpixel.xy * v_offset);\n  sum += texture2D(texture, v_uv0 + vec2(v_halfpixel.x, -v_halfpixel.y) * v_offset);\n  sum += texture2D(texture, v_uv0 - vec2(v_halfpixel.x, -v_halfpixel.y) * v_offset);\n  o = sum / 8.0;\n  o *= v_color;\n  ALPHA_TEST(o);\n  #if USE_BGRA\n    gl_FragColor = o.bgra;\n  #else\n    gl_FragColor = o.rgba;\n  #endif\n}"
        },
        builtins: {
          globals: {
            blocks: [ {
              name: "CCGlobal",
              defines: []
            } ],
            samplers: []
          },
          locals: {
            blocks: [ {
              name: "CCLocal",
              defines: []
            } ],
            samplers: []
          }
        },
        defines: [ {
          name: "USE_TEXTURE",
          type: "boolean",
          defines: []
        }, {
          name: "CC_USE_MODEL",
          type: "boolean",
          defines: []
        }, {
          name: "USE_ALPHA_TEST",
          type: "boolean",
          defines: []
        }, {
          name: "USE_BGRA",
          type: "boolean",
          defines: []
        } ],
        blocks: [ {
          name: "ALPHA_TEST",
          members: [ {
            name: "alphaThreshold",
            type: 13,
            count: 1
          } ],
          defines: [ "USE_ALPHA_TEST" ],
          binding: 0
        }, {
          name: "CustomUniform",
          members: [ {
            name: "v_halfpixel",
            type: 14,
            count: 1
          }, {
            name: "v_offset",
            type: 14,
            count: 1
          } ],
          defines: [],
          binding: 1
        } ],
        samplers: [ {
          name: "texture",
          type: 29,
          count: 1,
          defines: [ "USE_TEXTURE" ],
          binding: 30
        } ],
        record: null,
        name: "BlurUp|vs|fs"
      } ]
    };
    var EFFECT_DOWN = {
      __type__: "cc.EffectAsset",
      _name: "BlurDown",
      _objFlags: 0,
      _native: "",
      properties: null,
      techniques: [ {
        passes: [ {
          blendState: {
            targets: [ {
              blend: true
            } ]
          },
          rasterizerState: {
            cullMode: 0
          },
          properties: {
            texture: {
              value: "white",
              type: 29
            },
            alphaThreshold: {
              value: [ .5 ],
              type: 13
            }
          },
          program: "BlurDown|vs|fs"
        } ]
      } ],
      shaders: [ {
        hash: 4206633856,
        glsl3: {
          vert: "\nprecision highp float;\nuniform CCGlobal {\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n  vec4 cc_time;\n  mediump vec4 cc_screenSize;\n  mediump vec4 cc_screenScale;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}",
          frag: "\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  };\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nin vec4 v_color;\n#if USE_TEXTURE\nin vec2 v_uv0;\nuniform sampler2D texture;\n#endif\nuniform CustomUniform {\n  vec2 v_halfpixel;\n  vec2 v_offset;\n};\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  vec4 sum = texture2D(texture, v_uv0 + vec2(-v_halfpixel.x * 2.0, 0.0) * v_offset);\n  sum += texture2D(texture, v_uv0 + vec2(-v_halfpixel.x, v_halfpixel.y) * v_offset) * 2.0;\n  sum += texture2D(texture, v_uv0 + vec2(0.0, v_halfpixel.y * 2.0) * v_offset);\n  sum += texture2D(texture, v_uv0 + vec2(v_halfpixel.x, v_halfpixel.y) * v_offset) * 2.0;\n  sum += texture2D(texture, v_uv0 + vec2(v_halfpixel.x * 2.0, 0.0) * v_offset);\n  sum += texture2D(texture, v_uv0 + vec2(v_halfpixel.x, -v_halfpixel.y) * v_offset) * 2.0;\n  sum += texture2D(texture, v_uv0 + vec2(0.0, -v_halfpixel.y * 2.0) * v_offset);\n  sum += texture2D(texture, v_uv0 + vec2(-v_halfpixel.x, -v_halfpixel.y) * v_offset) * 2.0;\n  o = sum / 12.0;\n  o *= v_color;\n  ALPHA_TEST(o);\n  #if USE_BGRA\n    gl_FragColor = o.bgra;\n  #else\n    gl_FragColor = o.rgba;\n  #endif\n}"
        },
        glsl1: {
          vert: "\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n  v_color = a_color;\n  gl_Position = pos;\n}",
          frag: "\nprecision highp float;\n#if USE_ALPHA_TEST\n  uniform float alphaThreshold;\n#endif\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\nvarying vec4 v_color;\n#if USE_TEXTURE\nvarying vec2 v_uv0;\nuniform sampler2D texture;\n#endif\nuniform vec2 v_halfpixel;\nuniform vec2 v_offset;\nvoid main () {\n  vec4 o = vec4(1, 1, 1, 1);\n  vec4 sum = texture2D(texture, v_uv0 + vec2(-v_halfpixel.x * 2.0, 0.0) * v_offset);\n  sum += texture2D(texture, v_uv0 + vec2(-v_halfpixel.x, v_halfpixel.y) * v_offset) * 2.0;\n  sum += texture2D(texture, v_uv0 + vec2(0.0, v_halfpixel.y * 2.0) * v_offset);\n  sum += texture2D(texture, v_uv0 + vec2(v_halfpixel.x, v_halfpixel.y) * v_offset) * 2.0;\n  sum += texture2D(texture, v_uv0 + vec2(v_halfpixel.x * 2.0, 0.0) * v_offset);\n  sum += texture2D(texture, v_uv0 + vec2(v_halfpixel.x, -v_halfpixel.y) * v_offset) * 2.0;\n  sum += texture2D(texture, v_uv0 + vec2(0.0, -v_halfpixel.y * 2.0) * v_offset);\n  sum += texture2D(texture, v_uv0 + vec2(-v_halfpixel.x, -v_halfpixel.y) * v_offset) * 2.0;\n  o = sum / 12.0;\n  o *= v_color;\n  ALPHA_TEST(o);\n  #if USE_BGRA\n    gl_FragColor = o.bgra;\n  #else\n    gl_FragColor = o.rgba;\n  #endif\n}"
        },
        builtins: {
          globals: {
            blocks: [ {
              name: "CCGlobal",
              defines: []
            } ],
            samplers: []
          },
          locals: {
            blocks: [ {
              name: "CCLocal",
              defines: []
            } ],
            samplers: []
          }
        },
        defines: [ {
          name: "USE_TEXTURE",
          type: "boolean",
          defines: []
        }, {
          name: "CC_USE_MODEL",
          type: "boolean",
          defines: []
        }, {
          name: "USE_ALPHA_TEST",
          type: "boolean",
          defines: []
        }, {
          name: "USE_BGRA",
          type: "boolean",
          defines: []
        } ],
        blocks: [ {
          name: "ALPHA_TEST",
          members: [ {
            name: "alphaThreshold",
            type: 13,
            count: 1
          } ],
          defines: [ "USE_ALPHA_TEST" ],
          binding: 0
        }, {
          name: "CustomUniform",
          members: [ {
            name: "v_halfpixel",
            type: 14,
            count: 1
          }, {
            name: "v_offset",
            type: 14,
            count: 1
          } ],
          defines: [],
          binding: 1
        } ],
        samplers: [ {
          name: "texture",
          type: 29,
          count: 1,
          defines: [ "USE_TEXTURE" ],
          binding: 30
        } ],
        record: null,
        name: "BlurDown|vs|fs"
      } ]
    };
    cc._RF.pop();
  }, {
    "../Common/Utils/RenderUtil": "RenderUtil",
    "./CocosHelper": "CocosHelper",
    "./UIManager": "UIManager",
    "./WindowMgr": "WindowMgr",
    "./config/SysDefine": "SysDefine"
  } ],
  UIRecipeInfo_Auto: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "e8b588mKChBlr4fUNYV5uvD", "UIRecipeInfo_Auto");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
    var UIRecipeInfo_Auto = function(_super) {
      __extends(UIRecipeInfo_Auto, _super);
      function UIRecipeInfo_Auto() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.icon = null;
        _this.title = null;
        _this.list = null;
        _this.infoLabel = null;
        return _this;
      }
      __decorate([ property(cc.Node) ], UIRecipeInfo_Auto.prototype, "icon", void 0);
      __decorate([ property(cc.Node) ], UIRecipeInfo_Auto.prototype, "title", void 0);
      __decorate([ property(cc.Node) ], UIRecipeInfo_Auto.prototype, "list", void 0);
      __decorate([ property(cc.Node) ], UIRecipeInfo_Auto.prototype, "infoLabel", void 0);
      UIRecipeInfo_Auto = __decorate([ ccclass ], UIRecipeInfo_Auto);
      return UIRecipeInfo_Auto;
    }(cc.Component);
    exports.default = UIRecipeInfo_Auto;
    cc._RF.pop();
  }, {} ],
  UIRecipeInfo: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "4c1bf2Vs3NBGoaQpraELDQE", "UIRecipeInfo");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var UIRecipeInfo_1;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const CommonUtils_1 = require("../Common/Utils/CommonUtils");
    const GlobalData_1 = require("../Config/GlobalData");
    const RecipeCoffeeItem_1 = require("../Game/Item/RecipeCoffeeItem");
    const Struct_1 = require("../UIFrame/Struct");
    const UIForm_1 = require("../UIFrame/UIForm");
    const SysDefine_1 = require("../UIFrame/config/SysDefine");
    const {ccclass: ccclass, property: property} = cc._decorator;
    let UIRecipeInfo = UIRecipeInfo_1 = class UIRecipeInfo extends UIForm_1.UIWindow {
      constructor() {
        super(...arguments);
        this.modalType = new Struct_1.ModalType(SysDefine_1.ModalOpacity.OpacityHigh, true);
        this.menu = null;
        this._data = null;
        this.itemMax = 6;
        this.rawArr = [];
        this._List$RecipeScroll = null;
      }
      start() {
        console.log("UIRecipeInfo start...");
      }
      onShow(data) {
        this._data = data;
        this.clearMenu();
      }
      onEnable() {
        this.rawArr = [];
        this.initUi(this._data);
        this.addRecipeItem(this._data);
        this._List$RecipeScroll = this.node.parent.getChildByName("UIRecipe").getChildByName("bg").getChildByName("_List$RecipeScroll");
        this._List$RecipeScroll.getComponent(cc.ScrollView).enabled = false;
      }
      onDisable() {
        this._List$RecipeScroll.getComponent(cc.ScrollView).enabled = true;
      }
      initUi(data) {
        this.view.icon.getComponent(RecipeCoffeeItem_1.default).initUi(data);
        this.view.title.getComponent(cc.Label).string = true == data["name"].includes("%s") ? data["name"].replace("%s", "") : data["name"];
        this.view.infoLabel.getComponent(cc.Label).string = data["intro"];
      }
      clearMenu() {
        this.view.list.children.forEach(node => {
          node && (node.active = false);
        });
      }
      addRecipeItem(data) {
        let id;
        let menu;
        for (let i = 1; i < this.itemMax + 1; ++i) {
          id = data[`raw${i}`];
          if ("" != data[`raw${i}`] && "/" != data[`raw${i}`]) {
            if (this.view.list.children[i]) {
              menu = this.view.list.children[i];
              menu.active = true;
            } else {
              menu = cc.instantiate(this.menu);
              menu.parent = this.view.list;
            }
            CommonUtils_1.CommonUtils.setItemSpriteFrame(menu.children[0].getComponent(cc.Sprite), `${GlobalData_1.GlobalData.rawPath}${id}`);
          }
        }
      }
      clickClose() {
        UIRecipeInfo_1.close();
      }
    };
    __decorate([ property(cc.Prefab) ], UIRecipeInfo.prototype, "menu", void 0);
    UIRecipeInfo = UIRecipeInfo_1 = __decorate([ ccclass ], UIRecipeInfo);
    exports.default = UIRecipeInfo;
    cc._RF.pop();
  }, {
    "../Common/Utils/CommonUtils": "CommonUtils",
    "../Config/GlobalData": "GlobalData",
    "../Game/Item/RecipeCoffeeItem": "RecipeCoffeeItem",
    "../UIFrame/Struct": "Struct",
    "../UIFrame/UIForm": "UIForm",
    "../UIFrame/config/SysDefine": "SysDefine"
  } ],
  UIRecipe_Auto: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "7c507WtnXpBuZdXkwVX0sUC", "UIRecipe_Auto");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var List_1 = require("./../Common/Components/List");
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
    var UIRecipe_Auto = function(_super) {
      __extends(UIRecipe_Auto, _super);
      function UIRecipe_Auto() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.RecipeScroll = null;
        _this.RecipeContent = null;
        _this.RecipeModule = null;
        return _this;
      }
      __decorate([ property(List_1.default) ], UIRecipe_Auto.prototype, "RecipeScroll", void 0);
      __decorate([ property(cc.Node) ], UIRecipe_Auto.prototype, "RecipeContent", void 0);
      __decorate([ property(cc.Node) ], UIRecipe_Auto.prototype, "RecipeModule", void 0);
      UIRecipe_Auto = __decorate([ ccclass ], UIRecipe_Auto);
      return UIRecipe_Auto;
    }(cc.Component);
    exports.default = UIRecipe_Auto;
    cc._RF.pop();
  }, {
    "./../Common/Components/List": "List"
  } ],
  UIRecipe: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "9eb62r7nFlCPL9oiiT962Sm", "UIRecipe");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var UIRecipe_1;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const RawMaterial_1 = require("../Config/RawMaterial");
    const RecipeItem_1 = require("../Game/Item/RecipeItem");
    const RecipeModuleItem_1 = require("../Game/Item/RecipeModuleItem");
    const Struct_1 = require("../UIFrame/Struct");
    const UIForm_1 = require("../UIFrame/UIForm");
    const SysDefine_1 = require("../UIFrame/config/SysDefine");
    const Game_1 = require("../Logic/Game");
    const TableKey_1 = require("../Config/TableKey");
    const {ccclass: ccclass, property: property} = cc._decorator;
    let UIRecipe = UIRecipe_1 = class UIRecipe extends UIForm_1.UIWindow {
      constructor() {
        super(...arguments);
        this.modalType = new Struct_1.ModalType(SysDefine_1.ModalOpacity.OpacityHigh, true);
        this.recipeModuleItem = null;
        this.curModuleNumber = 0;
        this.nodeHeight = [ 110, 130 ];
        this.titlePos = [ -50, -60 ];
        this.recipeList = [];
      }
      start() {
        console.log("UIRecipe start...");
      }
      onEnable() {
        this.curModuleNumber = 0;
        this.recipeList = Game_1.default.dbMgr.query(TableKey_1.TableKey.RECIPE);
        this.initUi();
      }
      onAfterShow(params) {
        this.view.RecipeScroll.numItems = this.recipeList.length;
        this.view.RecipeScroll.scrollTo(0, 0, .1);
      }
      onListGridRender(item, idx) {
        item.getComponent(RecipeItem_1.default).initUi(this.recipeList[idx], this);
      }
      initUi() {
        this.initRecipeModule();
      }
      clickClose() {
        UIRecipe_1.close();
      }
      initRecipeModule() {
        this.initAllModule();
        for (let i = 0; i < RawMaterial_1.RecipeModule.length; i++) if (this.view.RecipeModule.children[i]) this.view.RecipeModule.children[i].getComponent(RecipeModuleItem_1.default).initUi(i, this); else {
          let recipeModuleItem = cc.instantiate(this.recipeModuleItem);
          recipeModuleItem.parent = this.view.RecipeModule;
          recipeModuleItem.getComponent(RecipeModuleItem_1.default).initUi(i, this);
          recipeModuleItem.name = "" + i;
        }
      }
      initAllModule() {
        this.view.RecipeModule.children.forEach(element => {
          element.height = this.nodeHeight[0];
          element.getComponent(RecipeModuleItem_1.default).title.y = this.titlePos[0];
        });
      }
      changeRecipeItem() {
        this.view.RecipeScroll.numItems = this.recipeList.length;
        this.view.RecipeScroll.updateAll();
      }
    };
    __decorate([ property(cc.Prefab) ], UIRecipe.prototype, "recipeModuleItem", void 0);
    UIRecipe = UIRecipe_1 = __decorate([ ccclass ], UIRecipe);
    exports.default = UIRecipe;
    cc._RF.pop();
  }, {
    "../Config/RawMaterial": "RawMaterial",
    "../Config/TableKey": "TableKey",
    "../Game/Item/RecipeItem": "RecipeItem",
    "../Game/Item/RecipeModuleItem": "RecipeModuleItem",
    "../Logic/Game": "Game",
    "../UIFrame/Struct": "Struct",
    "../UIFrame/UIForm": "UIForm",
    "../UIFrame/config/SysDefine": "SysDefine"
  } ],
  UIToast1: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "c3d9dX09jlJsYjxJBe9LSud", "UIToast1");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const CocosHelper_1 = require("../../UIFrame/CocosHelper");
    const ToastMgr_1 = require("../../UIFrame/ToastMgr");
    const UIForm_1 = require("../../UIFrame/UIForm");
    const {ccclass: ccclass, property: property} = cc._decorator;
    let UIToast1 = class UIToast1 extends UIForm_1.UIToast {
      constructor() {
        super(...arguments);
        this.info = null;
        this.bg = null;
      }
      start() {}
      use() {}
      free() {}
      onShow(params) {
        this.info.string = params.info;
        this.scheduleOnce(() => {
          ToastMgr_1.default.close(this, null);
        }, params.time || 1.5);
      }
      onHide() {}
      showEffect() {
        return __awaiter(this, void 0, void 0, function*() {
          this.node.scale = 0;
          this.node.position = cc.v3(0, 0, 0);
          yield CocosHelper_1.default.runTweenSync(this.node, cc.tween().to(.3, {
            scale: 1
          }, cc.easeBackOut()));
        });
      }
      hideEffect() {
        return __awaiter(this, void 0, void 0, function*() {
          yield CocosHelper_1.default.runTweenSync(this.node, cc.tween().by(.3, {
            y: 100
          }, cc.easeBackOut()));
        });
      }
    };
    __decorate([ property(cc.Label) ], UIToast1.prototype, "info", void 0);
    __decorate([ property(cc.Node) ], UIToast1.prototype, "bg", void 0);
    UIToast1 = __decorate([ ccclass ], UIToast1);
    exports.default = UIToast1;
    cc._RF.pop();
  }, {
    "../../UIFrame/CocosHelper": "CocosHelper",
    "../../UIFrame/ToastMgr": "ToastMgr",
    "../../UIFrame/UIForm": "UIForm"
  } ],
  UITop_Auto: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "2e06fOXe1xCHJkwgC0IL4pT", "UITop_Auto");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const {ccclass: ccclass, property: property} = cc._decorator;
    let UITop_Auto = class UITop_Auto extends cc.Component {
      constructor() {
        super(...arguments);
        this.Setting = null;
        this.Coin = null;
        this.Gold = null;
        this.Star = null;
        this.Gift = null;
        this.Backpack = null;
        this.Recipe = null;
        this.Variety = null;
        this.VarietyGame = null;
        this.Shop = null;
      }
    };
    __decorate([ property(cc.Node) ], UITop_Auto.prototype, "Setting", void 0);
    __decorate([ property(cc.Node) ], UITop_Auto.prototype, "Coin", void 0);
    __decorate([ property(cc.Label) ], UITop_Auto.prototype, "Gold", void 0);
    __decorate([ property(cc.Label) ], UITop_Auto.prototype, "Star", void 0);
    __decorate([ property(cc.Node) ], UITop_Auto.prototype, "Gift", void 0);
    __decorate([ property(cc.Node) ], UITop_Auto.prototype, "Backpack", void 0);
    __decorate([ property(cc.Node) ], UITop_Auto.prototype, "Recipe", void 0);
    __decorate([ property(cc.Node) ], UITop_Auto.prototype, "Variety", void 0);
    __decorate([ property(cc.Node) ], UITop_Auto.prototype, "VarietyGame", void 0);
    __decorate([ property(cc.Node) ], UITop_Auto.prototype, "Shop", void 0);
    UITop_Auto = __decorate([ ccclass ], UITop_Auto);
    exports.default = UITop_Auto;
    cc._RF.pop();
  }, {} ],
  UITop: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "cf0d1QZhShJ+pDPfq1sKLBC", "UITop");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const lodash_1 = require("lodash");
    const GlobalData_1 = require("../Config/GlobalData");
    const TableKey_1 = require("../Config/TableKey");
    const RoleMgr_1 = require("../Game/Manager/RoleMgr");
    const CoinFlyToWallet_1 = require("../Game/ani/CoinFlyToWallet");
    const Game_1 = require("../Logic/Game");
    const AdapterMgr_1 = require("../UIFrame/AdapterMgr");
    const UIForm_1 = require("../UIFrame/UIForm");
    const UIBackpack_1 = require("./UIBackpack");
    const UIBuild_1 = require("./UIBuild");
    const UIRecipe_1 = require("./UIRecipe");
    const UIVariety_1 = require("./UIVariety");
    const {ccclass: ccclass, property: property} = cc._decorator;
    let UITop = class UITop extends UIForm_1.UIFixed {
      onShow(data) {
        this.gold;
        this.home = data.home;
        data.callBack && data.callBack(this);
        AdapterMgr_1.default.inst.adapteByType(AdapterMgr_1.AdapterType.FullWidth, this.node);
      }
      clickBackpack() {
        UIBackpack_1.default.open();
      }
      clickRecipe() {
        UIRecipe_1.default.open();
      }
      clickVariety() {
        UIVariety_1.default.open(this);
        this.view.VarietyGame.active = true;
        this.view.Variety.active = false;
        this.view.Shop.active = false;
      }
      clickVarietyGame() {
        this.view.VarietyGame.active = false;
        this.view.Variety.active = true;
        this.view.Shop.active = true;
        UIVariety_1.default.close();
      }
      clickShop() {
        UIBuild_1.default.open(this.home);
      }
      toggleHome(isHidden = false) {
        RoleMgr_1.default.ins.waitSize > 0 && RoleMgr_1.default.ins.firstRole.changeTalk(!isHidden);
      }
      addGold(value) {
        let userData = Game_1.default.dbMgr.query(TableKey_1.TableKey.USER, {
          uid: 1
        });
        userData.gold += value;
        this.gold = userData.gold;
      }
      set gold(value) {
        this.view.Gold.string = value.toString();
        Game_1.default.dbMgr.update(TableKey_1.TableKey.USER, {
          gold: value
        }, {
          uid: GlobalData_1.GlobalData.userId
        });
      }
      get gold() {
        let userData = Game_1.default.dbMgr.query(TableKey_1.TableKey.USER, {
          uid: GlobalData_1.GlobalData.userId
        });
        this.view.Gold.string = userData.gold.toString();
        return userData.gold;
      }
      set star(value) {
        this.view.Star.string = value.toString();
        this.storeData.star = value;
        this.home.storeData = this.storeData;
      }
      get star() {
        this.view.Star.string = this.storeData.star.toString();
        return this.storeData.star;
      }
      get storeData() {
        return lodash_1.cloneDeep(this.home.storeData);
      }
      playGoldAnim(node, gold) {
        const ani = this.node.getComponent(CoinFlyToWallet_1.CoinFlyToWallet);
        ani.startNode = node;
        ani.playAnim(() => {
          this.addGold(gold);
        });
      }
      showCoffe() {
        RoleMgr_1.default.ins.firstRole.getCoffee();
        this.home.leave();
      }
      changeShopIcon(isShow) {
        this.view.Variety.active = isShow;
        this.view.Shop.active = isShow;
      }
    };
    UITop = __decorate([ ccclass ], UITop);
    exports.default = UITop;
    cc._RF.pop();
  }, {
    "../Config/GlobalData": "GlobalData",
    "../Config/TableKey": "TableKey",
    "../Game/Manager/RoleMgr": "RoleMgr",
    "../Game/ani/CoinFlyToWallet": "CoinFlyToWallet",
    "../Logic/Game": "Game",
    "../UIFrame/AdapterMgr": "AdapterMgr",
    "../UIFrame/UIForm": "UIForm",
    "./UIBackpack": "UIBackpack",
    "./UIBuild": "UIBuild",
    "./UIRecipe": "UIRecipe",
    "./UIVariety": "UIVariety",
    lodash: 1
  } ],
  UIVarietyInfo_Auto: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "1e6deSjbYlLqrLbCy0Dzf2b", "UIVarietyInfo_Auto");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const {ccclass: ccclass, property: property} = cc._decorator;
    let UIVarietyInfo_Auto = class UIVarietyInfo_Auto extends cc.Component {
      constructor() {
        super(...arguments);
        this.icon = null;
        this.title = null;
        this.number = null;
        this.infoLabel = null;
        this.coin = null;
      }
    };
    __decorate([ property(cc.Node) ], UIVarietyInfo_Auto.prototype, "icon", void 0);
    __decorate([ property(cc.Node) ], UIVarietyInfo_Auto.prototype, "title", void 0);
    __decorate([ property(cc.Label) ], UIVarietyInfo_Auto.prototype, "number", void 0);
    __decorate([ property(cc.Node) ], UIVarietyInfo_Auto.prototype, "infoLabel", void 0);
    __decorate([ property(cc.Label) ], UIVarietyInfo_Auto.prototype, "coin", void 0);
    UIVarietyInfo_Auto = __decorate([ ccclass ], UIVarietyInfo_Auto);
    exports.default = UIVarietyInfo_Auto;
    cc._RF.pop();
  }, {} ],
  UIVarietyInfo: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "a369fxV8LlPppXmXDGVDdrF", "UIVarietyInfo");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var UIVarietyInfo_1;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const CommonUtils_1 = require("../Common/Utils/CommonUtils");
    const GlobalData_1 = require("../Config/GlobalData");
    const MessageInfo_1 = require("../Config/MessageInfo");
    const RawMaterial_1 = require("../Config/RawMaterial");
    const TableKey_1 = require("../Config/TableKey");
    const Game_1 = require("../Logic/Game");
    const Struct_1 = require("../UIFrame/Struct");
    const UIForm_1 = require("../UIFrame/UIForm");
    const SysDefine_1 = require("../UIFrame/config/SysDefine");
    const UIToast1_1 = require("./toast/UIToast1");
    const {ccclass: ccclass, property: property} = cc._decorator;
    let UIVarietyInfo = UIVarietyInfo_1 = class UIVarietyInfo extends UIForm_1.UIWindow {
      constructor() {
        super(...arguments);
        this.modalType = new Struct_1.ModalType(SysDefine_1.ModalOpacity.OpacityHigh, true);
        this._data = null;
        this.eventNode = null;
        this.top = null;
      }
      start() {
        console.log("UIVarietyInfo start...");
      }
      onShow(param) {
        this._data = param.eventNode["data"];
        this.eventNode = param.eventNode;
        this.top = param.top;
      }
      onEnable() {
        this.initUi();
      }
      onDisable() {}
      initUi() {
        let tempPath = this._data["resPath"] ? this._data["resPath"] : GlobalData_1.GlobalData.rawPath;
        CommonUtils_1.CommonUtils.setItemSpriteFrame(this.view.icon.getComponent(cc.Sprite), `${tempPath}${this._data["ID"]}`);
        this.view.title.getComponent(cc.Label).string = this._data["name"];
        this.view.infoLabel.getComponent(cc.Label).string = this._data["intro"];
        this.view.coin.string = this._data["price"];
      }
      clickClose() {
        UIVarietyInfo_1.close();
      }
      clickBuy() {
        let tempCoin = Game_1.default.dbMgr.query(TableKey_1.TableKey.USER, {
          uid: GlobalData_1.GlobalData.userId
        }).gold;
        if (tempCoin < this._data["price"]) {
          UIToast1_1.default.open({
            info: MessageInfo_1.MessageInfo.buyFail
          });
          return;
        }
        tempCoin -= this._data["price"];
        this.top.gold = tempCoin;
        Game_1.default.dbMgr.update(TableKey_1.TableKey.USER, {
          gold: tempCoin
        }, {
          uid: GlobalData_1.GlobalData.userId
        });
        UIToast1_1.default.open({
          info: MessageInfo_1.MessageInfo.buySucc
        });
        UIVarietyInfo_1.close();
        switch (this._data["type"]) {
         case "item_raw":
          this.unclockRaw();
          break;

         case 1:
          this.unclockTable();
          break;

         case 2:
         case 6:
          this.unclockOrnaments();
          break;

         default:
          console.log("\u6682\u65f6\u672a\u5b9a\u4e49\u7684\u8d2d\u4e70\u7c7b\u578b");
        }
      }
      unclockRaw() {
        this.eventNode["data"] = null;
        let tempData = Game_1.default.dbMgr.query(TableKey_1.TableKey.MATE, {
          ID: this._data.ID
        });
        if (!tempData) {
          tempData = RawMaterial_1.RawMaterial.find(item => item.ID === this._data.ID);
          Game_1.default.dbMgr.insert2(TableKey_1.TableKey.MATE, tempData);
        }
        Game_1.default.dbMgr.update(TableKey_1.TableKey.MATE, tempData, {
          ID: this._data.ID
        });
        console.log(" \u83b7\u53d6\u539f\u6599 ", Game_1.default.dbMgr.query(TableKey_1.TableKey.MATE));
      }
      unclockTable() {
        this.eventNode.active = false;
        let tempData = Game_1.default.dbMgr.query(TableKey_1.TableKey.TABLE, {
          ID: this._data.ID
        });
        if (!tempData) {
          tempData = RawMaterial_1.TableList.find(item => item.ID === this._data.ID);
          Game_1.default.dbMgr.insert2(TableKey_1.TableKey.TABLE, tempData);
        }
        tempData["count"] = parseInt(tempData["count"]) + 1;
        Game_1.default.dbMgr.update(TableKey_1.TableKey.TABLE, tempData, {
          ID: this._data.ID
        });
        console.log(" \u83b7\u53d6\u684c\u5b50\u6570\u636e ", Game_1.default.dbMgr.query(TableKey_1.TableKey.TABLE));
      }
      unclockOrnaments() {
        this.eventNode.active = false;
        let tempData = Game_1.default.dbMgr.query(TableKey_1.TableKey.ORNAMENTS, {
          ID: this._data.ID
        });
        if (!tempData) {
          tempData = RawMaterial_1.OrnamentsList.find(item => item.ID === this._data.ID);
          Game_1.default.dbMgr.insert2(TableKey_1.TableKey.ORNAMENTS, tempData);
        }
        tempData["count"] = parseInt(tempData["count"]) + 1;
        Game_1.default.dbMgr.update(TableKey_1.TableKey.ORNAMENTS, tempData, {
          ID: this._data.ID
        });
        console.log(" \u83b7\u53d6\u88c5\u9970\u6570\u636e ", Game_1.default.dbMgr.query(TableKey_1.TableKey.ORNAMENTS));
      }
    };
    UIVarietyInfo = UIVarietyInfo_1 = __decorate([ ccclass ], UIVarietyInfo);
    exports.default = UIVarietyInfo;
    cc._RF.pop();
  }, {
    "../Common/Utils/CommonUtils": "CommonUtils",
    "../Config/GlobalData": "GlobalData",
    "../Config/MessageInfo": "MessageInfo",
    "../Config/RawMaterial": "RawMaterial",
    "../Config/TableKey": "TableKey",
    "../Logic/Game": "Game",
    "../UIFrame/Struct": "Struct",
    "../UIFrame/UIForm": "UIForm",
    "../UIFrame/config/SysDefine": "SysDefine",
    "./toast/UIToast1": "UIToast1"
  } ],
  UIVariety_Auto: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "5c559a7gAlHJYu6dNe1nmaP", "UIVariety_Auto");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const {ccclass: ccclass, property: property} = cc._decorator;
    let UIVariety_Auto = class UIVariety_Auto extends cc.Component {
      constructor() {
        super(...arguments);
        this.raws = null;
        this.raw1 = null;
        this.raw2 = null;
        this.goods = null;
        this.goods1 = null;
        this.goods2 = null;
        this.goods3 = null;
        this.goods4 = null;
      }
    };
    __decorate([ property(cc.Node) ], UIVariety_Auto.prototype, "raws", void 0);
    __decorate([ property(cc.Node) ], UIVariety_Auto.prototype, "raw1", void 0);
    __decorate([ property(cc.Node) ], UIVariety_Auto.prototype, "raw2", void 0);
    __decorate([ property(cc.Node) ], UIVariety_Auto.prototype, "goods", void 0);
    __decorate([ property(cc.Node) ], UIVariety_Auto.prototype, "goods1", void 0);
    __decorate([ property(cc.Node) ], UIVariety_Auto.prototype, "goods2", void 0);
    __decorate([ property(cc.Node) ], UIVariety_Auto.prototype, "goods3", void 0);
    __decorate([ property(cc.Node) ], UIVariety_Auto.prototype, "goods4", void 0);
    UIVariety_Auto = __decorate([ ccclass ], UIVariety_Auto);
    exports.default = UIVariety_Auto;
    cc._RF.pop();
  }, {} ],
  UIVariety: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "348ceBfzNVH3L4Tt0vQaaIs", "UIVariety");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var UIVariety_1;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const CommonUtils_1 = require("../Common/Utils/CommonUtils");
    const MatchUtils_1 = require("../Common/Utils/MatchUtils");
    const GlobalData_1 = require("../Config/GlobalData");
    const MessageInfo_1 = require("../Config/MessageInfo");
    const RawMaterial_1 = require("../Config/RawMaterial");
    const TableKey_1 = require("../Config/TableKey");
    const Game_1 = require("../Logic/Game");
    const AdapterMgr_1 = require("../UIFrame/AdapterMgr");
    const Struct_1 = require("../UIFrame/Struct");
    const UIForm_1 = require("../UIFrame/UIForm");
    const SysDefine_1 = require("../UIFrame/config/SysDefine");
    const UIVarietyInfo_1 = require("./UIVarietyInfo");
    const UIToast1_1 = require("./toast/UIToast1");
    const {ccclass: ccclass, property: property} = cc._decorator;
    let UIVariety = UIVariety_1 = class UIVariety extends UIForm_1.UIDrawer {
      constructor() {
        super(...arguments);
        this.modalType = new Struct_1.ModalType(SysDefine_1.ModalOpacity.OpacityHigh, false);
        this.clockRawArr = [];
        this.updateTimeArr = [ 12, 0 ];
        this.isDay = false;
        this.isUpdateVariety = false;
      }
      start() {
        console.log("UIVariety start...");
      }
      onEnable() {
        AdapterMgr_1.default.inst.adapteByType(AdapterMgr_1.AdapterType.FullWidth, this.node);
        this.initData();
        this.initUI();
        this.registerEvent();
      }
      onDisable() {
        this.unRegisterEvent();
      }
      registerEvent() {
        this.view.raws.children.forEach(element => {
          element.on(cc.Node.EventType.TOUCH_END, this.clickRecipeInfo, this);
        });
        this.view.goods.children.forEach(element => {
          element.on(cc.Node.EventType.TOUCH_END, this.clickRecipeInfo, this);
        });
      }
      unRegisterEvent() {
        this.view.raws.children.forEach(element => {
          element.off(cc.Node.EventType.TOUCH_END, this.clickRecipeInfo, this);
        });
        this.view.goods.children.forEach(element => {
          element.off(cc.Node.EventType.TOUCH_END, this.clickRecipeInfo, this);
        });
      }
      onShow(top) {
        this.top = top;
      }
      initData() {
        this.compactTime();
        this.recordClockRaw();
      }
      compactTime() {
        this.userData = Game_1.default.dbMgr.query(TableKey_1.TableKey.USER, {
          uid: 1
        });
        if (!this.userData["loginTime"] || 0 == this.userData["loginTime"]) {
          this.userData["loginTime"] = new Date();
          this.userData["isUpdateVarietyCount"] = -1;
        }
        this.compareTime(new Date(Date.parse(this.userData["loginTime"])));
        Game_1.default.dbMgr.update(TableKey_1.TableKey.USER, {
          loginTime: this.userData["loginTime"]
        }, {
          uid: GlobalData_1.GlobalData.userId
        });
      }
      isSameDay(now, previousDay) {
        const midnight = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0, 0);
        const previousMidnight = new Date(previousDay.getFullYear(), previousDay.getMonth(), previousDay.getDate(), 0, 0, 0, 0);
        return midnight.getTime() === previousMidnight.getTime();
      }
      compareTime(curTime) {
        this.isDay = this.isSameDay(new Date(), curTime);
        this.isDay || (this.userData["isUpdateVarietyCount"] = -1);
        const tempTime = new Date();
        for (let i = 0; i < this.updateTimeArr.length; i++) {
          tempTime.setHours(this.updateTimeArr[i], 0, 0, 0);
          if (curTime >= tempTime && (this.userData["isUpdateVarietyCount"] > i || -1 == this.userData["isUpdateVarietyCount"])) {
            this.isUpdateVariety = true;
            this.userData["isUpdateVarietyCount"] = i;
            Game_1.default.dbMgr.update(TableKey_1.TableKey.USER, {
              isUpdateVarietyCount: this.userData["isUpdateVarietyCount"]
            }, {
              uid: 1
            });
            return;
          }
        }
        this.isUpdateVariety = false;
      }
      recordClockRaw() {
        this.clockRawArr = [];
        let unclockRaw = Game_1.default.dbMgr.query(TableKey_1.TableKey.MATE);
        let tempData;
        for (let i = 0; i < RawMaterial_1.RawMaterial.length; i++) {
          tempData = unclockRaw.find(item => item.ID === RawMaterial_1.RawMaterial[i].ID);
          tempData || this.clockRawArr.push(RawMaterial_1.RawMaterial[i]);
        }
      }
      initUI() {
        let tempNum = 0;
        let tempType = 0;
        let tempNode;
        let tempData;
        for (let i = 0; i < this.view.goods.children.length; i++) {
          tempNode = this.view.goods.children[i];
          tempType = MatchUtils_1.MathUtils.getRandomInt(0, 2);
          tempNum = 0 == tempType ? MatchUtils_1.MathUtils.getRandomInt(0, RawMaterial_1.TableList.length) : MatchUtils_1.MathUtils.getRandomInt(0, RawMaterial_1.OrnamentsList.length);
          tempData = 0 == tempType ? RawMaterial_1.TableList[tempNum] : RawMaterial_1.OrnamentsList[tempNum];
          CommonUtils_1.CommonUtils.setItemSpriteFrame(tempNode.getComponent(cc.Sprite), `${tempData["resPath"]}${tempData["ID"]}`);
          tempNode["data"] = tempData;
          tempNode.active = true;
        }
        for (let i = 0; i < this.view.raws.children.length; i++) {
          if (this.clockRawArr.length == i || 0 == this.clockRawArr.length) break;
          tempNode = this.view.raws.children[i];
          tempNum = MatchUtils_1.MathUtils.getRandomInt(0, this.clockRawArr.length);
          tempData = this.clockRawArr[tempNum];
          tempNode["data"] = tempData;
          tempNode.active = true;
        }
      }
      clickClose() {
        UIVariety_1.close();
      }
      clickRecipeInfo(event) {
        if (!event.target["data"]) {
          UIToast1_1.default.open({
            info: MessageInfo_1.MessageInfo.noRaw
          });
          return;
        }
        let param = {
          eventNode: event.target,
          top: this.top
        };
        UIVarietyInfo_1.default.open(param);
      }
    };
    UIVariety = UIVariety_1 = __decorate([ ccclass ], UIVariety);
    exports.default = UIVariety;
    cc._RF.pop();
  }, {
    "../Common/Utils/CommonUtils": "CommonUtils",
    "../Common/Utils/MatchUtils": "MatchUtils",
    "../Config/GlobalData": "GlobalData",
    "../Config/MessageInfo": "MessageInfo",
    "../Config/RawMaterial": "RawMaterial",
    "../Config/TableKey": "TableKey",
    "../Logic/Game": "Game",
    "../UIFrame/AdapterMgr": "AdapterMgr",
    "../UIFrame/Struct": "Struct",
    "../UIFrame/UIForm": "UIForm",
    "../UIFrame/config/SysDefine": "SysDefine",
    "./UIVarietyInfo": "UIVarietyInfo",
    "./toast/UIToast1": "UIToast1"
  } ],
  UIWorkDesk_Auto: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "56ee2Nm2yJEJK0ns2XwnyMc", "UIWorkDesk_Auto");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    const List_1 = require("./../Common/Components/List");
    const {ccclass: ccclass, property: property} = cc._decorator;
    let UIWorkDesk_Auto = class UIWorkDesk_Auto extends cc.Component {
      constructor() {
        super(...arguments);
        this.Role = null;
        this.Menu = null;
        this.MenuList = null;
        this.MenuTitle = null;
        this.Scroll = null;
        this.Content = null;
        this.Reform = null;
        this.Ok = null;
        this.CoffeePos = null;
        this.Close = null;
      }
    };
    __decorate([ property(cc.Sprite) ], UIWorkDesk_Auto.prototype, "Role", void 0);
    __decorate([ property(cc.Node) ], UIWorkDesk_Auto.prototype, "Menu", void 0);
    __decorate([ property(cc.Node) ], UIWorkDesk_Auto.prototype, "MenuList", void 0);
    __decorate([ property(cc.Label) ], UIWorkDesk_Auto.prototype, "MenuTitle", void 0);
    __decorate([ property(List_1.default) ], UIWorkDesk_Auto.prototype, "Scroll", void 0);
    __decorate([ property(cc.Node) ], UIWorkDesk_Auto.prototype, "Content", void 0);
    __decorate([ property(cc.Node) ], UIWorkDesk_Auto.prototype, "Reform", void 0);
    __decorate([ property(cc.Node) ], UIWorkDesk_Auto.prototype, "Ok", void 0);
    __decorate([ property(cc.Node) ], UIWorkDesk_Auto.prototype, "CoffeePos", void 0);
    __decorate([ property(cc.Node) ], UIWorkDesk_Auto.prototype, "Close", void 0);
    UIWorkDesk_Auto = __decorate([ ccclass ], UIWorkDesk_Auto);
    exports.default = UIWorkDesk_Auto;
    cc._RF.pop();
  }, {
    "./../Common/Components/List": "List"
  } ],
  UIWorkDesk: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "b0b79n3Ta5Bz7qDiGc5ZdnV", "UIWorkDesk");
    "use strict";
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var UIWorkDesk_1;
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.makeState = exports.DragType = void 0;
    const lodash_1 = require("lodash");
    const BroadcastCenter_1 = require("../Common/BroadCasts/BroadcastCenter");
    const KawaseBlur_1 = require("../Common/Components/KawaseBlur");
    const Printer_1 = require("../Common/Components/Printer");
    const GPDrag_1 = require("../Common/GPDrag");
    const CommonUtils_1 = require("../Common/Utils/CommonUtils");
    const utils_1 = require("../Common/Utils/utils");
    const GlobalData_1 = require("../Config/GlobalData");
    const MessageInfo_1 = require("../Config/MessageInfo");
    const RawMaterial_1 = require("../Config/RawMaterial");
    const TableKey_1 = require("../Config/TableKey");
    const MessageType_1 = require("../Enum/MessageType");
    const Coffee_1 = require("../Game/Coffee");
    const MenuItem_1 = require("../Game/Item/MenuItem");
    const RawItem_1 = require("../Game/Item/RawItem");
    const RoleMgr_1 = require("../Game/Manager/RoleMgr");
    const Game_1 = require("../Logic/Game");
    const AdapterMgr_1 = require("../UIFrame/AdapterMgr");
    const CocosHelper_1 = require("../UIFrame/CocosHelper");
    const Struct_1 = require("../UIFrame/Struct");
    const UIForm_1 = require("../UIFrame/UIForm");
    const SysDefine_1 = require("../UIFrame/config/SysDefine");
    const UIToast1_1 = require("./toast/UIToast1");
    const {ccclass: ccclass, property: property} = cc._decorator;
    var DragType;
    (function(DragType) {
      DragType[DragType["Raw"] = 0] = "Raw";
      DragType[DragType["Menu"] = 1] = "Menu";
    })(DragType = exports.DragType || (exports.DragType = {}));
    var makeState;
    (function(makeState) {
      makeState[makeState["INIT"] = 0] = "INIT";
      makeState[makeState["ISMAKE"] = 1] = "ISMAKE";
      makeState[makeState["MAKESUCC"] = 2] = "MAKESUCC";
    })(makeState = exports.makeState || (exports.makeState = {}));
    let UIWorkDesk = UIWorkDesk_1 = class UIWorkDesk extends UIForm_1.UIDrawer {
      constructor() {
        super(...arguments);
        this.coffee = null;
        this.menu = null;
        this.talkNode = null;
        this.content = null;
        this.box = null;
        this.roleNode = null;
        this.coffeeNode = null;
        this.menuNode = null;
        this.modalType = new Struct_1.ModalType(SysDefine_1.ModalOpacity.GuassBlur);
        this.dualBlur = true;
        this.menuMaxNum = 6;
        this.dragIndex = -1;
        this.talkPosY = 300;
        this.boxHeight = 51;
        this.maxBoxWidth = 662;
        this.offsetY = 18;
        this.layoutOffsetY = -5.9;
        this.iceId = 2003;
        this.dragItem = null;
        this.dragMenuItem = null;
        this.menuItemArr = [];
        this.dragType = null;
        this.top = null;
        this.defaultTilte = "\u81ea\u7531\u5236\u4f5c";
        this.blurComp = null;
        this.recipeList = null;
        this.makeRecipeList = null;
        this.willMakeRp = null;
        this.makeRecipe = null;
        this.makeState = makeState.INIT;
        this.RawMaterial = [];
        this.tempRestormPos = null;
        this.stopDrag = false;
        this.menuKeyArr = [ "raw1", "raw2", "raw3", "raw4", "raw5", "raw6" ];
      }
      start() {
        console.log("UIBackpack start...");
        this.initBg();
        this.addCoffe();
      }
      initBg() {
        this.tempRestormPos = this.view.Reform.position.clone();
        let spr = this.node.parent.getChildByName("UIModalNode").getComponent(cc.Sprite);
        this.blurComp = this.node.getComponent(KawaseBlur_1.default);
        this.blurComp.sprite = spr;
        this.blurComp.enabled = true;
      }
      addCoffe() {
        this.coffeeNode = cc.instantiate(this.coffee);
        this.coffeeNode.parent = this.view.CoffeePos;
        this.coffeComp.initData(this);
        for (let i = 0; i <= this.menuMaxNum; i++) {
          let menu = cc.instantiate(this.menu);
          if (i < this.menuMaxNum) {
            menu.getComponent(GPDrag_1.GPDrag).enabled = false;
            menu.getComponent(MenuItem_1.default).init(this);
            menu.parent = this.view.MenuList;
            this.view.MenuList.getComponent(cc.Layout).updateLayout();
          } else {
            this.menuNode = menu;
            menu.getComponent(MenuItem_1.default).enabled = false;
            this.menuComp.succeedCheck = this.succkCheck.bind(this);
            this.menuComp.succeedCallback = this.succeedCallback.bind(this);
            this.menuNode.children[0].active = true;
            this.menuNode.parent = this.node;
            this.menuNode.active = false;
          }
        }
      }
      close() {
        this.content.parent = this.box;
        this.changeRoleState(false);
        this.top.toggleHome();
        this.top.changeShopIcon(true);
        UIWorkDesk_1.close();
      }
      changeRoleState(isShow) {
        return __awaiter(this, void 0, void 0, function*() {
          const role = RoleMgr_1.default.ins.firstRole;
          if (isShow && role) {
            let spf = yield CocosHelper_1.default.loadResSync(GlobalData_1.GlobalData.roleImgPath + role.roleData.ID, cc.SpriteFrame);
            this.view.Role.spriteFrame = spf;
          }
          this.roleNode.active = isShow;
        });
      }
      onShow(top) {
        this.top = top;
        this.top.changeShopIcon(false);
        this.RawMaterial = Game_1.default.dbMgr.query(TableKey_1.TableKey.MATE);
        AdapterMgr_1.default.inst.adapteByType(AdapterMgr_1.AdapterType.FullWidth, this.node);
        this.makeState !== makeState.ISMAKE && this.clearMenu();
        this.recipeList = lodash_1.flatten(Game_1.default.dbMgr.query(TableKey_1.TableKey.RECIPE));
        this.makeRecipeList = this.queryMakeRep();
        0 === RoleMgr_1.default.ins.waitSize || RoleMgr_1.default.ins.firstRole.moveing || this.startTalk();
        BroadcastCenter_1.BroadcastCenter.buildingState.on(data => {
          data.state === MessageType_1.MessageType.RoleStand && 1 === data.id && this.node && this.node.active && this.startTalk();
        }, this);
      }
      startTalk() {
        const role = RoleMgr_1.default.ins.firstRole;
        this.changeRoleState(true);
        const talkArr = RawMaterial_1.RoleBuyTalk[role.roleData.ID];
        let idx = -1 === role.talkIdx ? CommonUtils_1.CommonUtils.randomIntClosedRange(0, talkArr.length - 1) : role.talkIdx;
        role.talkIdx = idx;
        let talk = talkArr[idx].talk;
        let i = -1 === role.repIdx ? CommonUtils_1.CommonUtils.randomIntClosedRange(0, this.makeRecipeList.length - 1) : role.repIdx;
        role.repIdx = i;
        this.willMakeRp = this.makeRecipeList[i];
        let repName = this.isAddIce(this.willMakeRp);
        talk = talk.replaceAll("%d", repName);
        this.view.MenuTitle.string = repName;
        this.talkContent = talk;
        role && (role.makeRecipe = this.makeRecipe);
      }
      isAddIce(recipe) {
        let repName = lodash_1.cloneDeep(recipe.name);
        recipe.coldDrink && (repName = utils_1.getOddsByNum(GlobalData_1.GlobalData.gameData.iceRandom) ? lodash_1.replace(repName, "%s", "\u51b0") : lodash_1.replace(repName, "%s", ""));
        return repName;
      }
      clearMenu() {
        this.coffeeNode && this.coffeComp.init();
        this.dragIndex = -1;
        this.dragMenuItem = null;
        this.dragItem = null;
        this.menuItemArr = [];
        this.view.Reform.active = false;
        this.view.Ok.active = false;
        this.view.Menu.active = true;
        for (let node of this.view.MenuList.children) {
          if (!node.getComponent(MenuItem_1.default).itemData) continue;
          this.makeState !== makeState.ISMAKE && node.getComponent(MenuItem_1.default).rawItem.updateRawCount(1);
          node.getComponent(MenuItem_1.default).itemData = null;
          node.getComponent(MenuItem_1.default).rawItem = null;
          const icon = node.children[0];
          icon.active = false;
        }
        this.makeState = makeState.INIT;
        RoleMgr_1.default.ins.firstRole || (this.view.MenuTitle.string = this.defaultTilte);
      }
      showEffect() {
        return __awaiter(this, void 0, void 0, function*() {
          this.node.scale = 0;
          this.node.position = cc.v3(0, -800);
          yield CocosHelper_1.default.runTweenSync(this.node, cc.tween().by(.3, {
            position: cc.v3(0, 340),
            scale: 1
          }, cc.easeBackOut()));
        });
      }
      hideEffect() {
        return __awaiter(this, void 0, void 0, function*() {
          yield CocosHelper_1.default.runTweenSync(this.node, cc.tween().to(.8, {
            position: cc.v3(0, -800),
            scale: 0
          }, cc.easeBackOut()));
        });
      }
      onAfterShow(params) {
        this.view.Scroll.numItems = this.RawMaterial.length;
        this.view.Scroll.scrollTo(0, 0, .1);
      }
      onListGridRender(item, idx) {
        item.getComponent(RawItem_1.default).initUi(this.RawMaterial[idx], this);
      }
      queryMenu() {
        let isRecipe = false;
        let isIce = false;
        let menuIdArr = lodash_1.map(this.menuItemArr, "ID");
        if (menuIdArr.includes(this.iceId)) {
          isIce = true;
          lodash_1.pull(menuIdArr, this.iceId);
        }
        let myRecipe = null;
        let i = 0;
        for (let recipe of this.recipeList) {
          let menuIdArr1 = lodash_1.flatMap(recipe, (v, k) => {
            if (this.menuKeyArr.includes(k)) return v;
          });
          menuIdArr1 = lodash_1.compact(menuIdArr1);
          let idArr = lodash_1.intersection(menuIdArr, menuIdArr1);
          if (idArr.length === menuIdArr.length && idArr.length === menuIdArr1.length) {
            myRecipe = recipe;
            isIce ? true === myRecipe.coldDrink && (isRecipe = true) : isRecipe = true;
          }
          i++;
        }
        return {
          isRecipe: isRecipe,
          myRecipe: myRecipe,
          isIce: isIce
        };
      }
      queryMakeRep() {
        let mateIDArr = lodash_1.map(this.RawMaterial, "ID");
        let repArr = lodash_1.cloneDeep(this.recipeList);
        let pullArr = [];
        for (let recipe of repArr) {
          let repIdArr = lodash_1.flatMap(recipe, (v, k) => {
            if (this.menuKeyArr.includes(k)) return v;
          });
          repIdArr = lodash_1.compact(repIdArr);
          let idArr = lodash_1.difference(repIdArr, mateIDArr);
          idArr.length && pullArr.push(recipe);
        }
        lodash_1.pullAllWith(repArr, pullArr, lodash_1.isEqual);
        return repArr;
      }
      giveCoffer() {
        this.makeState = makeState.MAKESUCC;
        this.talkContent = "";
        RoleMgr_1.default.ins.firstRole && this.top.showCoffe();
        this.changeRoleState(false);
        this.clearMenu();
        RoleMgr_1.default.ins.firstRole && this.scheduleOnce(() => {
          this.startTalk();
        }, .5);
      }
      clickMake() {
        return __awaiter(this, void 0, void 0, function*() {
          if (0 === this.menuItemArr.length) {
            UIToast1_1.default.open({
              info: MessageInfo_1.MessageInfo.rawInfo
            });
            return;
          }
          {
            let checkRecipe = this.queryMenu();
            if (!checkRecipe.isRecipe) {
              UIToast1_1.default.open({
                info: MessageInfo_1.MessageInfo.checkMenuErrr
              });
              this.clearMenu();
              return;
            }
            this.makeRecipe = checkRecipe.myRecipe;
            RoleMgr_1.default.ins.firstRole && (RoleMgr_1.default.ins.firstRole.makeRecipe = this.makeRecipe);
          }
          Game_1.default.dbMgr.update(TableKey_1.TableKey.RECIPE, {
            unlock: "unlock"
          }, {
            ID: this.makeRecipe.ID
          });
          this.makeState = makeState.ISMAKE;
          this.coffeeNode.active = true;
          this.coffeComp.changeCoffer(this.makeRecipe);
          yield CocosHelper_1.default.runTweenSync(this.coffeeNode, cc.tween().to(.5, {
            position: cc.v3(0, 0),
            angle: 0
          }));
          this.coffeComp.runTopUp();
        });
      }
      get coffeComp() {
        return this.coffeeNode.getComponent(Coffee_1.default);
      }
      dragNode(e, item, type) {
        const rep = lodash_1.find(this.menuItemArr, {
          ID: item.itemData.ID
        });
        if (this.makeState !== makeState.INIT || !item.itemData || item.itemData.count < 1 || rep && type === DragType.Raw) {
          this.stopDrag = true;
          return;
        }
        this.dragType = type;
        type == DragType.Raw ? this.dragItem = item : this.dragMenuItem = item;
        this.view.Scroll.node.getComponent(cc.ScrollView).enabled = false;
        this.menuNode.setContentSize(cc.size(item.node.width, item.node.height));
        this.menuNode.children[0].getComponent(cc.Sprite).spriteFrame = item.icon.spriteFrame;
        const pos = this.node.convertToNodeSpaceAR(e.getLocation());
        this.menuNode.position = cc.v3(pos.x, pos.y);
        this.menuNode.active = true;
        e.target = this.menuNode;
        e.currentTarget = this.menuNode;
        this.dragIndex = this.RawMaterial.indexOf(item.itemData);
        this.menuComp.OnDragStart(e);
      }
      dragMove(e) {
        if (!this.menuNode || this.stopDrag) return;
        e.target = this.menuNode;
        e.currentTarget = this.menuNode;
        this.menuComp.OnDragMove(e);
      }
      dragEnd(e) {
        if (!this.menuNode) {
          this.stopDrag = false;
          return;
        }
        e.target = this.menuNode;
        e.currentTarget = this.menuNode;
        this.menuComp.OnDragEnd(e);
      }
      succkCheck() {
        if (this.stopDrag) {
          debugger;
          this.stopDrag = false;
          return false;
        }
        let box = this.view.MenuList.getBoundingBoxToWorld();
        this.dragType == DragType.Menu && (box = this.view.Content.getBoundingBoxToWorld());
        let isIntersecting = cc.Intersection.rectRect(this.menuNode.getBoundingBoxToWorld(), box);
        this.queryNullMenu() || this.dragType != DragType.Raw || (isIntersecting = false);
        isIntersecting || ((this.menuComp.backHomeType = GPDrag_1.DragBackHomeType.Tween) ? this.scheduleOnce(this.initDragData, this.menuComp.backTweenTime) : this.initDragData());
        return isIntersecting;
      }
      succeedCallback() {
        const itemNode = this.queryNullMenu();
        if (this.dragType == DragType.Raw) {
          if (!itemNode || !this.dragItem) return;
          const icon = itemNode.children[0];
          this.dragItem.updateRawCount(-1);
          icon.getComponent(cc.Sprite).spriteFrame = this.dragItem.icon.spriteFrame;
          itemNode.getComponent(MenuItem_1.default).itemData = this.dragItem.itemData;
          itemNode.getComponent(MenuItem_1.default).rawItem = this.dragItem;
          icon.active = true;
          this.menuItemArr.push(this.dragItem.itemData);
        } else {
          let comp = this.queryBackItem(this.dragMenuItem.itemData);
          comp && comp.updateRawCount(1);
          lodash_1.pull(this.menuItemArr, this.dragMenuItem.itemData);
          console.log(this.menuItemArr, this.dragMenuItem.itemData);
          this.dragMenuItem.icon.node.active = false;
          this.dragMenuItem.itemData = null;
        }
        this.initDragData();
      }
      queryNullMenu() {
        for (let node of this.view.MenuList.children) {
          const icon = node.children[0];
          if (!icon.active) return node;
        }
      }
      queryBackItem(itemData) {
        let comp = lodash_1.find(this.view.Content.children, v => {
          if (v.getComponent(RawItem_1.default).itemData.ID == itemData.ID) return v;
        });
        return comp.getComponent(RawItem_1.default);
      }
      get menuComp() {
        return this.menuNode.getComponent(GPDrag_1.GPDrag);
      }
      initDragData() {
        this.menuNode.active = false;
        this.dragIndex = -1;
        this.view.Scroll.node.getComponent(cc.ScrollView).enabled = true;
      }
      set talkContent(str) {
        console.log(this);
        const pos = this.talkNode.position;
        const layout = this.talkNode.getComponent(cc.Layout);
        layout.spacingY = this.layoutOffsetY;
        layout.updateLayout();
        this.talkNode.position = cc.v3(pos.x, this.talkPosY, pos.z);
        let col = new cc.Color(255, 255, 255, 255);
        cc.Color.fromHEX(col, "#FEF3DE");
        this.content.color = col;
        this.content.getComponent(cc.Label).overflow = cc.Label.Overflow.RESIZE_HEIGHT;
        this.content.parent = this.box;
        this.content.width = this.maxBoxWidth;
        this.content.getComponent(cc.Label).string = str;
        this.content.getComponent(cc.Label)["_forceUpdateRenderData"]();
        if (this.content.height < this.boxHeight) this.content.getComponent(cc.Label).overflow = cc.Label.Overflow.NONE; else {
          let num = Math.floor(this.content.height / this.boxHeight);
          layout.spacingY = (num + 1) * this.layoutOffsetY + num + 1;
          layout.updateLayout();
          this.talkNode.position = cc.v3(pos.x, this.talkPosY + num * this.offsetY, pos.z);
        }
        this.scheduleOnce(() => {
          const pos = this.content.convertToWorldSpaceAR(cc.v2(0));
          this.content.parent = this.node;
          this.content.position = cc.v3(this.node.convertToNodeSpaceAR(pos));
          cc.Color.fromHEX(col, "#000000");
          this.content.color = col;
          this.content.getComponent(Printer_1.Priter).showLabelPrinter(str);
        }, .3);
      }
    };
    __decorate([ property(cc.Prefab) ], UIWorkDesk.prototype, "coffee", void 0);
    __decorate([ property(cc.Prefab) ], UIWorkDesk.prototype, "menu", void 0);
    __decorate([ property(cc.Node) ], UIWorkDesk.prototype, "talkNode", void 0);
    __decorate([ property(cc.Node) ], UIWorkDesk.prototype, "content", void 0);
    __decorate([ property(cc.Node) ], UIWorkDesk.prototype, "box", void 0);
    __decorate([ property(cc.Node) ], UIWorkDesk.prototype, "roleNode", void 0);
    UIWorkDesk = UIWorkDesk_1 = __decorate([ ccclass ], UIWorkDesk);
    exports.default = UIWorkDesk;
    cc._RF.pop();
  }, {
    "../Common/BroadCasts/BroadcastCenter": "BroadcastCenter",
    "../Common/Components/KawaseBlur": "KawaseBlur",
    "../Common/Components/Printer": "Printer",
    "../Common/GPDrag": "GPDrag",
    "../Common/Utils/CommonUtils": "CommonUtils",
    "../Common/Utils/utils": "utils",
    "../Config/GlobalData": "GlobalData",
    "../Config/MessageInfo": "MessageInfo",
    "../Config/RawMaterial": "RawMaterial",
    "../Config/TableKey": "TableKey",
    "../Enum/MessageType": "MessageType",
    "../Game/Coffee": "Coffee",
    "../Game/Item/MenuItem": "MenuItem",
    "../Game/Item/RawItem": "RawItem",
    "../Game/Manager/RoleMgr": "RoleMgr",
    "../Logic/Game": "Game",
    "../UIFrame/AdapterMgr": "AdapterMgr",
    "../UIFrame/CocosHelper": "CocosHelper",
    "../UIFrame/Struct": "Struct",
    "../UIFrame/UIForm": "UIForm",
    "../UIFrame/config/SysDefine": "SysDefine",
    "./toast/UIToast1": "UIToast1",
    lodash: 1
  } ],
  ViewGroupNesting_2x: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "fbbc2YD7iFPfbCE9Qs6WlQb", "ViewGroupNesting_2x");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
    var ViewGroupNesting_2x = function(_super) {
      __extends(ViewGroupNesting_2x, _super);
      function ViewGroupNesting_2x() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.events = [];
        return _this;
      }
      ViewGroupNesting_2x.prototype.onLoad = function() {
        this.node.on(cc.Node.EventType.TOUCH_START, this.onTouchHandle, this, true);
        this.node.on(cc.Node.EventType.TOUCH_MOVE, this.onTouchHandle, this, true);
        this.node.on(cc.Node.EventType.TOUCH_END, this.onTouchHandle, this, true);
        this.node.on(cc.Node.EventType.TOUCH_CANCEL, this.onTouchHandle, this, true);
      };
      ViewGroupNesting_2x.prototype.onTouchHandle = function(event) {
        if (event.sham || event.simulate || event.target === this.node) return;
        var cancelEvent = new cc.Event.EventTouch(event.getTouches(), event.bubbles);
        cancelEvent.type = event.type;
        cancelEvent.touch = event.touch;
        cancelEvent.sham = true;
        this.events.push(cancelEvent);
      };
      ViewGroupNesting_2x.prototype.update = function() {
        if (0 === this.events.length) return;
        for (var index = 0; index < this.events.length; index++) this.node.dispatchEvent(this.events[index]);
        this.events.length = 0;
      };
      ViewGroupNesting_2x = __decorate([ ccclass ], ViewGroupNesting_2x);
      return ViewGroupNesting_2x;
    }(cc.Component);
    exports.default = ViewGroupNesting_2x;
    cc._RF.pop();
  }, {} ],
  WindowMgr: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "3a04aa299JD1rqA2T4NCR4W", "WindowMgr");
    "use strict";
    var __awaiter = this && this.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = this && this.__generator || function(thisArg, body) {
      var _ = {
        label: 0,
        sent: function() {
          if (1 & t[0]) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      }, f, y, t, g;
      return g = {
        next: verb(0),
        throw: verb(1),
        return: verb(2)
      }, "function" === typeof Symbol && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([ n, v ]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t = 2 & op[0] ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 
          0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          (y = 0, t) && (op = [ 2 & op[0], t.value ]);
          switch (op[0]) {
           case 0:
           case 1:
            t = op;
            break;

           case 4:
            _.label++;
            return {
              value: op[1],
              done: false
            };

           case 5:
            _.label++;
            y = op[1];
            op = [ 0 ];
            continue;

           case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;

           default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (6 === op[0] || 2 === op[0])) {
              _ = 0;
              continue;
            }
            if (3 === op[0] && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (6 === op[0] && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            t[2] && _.ops.pop();
            _.trys.pop();
            continue;
          }
          op = body.call(thisArg, _);
        } catch (e) {
          op = [ 6, e ];
          y = 0;
        } finally {
          f = t = 0;
        }
        if (5 & op[0]) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var PriorityQueue_1 = require("../Common/Utils/PriorityQueue");
    var PriorityStack_1 = require("../Common/Utils/PriorityStack");
    var SysDefine_1 = require("./config/SysDefine");
    var Struct_1 = require("./Struct");
    var UIManager_1 = require("./UIManager");
    var WindowMgr = function() {
      function WindowMgr() {
        this._showingList = new PriorityStack_1.default(function(a, b) {
          return a.prefabUrl === b.prefabUrl;
        });
        this._waitingList = new PriorityQueue_1.default();
      }
      Object.defineProperty(WindowMgr.prototype, "currWindow", {
        get: function() {
          return this._currWindow;
        },
        enumerable: false,
        configurable: true
      });
      WindowMgr.prototype.getWindows = function() {
        return this._showingList.getElements();
      };
      WindowMgr.prototype.open = function(form, params, formData) {
        return __awaiter(this, void 0, void 0, function() {
          var prefabPath;
          return __generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              form = Struct_1.GetForm(form, SysDefine_1.FormType.Window);
              prefabPath = form.prefabUrl;
              formData = this._formatFormData(formData);
              if (!(this._showingList.size <= 0 || !formData.showWait && formData.priority >= this._showingList.getTopEPriority())) return [ 3, 2 ];
              this._showingList.push(form, formData.priority);
              this._currWindow = this._showingList.getTopElement();
              return [ 4, UIManager_1.default.getInstance().openForm(form, params, formData) ];

             case 1:
              return [ 2, _a.sent() ];

             case 2:
              this._waitingList.enqueue({
                form: form,
                params: params,
                formData: formData
              });
              return [ 4, UIManager_1.default.getInstance().loadUIForm(prefabPath) ];

             case 3:
              return [ 2, _a.sent() ];
            }
          });
        });
      };
      WindowMgr.prototype.close = function(form, params, formData) {
        return __awaiter(this, void 0, void 0, function() {
          var result, windowData;
          return __generator(this, function(_a) {
            switch (_a.label) {
             case 0:
              form = Struct_1.GetForm(form, SysDefine_1.FormType.Window);
              result = this._showingList.remove(form);
              if (!result) return [ 2, false ];
              return [ 4, UIManager_1.default.getInstance().closeForm(form, params, formData) ];

             case 1:
              _a.sent();
              if (this._showingList.size <= 0 && this._waitingList.size > 0) {
                windowData = this._waitingList.dequeue();
                this.open(windowData.form, windowData.params, windowData.formData);
              }
              return [ 2, true ];
            }
          });
        });
      };
      WindowMgr.prototype.closeAll = function() {
        return __awaiter(this, void 0, void 0, function() {
          var _i, _a, fid;
          return __generator(this, function(_b) {
            switch (_b.label) {
             case 0:
              this._waitingList.clear();
              _i = 0, _a = this._showingList.getElements();
              _b.label = 1;

             case 1:
              if (!(_i < _a.length)) return [ 3, 4 ];
              fid = _a[_i];
              return [ 4, UIManager_1.default.getInstance().closeForm(fid) ];

             case 2:
              _b.sent();
              _b.label = 3;

             case 3:
              _i++;
              return [ 3, 1 ];

             case 4:
              this._showingList.clear();
              return [ 2, true ];
            }
          });
        });
      };
      WindowMgr.prototype._formatFormData = function(formData) {
        return Object.assign({
          showWait: false,
          priority: Struct_1.EPriority.FIVE
        }, formData);
      };
      return WindowMgr;
    }();
    var WindowData = function() {
      function WindowData() {}
      return WindowData;
    }();
    exports.default = new WindowMgr();
    cc._RF.pop();
  }, {
    "../Common/Utils/PriorityQueue": "PriorityQueue",
    "../Common/Utils/PriorityStack": "PriorityStack",
    "./Struct": "Struct",
    "./UIManager": "UIManager",
    "./config/SysDefine": "SysDefine"
  } ],
  adaptToPositionArr: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "14f1fZz2sRGxKBTQlGUT+sp", "adaptToPositionArr");
    "use strict";
    var __extends = this && this.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || {
          __proto__: []
        } instanceof Array && function(d, b) {
          d.__proto__ = b;
        } || function(d, b) {
          for (var p in b) Object.prototype.hasOwnProperty.call(b, p) && (d[p] = b[p]);
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __decorate = this && this.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if ("object" === typeof Reflect && "function" === typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc); else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _a = cc._decorator, ccclass = _a.ccclass, property = _a.property;
    var adaptToPositionArr = function(_super) {
      __extends(adaptToPositionArr, _super);
      function adaptToPositionArr() {
        var _this = null !== _super && _super.apply(this, arguments) || this;
        _this.totalPosCount = 0;
        _this.xPosCount = 0;
        _this.yPosCount = 0;
        _this.posArr = [];
        _this.countArr = [];
        _this.nodePrefab = null;
        return _this;
      }
      adaptToPositionArr.prototype.onLoad = function() {
        this.yPosCount = Math.ceil(this.totalPosCount / this.xPosCount);
        this.initData(12, 5);
      };
      adaptToPositionArr.prototype.initData = function(totalNum, xNum) {
        this.totalPosCount = totalNum;
        this.xPosCount = xNum;
        this.calculatePos();
      };
      adaptToPositionArr.prototype.calculatePos = function() {
        if (0 == this.totalPosCount) return;
        if (1 == this.totalPosCount) {
          this.posArr.push(cc.v2(0, 0));
          return;
        }
        this.posArr = [];
        this.countArr = [];
        this.calculatePosXY();
        this.creatreTestPrefab();
      };
      adaptToPositionArr.prototype.calculatePosXY = function() {
        var xPos = this.totalPosCount % this.xPosCount == 0 ? this.xPosCount : this.totalPosCount % this.xPosCount;
        var yPos = Math.ceil(this.totalPosCount / this.xPosCount);
        var curNum = 0;
        for (var i = 0; i < yPos; i++) {
          curNum = i == yPos - 1 ? xPos : this.xPosCount;
          this.countArr.push(curNum);
        }
        var tempX = 0;
        var tempY = 0;
        var xTotal = 0;
        for (var i = 0; i < this.countArr.length; i++) {
          tempY = this.node.height / 2 - this.node.height / (this.countArr.length + 1) - this.node.height / (this.countArr.length + 1) * i;
          xTotal = this.countArr[0];
          for (var j = 0; j < this.countArr[i]; j++) {
            tempX = -this.node.width / 2 + this.node.width / (xTotal + 1) + this.node.width / (xTotal + 1) * j;
            this.posArr.push(cc.v2(tempX, tempY));
          }
        }
      };
      adaptToPositionArr.prototype.creatreTestPrefab = function() {
        if (null == this.nodePrefab) return;
        var testP;
        for (var i = 0; i < this.posArr.length; i++) {
          testP = cc.instantiate(this.nodePrefab);
          testP.parent = this.node;
          testP.x = this.posArr[i].x;
          testP.y = this.posArr[i].y;
        }
      };
      __decorate([ property({
        tooltip: "\u603b\u5750\u6807\u6570"
      }) ], adaptToPositionArr.prototype, "totalPosCount", void 0);
      __decorate([ property({
        tooltip: "x\u8f74\u603b\u4e2a\u6570"
      }) ], adaptToPositionArr.prototype, "xPosCount", void 0);
      __decorate([ property(cc.Prefab) ], adaptToPositionArr.prototype, "nodePrefab", void 0);
      adaptToPositionArr = __decorate([ ccclass ], adaptToPositionArr);
      return adaptToPositionArr;
    }(cc.Component);
    exports.default = adaptToPositionArr;
    cc._RF.pop();
  }, {} ],
  aes: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "7c0b2FcU2lAeragv9jHUqhm", "aes");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core")) : "function" === typeof define && define.amd ? define([ "./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX_0 = [];
        var SUB_MIX_1 = [];
        var SUB_MIX_2 = [];
        var SUB_MIX_3 = [];
        var INV_SUB_MIX_0 = [];
        var INV_SUB_MIX_1 = [];
        var INV_SUB_MIX_2 = [];
        var INV_SUB_MIX_3 = [];
        (function() {
          var d = [];
          for (var i = 0; i < 256; i++) d[i] = i < 128 ? i << 1 : i << 1 ^ 283;
          var x = 0;
          var xi = 0;
          for (var i = 0; i < 256; i++) {
            var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
            sx = sx >>> 8 ^ 255 & sx ^ 99;
            SBOX[x] = sx;
            INV_SBOX[sx] = x;
            var x2 = d[x];
            var x4 = d[x2];
            var x8 = d[x4];
            var t = 257 * d[sx] ^ 16843008 * sx;
            SUB_MIX_0[x] = t << 24 | t >>> 8;
            SUB_MIX_1[x] = t << 16 | t >>> 16;
            SUB_MIX_2[x] = t << 8 | t >>> 24;
            SUB_MIX_3[x] = t;
            var t = 16843009 * x8 ^ 65537 * x4 ^ 257 * x2 ^ 16843008 * x;
            INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;
            INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;
            INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;
            INV_SUB_MIX_3[sx] = t;
            if (x) {
              x = x2 ^ d[d[d[x8 ^ x2]]];
              xi ^= d[d[xi]];
            } else x = xi = 1;
          }
        })();
        var RCON = [ 0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54 ];
        var AES = C_algo.AES = BlockCipher.extend({
          _doReset: function _doReset() {
            if (this._nRounds && this._keyPriorReset === this._key) return;
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            var nRounds = this._nRounds = keySize + 6;
            var ksRows = 4 * (nRounds + 1);
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) if (ksRow < keySize) keySchedule[ksRow] = keyWords[ksRow]; else {
              var t = keySchedule[ksRow - 1];
              if (ksRow % keySize) keySize > 6 && ksRow % keySize == 4 && (t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[255 & t]); else {
                t = t << 8 | t >>> 24;
                t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[255 & t];
                t ^= RCON[ksRow / keySize | 0] << 24;
              }
              keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
            }
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              var ksRow = ksRows - invKsRow;
              if (invKsRow % 4) var t = keySchedule[ksRow]; else var t = keySchedule[ksRow - 4];
              invKeySchedule[invKsRow] = invKsRow < 4 || ksRow <= 4 ? t : INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[t >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[255 & t]];
            }
          },
          encryptBlock: function encryptBlock(M, offset) {
            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          },
          decryptBlock: function decryptBlock(M, offset) {
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
          },
          _doCryptBlock: function _doCryptBlock(M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
            var nRounds = this._nRounds;
            var s0 = M[offset] ^ keySchedule[0];
            var s1 = M[offset + 1] ^ keySchedule[1];
            var s2 = M[offset + 2] ^ keySchedule[2];
            var s3 = M[offset + 3] ^ keySchedule[3];
            var ksRow = 4;
            for (var round = 1; round < nRounds; round++) {
              var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[s1 >>> 16 & 255] ^ SUB_MIX_2[s2 >>> 8 & 255] ^ SUB_MIX_3[255 & s3] ^ keySchedule[ksRow++];
              var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[s2 >>> 16 & 255] ^ SUB_MIX_2[s3 >>> 8 & 255] ^ SUB_MIX_3[255 & s0] ^ keySchedule[ksRow++];
              var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[s3 >>> 16 & 255] ^ SUB_MIX_2[s0 >>> 8 & 255] ^ SUB_MIX_3[255 & s1] ^ keySchedule[ksRow++];
              var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[s0 >>> 16 & 255] ^ SUB_MIX_2[s1 >>> 8 & 255] ^ SUB_MIX_3[255 & s2] ^ keySchedule[ksRow++];
              s0 = t0;
              s1 = t1;
              s2 = t2;
              s3 = t3;
            }
            var t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 | SBOX[s2 >>> 8 & 255] << 8 | SBOX[255 & s3]) ^ keySchedule[ksRow++];
            var t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 255] << 16 | SBOX[s3 >>> 8 & 255] << 8 | SBOX[255 & s0]) ^ keySchedule[ksRow++];
            var t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 255] << 16 | SBOX[s0 >>> 8 & 255] << 8 | SBOX[255 & s1]) ^ keySchedule[ksRow++];
            var t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 | SBOX[s1 >>> 8 & 255] << 8 | SBOX[255 & s2]) ^ keySchedule[ksRow++];
            M[offset] = t0;
            M[offset + 1] = t1;
            M[offset + 2] = t2;
            M[offset + 3] = t3;
          },
          keySize: 8
        });
        C.AES = BlockCipher._createHelper(AES);
      })();
      return CryptoJS.AES;
    });
    cc._RF.pop();
  }, {
    "./cipher-core": "cipher-core",
    "./core": "core",
    "./enc-base64": "enc-base64",
    "./evpkdf": "evpkdf",
    "./md5": "md5"
  } ],
  "cipher-core": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "7727finVORC0I+RuLWG+KYf", "cipher-core");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./evpkdf")) : "function" === typeof define && define.amd ? define([ "./core", "./evpkdf" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      CryptoJS.lib.Cipher || function(undefined) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var Base64 = C_enc.Base64;
        var C_algo = C.algo;
        var EvpKDF = C_algo.EvpKDF;
        var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          createEncryptor: function createEncryptor(key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
          },
          createDecryptor: function createDecryptor(key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
          },
          init: function init(xformMode, key, cfg) {
            this.cfg = this.cfg.extend(cfg);
            this._xformMode = xformMode;
            this._key = key;
            this.reset();
          },
          reset: function reset() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          process: function process(dataUpdate) {
            this._append(dataUpdate);
            return this._process();
          },
          finalize: function finalize(dataUpdate) {
            dataUpdate && this._append(dataUpdate);
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          },
          keySize: 4,
          ivSize: 4,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          _createHelper: function() {
            function selectCipherStrategy(key) {
              return "string" == typeof key ? PasswordBasedCipher : SerializableCipher;
            }
            return function(cipher) {
              return {
                encrypt: function encrypt(message, key, cfg) {
                  return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                },
                decrypt: function decrypt(ciphertext, key, cfg) {
                  return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                }
              };
            };
          }()
        });
        var StreamCipher = C_lib.StreamCipher = Cipher.extend({
          _doFinalize: function _doFinalize() {
            var finalProcessedBlocks = this._process(true);
            return finalProcessedBlocks;
          },
          blockSize: 1
        });
        var C_mode = C.mode = {};
        var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
          createEncryptor: function createEncryptor(cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          },
          createDecryptor: function createDecryptor(cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          },
          init: function init(cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
          }
        });
        var CBC = C_mode.CBC = function() {
          var CBC = BlockCipherMode.extend();
          CBC.Encryptor = CBC.extend({
            processBlock: function processBlock(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              xorBlock.call(this, words, offset, blockSize);
              cipher.encryptBlock(words, offset);
              this._prevBlock = words.slice(offset, offset + blockSize);
            }
          });
          CBC.Decryptor = CBC.extend({
            processBlock: function processBlock(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words.slice(offset, offset + blockSize);
              cipher.decryptBlock(words, offset);
              xorBlock.call(this, words, offset, blockSize);
              this._prevBlock = thisBlock;
            }
          });
          function xorBlock(words, offset, blockSize) {
            var iv = this._iv;
            if (iv) {
              var block = iv;
              this._iv = undefined;
            } else var block = this._prevBlock;
            for (var i = 0; i < blockSize; i++) words[offset + i] ^= block[i];
          }
          return CBC;
        }();
        var C_pad = C.pad = {};
        var Pkcs7 = C_pad.Pkcs7 = {
          pad: function pad(data, blockSize) {
            var blockSizeBytes = 4 * blockSize;
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
            var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
            var paddingWords = [];
            for (var i = 0; i < nPaddingBytes; i += 4) paddingWords.push(paddingWord);
            var padding = WordArray.create(paddingWords, nPaddingBytes);
            data.concat(padding);
          },
          unpad: function unpad(data) {
            var nPaddingBytes = 255 & data.words[data.sigBytes - 1 >>> 2];
            data.sigBytes -= nPaddingBytes;
          }
        };
        var BlockCipher = C_lib.BlockCipher = Cipher.extend({
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: function reset() {
            Cipher.reset.call(this);
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) var modeCreator = mode.createEncryptor; else {
              var modeCreator = mode.createDecryptor;
              this._minBufferSize = 1;
            }
            if (this._mode && this._mode.__creator == modeCreator) this._mode.init(this, iv && iv.words); else {
              this._mode = modeCreator.call(mode, this, iv && iv.words);
              this._mode.__creator = modeCreator;
            }
          },
          _doProcessBlock: function _doProcessBlock(words, offset) {
            this._mode.processBlock(words, offset);
          },
          _doFinalize: function _doFinalize() {
            var padding = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              padding.pad(this._data, this.blockSize);
              var finalProcessedBlocks = this._process(true);
            } else {
              var finalProcessedBlocks = this._process(true);
              padding.unpad(finalProcessedBlocks);
            }
            return finalProcessedBlocks;
          },
          blockSize: 4
        });
        var CipherParams = C_lib.CipherParams = Base.extend({
          init: function init(cipherParams) {
            this.mixIn(cipherParams);
          },
          toString: function toString(formatter) {
            return (formatter || this.formatter).stringify(this);
          }
        });
        var C_format = C.format = {};
        var OpenSSLFormatter = C_format.OpenSSL = {
          stringify: function stringify(cipherParams) {
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;
            if (salt) var wordArray = WordArray.create([ 1398893684, 1701076831 ]).concat(salt).concat(ciphertext); else var wordArray = ciphertext;
            return wordArray.toString(Base64);
          },
          parse: function parse(openSSLStr) {
            var ciphertext = Base64.parse(openSSLStr);
            var ciphertextWords = ciphertext.words;
            if (1398893684 == ciphertextWords[0] && 1701076831 == ciphertextWords[1]) {
              var salt = WordArray.create(ciphertextWords.slice(2, 4));
              ciphertextWords.splice(0, 4);
              ciphertext.sigBytes -= 16;
            }
            return CipherParams.create({
              ciphertext: ciphertext,
              salt: salt
            });
          }
        };
        var SerializableCipher = C_lib.SerializableCipher = Base.extend({
          cfg: Base.extend({
            format: OpenSSLFormatter
          }),
          encrypt: function encrypt(cipher, message, key, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message);
            var cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext: ciphertext,
              key: key,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          },
          decrypt: function decrypt(cipher, ciphertext, key, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          },
          _parse: function _parse(ciphertext, format) {
            return "string" == typeof ciphertext ? format.parse(ciphertext, this) : ciphertext;
          }
        });
        var C_kdf = C.kdf = {};
        var OpenSSLKdf = C_kdf.OpenSSL = {
          execute: function execute(password, keySize, ivSize, salt) {
            salt || (salt = WordArray.random(8));
            var key = EvpKDF.create({
              keySize: keySize + ivSize
            }).compute(password, salt);
            var iv = WordArray.create(key.words.slice(keySize), 4 * ivSize);
            key.sigBytes = 4 * keySize;
            return CipherParams.create({
              key: key,
              iv: iv,
              salt: salt
            });
          }
        };
        var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          encrypt: function encrypt(cipher, message, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
            ciphertext.mixIn(derivedParams);
            return ciphertext;
          },
          decrypt: function decrypt(cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }
        });
      }();
    });
    cc._RF.pop();
  }, {
    "./core": "core",
    "./evpkdf": "evpkdf"
  } ],
  core: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "477d6XNuaxAtZpTVHnfGFhD", "core");
    "use strict";
    (function(root, factory) {
      "object" === typeof exports ? module.exports = exports = factory() : "function" === typeof define && define.amd ? define([], factory) : root.CryptoJS = factory();
    })(void 0, function() {
      var CryptoJS = CryptoJS || function(Math, undefined) {
        var create = Object.create || function() {
          function F() {}
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = function() {
          return {
            extend: function extend(overrides) {
              var subtype = create(this);
              overrides && subtype.mixIn(overrides);
              subtype.hasOwnProperty("init") && this.init !== subtype.init || (subtype.init = function() {
                subtype.$super.init.apply(this, arguments);
              });
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            create: function create() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            init: function init() {},
            mixIn: function mixIn(properties) {
              for (var propertyName in properties) properties.hasOwnProperty(propertyName) && (this[propertyName] = properties[propertyName]);
              properties.hasOwnProperty("toString") && (this.toString = properties.toString);
            },
            clone: function clone() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          init: function init(words, sigBytes) {
            words = this.words = words || [];
            this.sigBytes = sigBytes != undefined ? sigBytes : 4 * words.length;
          },
          toString: function toString(encoder) {
            return (encoder || Hex).stringify(this);
          },
          concat: function concat(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) for (var i = 0; i < thatSigBytes; i++) {
              var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
            } else for (var i = 0; i < thatSigBytes; i += 4) thisWords[thisSigBytes + i >>> 2] = thatWords[i >>> 2];
            this.sigBytes += thatSigBytes;
            return this;
          },
          clamp: function clamp() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math.ceil(sigBytes / 4);
          },
          clone: function clone() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          random: function random(nBytes) {
            var words = [];
            var r = function r(m_w) {
              var m_w = m_w;
              var m_z = 987654321;
              var mask = 4294967295;
              return function() {
                m_z = 36969 * (65535 & m_z) + (m_z >> 16) & mask;
                m_w = 18e3 * (65535 & m_w) + (m_w >> 16) & mask;
                var result = (m_z << 16) + m_w & mask;
                result /= 4294967296;
                result += .5;
                return result * (Math.random() > .5 ? 1 : -1);
              };
            };
            for (var i = 0, rcache; i < nBytes; i += 4) {
              var _r = r(4294967296 * (rcache || Math.random()));
              rcache = 987654071 * _r();
              words.push(4294967296 * _r() | 0);
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          stringify: function stringify(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((15 & bite).toString(16));
            }
            return hexChars.join("");
          },
          parse: function parse(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          stringify: function stringify(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          parse: function parse(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) words[i >>> 2] |= (255 & latin1Str.charCodeAt(i)) << 24 - i % 4 * 8;
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          stringify: function stringify(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          parse: function parse(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          reset: function reset() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          _append: function _append(data) {
            "string" == typeof data && (data = Utf8.parse(data));
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          _process: function _process(doFlush) {
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = 4 * blockSize;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            nBlocksReady = doFlush ? Math.ceil(nBlocksReady) : Math.max((0 | nBlocksReady) - this._minBufferSize, 0);
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math.min(4 * nWordsReady, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) this._doProcessBlock(dataWords, offset);
              var processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          clone: function clone() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          init: function init(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          reset: function reset() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          update: function update(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          finalize: function finalize(messageUpdate) {
            messageUpdate && this._append(messageUpdate);
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 16,
          _createHelper: function _createHelper(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          _createHmacHelper: function _createHmacHelper(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS;
    });
    cc._RF.pop();
  }, {} ],
  "crypto-js": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "fa50arzzX9Oappsa3wvgJPe", "crypto-js");
    "use strict";
    (function(root, factory) {
      "object" === typeof exports ? module.exports = exports = factory() : "function" === typeof define && define.amd ? define([], factory) : root.CryptoJS = factory();
    })(void 0, function() {
      var CryptoJS = CryptoJS || function(Math, undefined) {
        var create = Object.create || function() {
          function F() {}
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = function() {
          return {
            extend: function extend(overrides) {
              var subtype = create(this);
              overrides && subtype.mixIn(overrides);
              subtype.hasOwnProperty("init") && this.init !== subtype.init || (subtype.init = function() {
                subtype.$super.init.apply(this, arguments);
              });
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            create: function create() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            init: function init() {},
            mixIn: function mixIn(properties) {
              for (var propertyName in properties) properties.hasOwnProperty(propertyName) && (this[propertyName] = properties[propertyName]);
              properties.hasOwnProperty("toString") && (this.toString = properties.toString);
            },
            clone: function clone() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          init: function init(words, sigBytes) {
            words = this.words = words || [];
            this.sigBytes = sigBytes != undefined ? sigBytes : 4 * words.length;
          },
          toString: function toString(encoder) {
            return (encoder || Hex).stringify(this);
          },
          concat: function concat(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) for (var i = 0; i < thatSigBytes; i++) {
              var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
            } else for (var i = 0; i < thatSigBytes; i += 4) thisWords[thisSigBytes + i >>> 2] = thatWords[i >>> 2];
            this.sigBytes += thatSigBytes;
            return this;
          },
          clamp: function clamp() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math.ceil(sigBytes / 4);
          },
          clone: function clone() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          random: function random(nBytes) {
            var words = [];
            var r = function r(m_w) {
              var m_w = m_w;
              var m_z = 987654321;
              var mask = 4294967295;
              return function() {
                m_z = 36969 * (65535 & m_z) + (m_z >> 16) & mask;
                m_w = 18e3 * (65535 & m_w) + (m_w >> 16) & mask;
                var result = (m_z << 16) + m_w & mask;
                result /= 4294967296;
                result += .5;
                return result * (Math.random() > .5 ? 1 : -1);
              };
            };
            for (var i = 0, rcache; i < nBytes; i += 4) {
              var _r = r(4294967296 * (rcache || Math.random()));
              rcache = 987654071 * _r();
              words.push(4294967296 * _r() | 0);
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          stringify: function stringify(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((15 & bite).toString(16));
            }
            return hexChars.join("");
          },
          parse: function parse(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          stringify: function stringify(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          parse: function parse(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) words[i >>> 2] |= (255 & latin1Str.charCodeAt(i)) << 24 - i % 4 * 8;
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          stringify: function stringify(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          parse: function parse(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          reset: function reset() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          _append: function _append(data) {
            "string" == typeof data && (data = Utf8.parse(data));
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          _process: function _process(doFlush) {
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = 4 * blockSize;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            nBlocksReady = doFlush ? Math.ceil(nBlocksReady) : Math.max((0 | nBlocksReady) - this._minBufferSize, 0);
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math.min(4 * nWordsReady, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) this._doProcessBlock(dataWords, offset);
              var processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          clone: function clone() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          init: function init(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          reset: function reset() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          update: function update(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          finalize: function finalize(messageUpdate) {
            messageUpdate && this._append(messageUpdate);
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 16,
          _createHelper: function _createHelper(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          _createHmacHelper: function _createHmacHelper(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Base64 = C_enc.Base64 = {
          stringify: function stringify(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
              var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
              var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i + .75 * j < sigBytes; j++) base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) while (base64Chars.length % 4) base64Chars.push(paddingChar);
            return base64Chars.join("");
          },
          parse: function parse(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) reverseMap[map.charCodeAt(j)] = j;
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              -1 !== paddingIndex && (base64StrLength = paddingIndex);
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i = 0; i < base64StrLength; i++) if (i % 4) {
            var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
            var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
            words[nBytes >>> 2] |= (bits1 | bits2) << 24 - nBytes % 4 * 8;
            nBytes++;
          }
          return WordArray.create(words, nBytes);
        }
      })();
      (function(Math) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var T = [];
        (function() {
          for (var i = 0; i < 64; i++) T[i] = 4294967296 * Math.abs(Math.sin(i + 1)) | 0;
        })();
        var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function _doReset() {
            this._hash = new WordArray.init([ 1732584193, 4023233417, 2562383102, 271733878 ]);
          },
          _doProcessBlock: function _doProcessBlock(M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = 16711935 & (M_offset_i << 8 | M_offset_i >>> 24) | 4278255360 & (M_offset_i << 24 | M_offset_i >>> 8);
            }
            var H = this._hash.words;
            var M_offset_0 = M[offset + 0];
            var M_offset_1 = M[offset + 1];
            var M_offset_2 = M[offset + 2];
            var M_offset_3 = M[offset + 3];
            var M_offset_4 = M[offset + 4];
            var M_offset_5 = M[offset + 5];
            var M_offset_6 = M[offset + 6];
            var M_offset_7 = M[offset + 7];
            var M_offset_8 = M[offset + 8];
            var M_offset_9 = M[offset + 9];
            var M_offset_10 = M[offset + 10];
            var M_offset_11 = M[offset + 11];
            var M_offset_12 = M[offset + 12];
            var M_offset_13 = M[offset + 13];
            var M_offset_14 = M[offset + 14];
            var M_offset_15 = M[offset + 15];
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            a = FF(a, b, c, d, M_offset_0, 7, T[0]);
            d = FF(d, a, b, c, M_offset_1, 12, T[1]);
            c = FF(c, d, a, b, M_offset_2, 17, T[2]);
            b = FF(b, c, d, a, M_offset_3, 22, T[3]);
            a = FF(a, b, c, d, M_offset_4, 7, T[4]);
            d = FF(d, a, b, c, M_offset_5, 12, T[5]);
            c = FF(c, d, a, b, M_offset_6, 17, T[6]);
            b = FF(b, c, d, a, M_offset_7, 22, T[7]);
            a = FF(a, b, c, d, M_offset_8, 7, T[8]);
            d = FF(d, a, b, c, M_offset_9, 12, T[9]);
            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
            a = FF(a, b, c, d, M_offset_12, 7, T[12]);
            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
            b = FF(b, c, d, a, M_offset_15, 22, T[15]);
            a = GG(a, b, c, d, M_offset_1, 5, T[16]);
            d = GG(d, a, b, c, M_offset_6, 9, T[17]);
            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
            b = GG(b, c, d, a, M_offset_0, 20, T[19]);
            a = GG(a, b, c, d, M_offset_5, 5, T[20]);
            d = GG(d, a, b, c, M_offset_10, 9, T[21]);
            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
            b = GG(b, c, d, a, M_offset_4, 20, T[23]);
            a = GG(a, b, c, d, M_offset_9, 5, T[24]);
            d = GG(d, a, b, c, M_offset_14, 9, T[25]);
            c = GG(c, d, a, b, M_offset_3, 14, T[26]);
            b = GG(b, c, d, a, M_offset_8, 20, T[27]);
            a = GG(a, b, c, d, M_offset_13, 5, T[28]);
            d = GG(d, a, b, c, M_offset_2, 9, T[29]);
            c = GG(c, d, a, b, M_offset_7, 14, T[30]);
            b = GG(b, c, d, a, M_offset_12, 20, T[31]);
            a = HH(a, b, c, d, M_offset_5, 4, T[32]);
            d = HH(d, a, b, c, M_offset_8, 11, T[33]);
            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
            a = HH(a, b, c, d, M_offset_1, 4, T[36]);
            d = HH(d, a, b, c, M_offset_4, 11, T[37]);
            c = HH(c, d, a, b, M_offset_7, 16, T[38]);
            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
            a = HH(a, b, c, d, M_offset_13, 4, T[40]);
            d = HH(d, a, b, c, M_offset_0, 11, T[41]);
            c = HH(c, d, a, b, M_offset_3, 16, T[42]);
            b = HH(b, c, d, a, M_offset_6, 23, T[43]);
            a = HH(a, b, c, d, M_offset_9, 4, T[44]);
            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
            b = HH(b, c, d, a, M_offset_2, 23, T[47]);
            a = II(a, b, c, d, M_offset_0, 6, T[48]);
            d = II(d, a, b, c, M_offset_7, 10, T[49]);
            c = II(c, d, a, b, M_offset_14, 15, T[50]);
            b = II(b, c, d, a, M_offset_5, 21, T[51]);
            a = II(a, b, c, d, M_offset_12, 6, T[52]);
            d = II(d, a, b, c, M_offset_3, 10, T[53]);
            c = II(c, d, a, b, M_offset_10, 15, T[54]);
            b = II(b, c, d, a, M_offset_1, 21, T[55]);
            a = II(a, b, c, d, M_offset_8, 6, T[56]);
            d = II(d, a, b, c, M_offset_15, 10, T[57]);
            c = II(c, d, a, b, M_offset_6, 15, T[58]);
            b = II(b, c, d, a, M_offset_13, 21, T[59]);
            a = II(a, b, c, d, M_offset_4, 6, T[60]);
            d = II(d, a, b, c, M_offset_11, 10, T[61]);
            c = II(c, d, a, b, M_offset_2, 15, T[62]);
            b = II(b, c, d, a, M_offset_9, 21, T[63]);
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
          },
          _doFinalize: function _doFinalize() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = 8 * this._nDataBytes;
            var nBitsLeft = 8 * data.sigBytes;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[15 + (nBitsLeft + 64 >>> 9 << 4)] = 16711935 & (nBitsTotalH << 8 | nBitsTotalH >>> 24) | 4278255360 & (nBitsTotalH << 24 | nBitsTotalH >>> 8);
            dataWords[14 + (nBitsLeft + 64 >>> 9 << 4)] = 16711935 & (nBitsTotalL << 8 | nBitsTotalL >>> 24) | 4278255360 & (nBitsTotalL << 24 | nBitsTotalL >>> 8);
            data.sigBytes = 4 * (dataWords.length + 1);
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i = 0; i < 4; i++) {
              var H_i = H[i];
              H[i] = 16711935 & (H_i << 8 | H_i >>> 24) | 4278255360 & (H_i << 24 | H_i >>> 8);
            }
            return hash;
          },
          clone: function clone() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a, b, c, d, x, s, t) {
          var n = a + (b & c | ~b & d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function GG(a, b, c, d, x, s, t) {
          var n = a + (b & d | c & ~d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function HH(a, b, c, d, x, s, t) {
          var n = a + (b ^ c ^ d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function II(a, b, c, d, x, s, t) {
          var n = a + (c ^ (b | ~d)) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        C.MD5 = Hasher._createHelper(MD5);
        C.HmacMD5 = Hasher._createHmacHelper(MD5);
      })(Math);
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var W = [];
        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function _doReset() {
            this._hash = new WordArray.init([ 1732584193, 4023233417, 2562383102, 271733878, 3285377520 ]);
          },
          _doProcessBlock: function _doProcessBlock(M, offset) {
            var H = this._hash.words;
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];
            for (var i = 0; i < 80; i++) {
              if (i < 16) W[i] = 0 | M[offset + i]; else {
                var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                W[i] = n << 1 | n >>> 31;
              }
              var t = (a << 5 | a >>> 27) + e + W[i];
              t += i < 20 ? 1518500249 + (b & c | ~b & d) : i < 40 ? 1859775393 + (b ^ c ^ d) : i < 60 ? (b & c | b & d | c & d) - 1894007588 : (b ^ c ^ d) - 899497514;
              e = d;
              d = c;
              c = b << 30 | b >>> 2;
              b = a;
              a = t;
            }
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
            H[4] = H[4] + e | 0;
          },
          _doFinalize: function _doFinalize() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = 8 * this._nDataBytes;
            var nBitsLeft = 8 * data.sigBytes;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[14 + (nBitsLeft + 64 >>> 9 << 4)] = Math.floor(nBitsTotal / 4294967296);
            dataWords[15 + (nBitsLeft + 64 >>> 9 << 4)] = nBitsTotal;
            data.sigBytes = 4 * dataWords.length;
            this._process();
            return this._hash;
          },
          clone: function clone() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA1 = Hasher._createHelper(SHA1);
        C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();
      (function(Math) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var H = [];
        var K = [];
        (function() {
          function isPrime(n) {
            var sqrtN = Math.sqrt(n);
            for (var factor = 2; factor <= sqrtN; factor++) if (!(n % factor)) return false;
            return true;
          }
          function getFractionalBits(n) {
            return 4294967296 * (n - (0 | n)) | 0;
          }
          var n = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n)) {
              nPrime < 8 && (H[nPrime] = getFractionalBits(Math.pow(n, .5)));
              K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));
              nPrime++;
            }
            n++;
          }
        })();
        var W = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function _doReset() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function _doProcessBlock(M, offset) {
            var H = this._hash.words;
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];
            var f = H[5];
            var g = H[6];
            var h = H[7];
            for (var i = 0; i < 64; i++) {
              if (i < 16) W[i] = 0 | M[offset + i]; else {
                var gamma0x = W[i - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
              }
              var ch = e & f ^ ~e & g;
              var maj = a & b ^ a & c ^ b & c;
              var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
              var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
              var t1 = h + sigma1 + ch + K[i] + W[i];
              var t2 = sigma0 + maj;
              h = g;
              g = f;
              f = e;
              e = d + t1 | 0;
              d = c;
              c = b;
              b = a;
              a = t1 + t2 | 0;
            }
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
            H[4] = H[4] + e | 0;
            H[5] = H[5] + f | 0;
            H[6] = H[6] + g | 0;
            H[7] = H[7] + h | 0;
          },
          _doFinalize: function _doFinalize() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = 8 * this._nDataBytes;
            var nBitsLeft = 8 * data.sigBytes;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[14 + (nBitsLeft + 64 >>> 9 << 4)] = Math.floor(nBitsTotal / 4294967296);
            dataWords[15 + (nBitsLeft + 64 >>> 9 << 4)] = nBitsTotal;
            data.sigBytes = 4 * dataWords.length;
            this._process();
            return this._hash;
          },
          clone: function clone() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA256 = Hasher._createHelper(SHA256);
        C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
          stringify: function stringify(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i = 0; i < sigBytes; i += 2) {
              var codePoint = words[i >>> 2] >>> 16 - i % 4 * 8 & 65535;
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          parse: function parse(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i = 0; i < utf16StrLength; i++) words[i >>> 1] |= utf16Str.charCodeAt(i) << 16 - i % 2 * 16;
            return WordArray.create(words, 2 * utf16StrLength);
          }
        };
        C_enc.Utf16LE = {
          stringify: function stringify(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i = 0; i < sigBytes; i += 2) {
              var codePoint = swapEndian(words[i >>> 2] >>> 16 - i % 4 * 8 & 65535);
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          parse: function parse(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i = 0; i < utf16StrLength; i++) words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << 16 - i % 2 * 16);
            return WordArray.create(words, 2 * utf16StrLength);
          }
        };
        function swapEndian(word) {
          return word << 8 & 4278255360 | word >>> 8 & 16711935;
        }
      })();
      (function() {
        if ("function" != typeof ArrayBuffer) return;
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var superInit = WordArray.init;
        var subInit = WordArray.init = function(typedArray) {
          typedArray instanceof ArrayBuffer && (typedArray = new Uint8Array(typedArray));
          (typedArray instanceof Int8Array || "undefined" !== typeof Uint8ClampedArray && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) && (typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength));
          if (typedArray instanceof Uint8Array) {
            var typedArrayByteLength = typedArray.byteLength;
            var words = [];
            for (var i = 0; i < typedArrayByteLength; i++) words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;
            superInit.call(this, words, typedArrayByteLength);
          } else superInit.apply(this, arguments);
        };
        subInit.prototype = WordArray;
      })();
      (function(Math) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var _zl = WordArray.create([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13 ]);
        var _zr = WordArray.create([ 5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11 ]);
        var _sl = WordArray.create([ 11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6 ]);
        var _sr = WordArray.create([ 8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11 ]);
        var _hl = WordArray.create([ 0, 1518500249, 1859775393, 2400959708, 2840853838 ]);
        var _hr = WordArray.create([ 1352829926, 1548603684, 1836072691, 2053994217, 0 ]);
        var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
          _doReset: function _doReset() {
            this._hash = WordArray.create([ 1732584193, 4023233417, 2562383102, 271733878, 3285377520 ]);
          },
          _doProcessBlock: function _doProcessBlock(M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = 16711935 & (M_offset_i << 8 | M_offset_i >>> 24) | 4278255360 & (M_offset_i << 24 | M_offset_i >>> 8);
            }
            var H = this._hash.words;
            var hl = _hl.words;
            var hr = _hr.words;
            var zl = _zl.words;
            var zr = _zr.words;
            var sl = _sl.words;
            var sr = _sr.words;
            var al, bl, cl, dl, el;
            var ar, br, cr, dr, er;
            ar = al = H[0];
            br = bl = H[1];
            cr = cl = H[2];
            dr = dl = H[3];
            er = el = H[4];
            var t;
            for (var i = 0; i < 80; i += 1) {
              t = al + M[offset + zl[i]] | 0;
              t += i < 16 ? f1(bl, cl, dl) + hl[0] : i < 32 ? f2(bl, cl, dl) + hl[1] : i < 48 ? f3(bl, cl, dl) + hl[2] : i < 64 ? f4(bl, cl, dl) + hl[3] : f5(bl, cl, dl) + hl[4];
              t |= 0;
              t = rotl(t, sl[i]);
              t = t + el | 0;
              al = el;
              el = dl;
              dl = rotl(cl, 10);
              cl = bl;
              bl = t;
              t = ar + M[offset + zr[i]] | 0;
              t += i < 16 ? f5(br, cr, dr) + hr[0] : i < 32 ? f4(br, cr, dr) + hr[1] : i < 48 ? f3(br, cr, dr) + hr[2] : i < 64 ? f2(br, cr, dr) + hr[3] : f1(br, cr, dr) + hr[4];
              t |= 0;
              t = rotl(t, sr[i]);
              t = t + er | 0;
              ar = er;
              er = dr;
              dr = rotl(cr, 10);
              cr = br;
              br = t;
            }
            t = H[1] + cl + dr | 0;
            H[1] = H[2] + dl + er | 0;
            H[2] = H[3] + el + ar | 0;
            H[3] = H[4] + al + br | 0;
            H[4] = H[0] + bl + cr | 0;
            H[0] = t;
          },
          _doFinalize: function _doFinalize() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = 8 * this._nDataBytes;
            var nBitsLeft = 8 * data.sigBytes;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[14 + (nBitsLeft + 64 >>> 9 << 4)] = 16711935 & (nBitsTotal << 8 | nBitsTotal >>> 24) | 4278255360 & (nBitsTotal << 24 | nBitsTotal >>> 8);
            data.sigBytes = 4 * (dataWords.length + 1);
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i = 0; i < 5; i++) {
              var H_i = H[i];
              H[i] = 16711935 & (H_i << 8 | H_i >>> 24) | 4278255360 & (H_i << 24 | H_i >>> 8);
            }
            return hash;
          },
          clone: function clone() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function f1(x, y, z) {
          return x ^ y ^ z;
        }
        function f2(x, y, z) {
          return x & y | ~x & z;
        }
        function f3(x, y, z) {
          return (x | ~y) ^ z;
        }
        function f4(x, y, z) {
          return x & z | y & ~z;
        }
        function f5(x, y, z) {
          return x ^ (y | ~z);
        }
        function rotl(x, n) {
          return x << n | x >>> 32 - n;
        }
        C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
        C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
      })(Math);
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C.algo;
        var HMAC = C_algo.HMAC = Base.extend({
          init: function init(hasher, key) {
            hasher = this._hasher = new hasher.init();
            "string" == typeof key && (key = Utf8.parse(key));
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = 4 * hasherBlockSize;
            key.sigBytes > hasherBlockSizeBytes && (key = hasher.finalize(key));
            key.clamp();
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i = 0; i < hasherBlockSize; i++) {
              oKeyWords[i] ^= 1549556828;
              iKeyWords[i] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          reset: function reset() {
            var hasher = this._hasher;
            hasher.reset();
            hasher.update(this._iKey);
          },
          update: function update(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          finalize: function finalize(messageUpdate) {
            var hasher = this._hasher;
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac;
          }
        });
      })();
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA1 = C_algo.SHA1;
        var HMAC = C_algo.HMAC;
        var PBKDF2 = C_algo.PBKDF2 = Base.extend({
          cfg: Base.extend({
            keySize: 4,
            hasher: SHA1,
            iterations: 1
          }),
          init: function init(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          compute: function compute(password, salt) {
            var cfg = this.cfg;
            var hmac = HMAC.create(cfg.hasher, password);
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([ 1 ]);
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              var block = hmac.update(salt).finalize(blockIndex);
              hmac.reset();
              var blockWords = block.words;
              var blockWordsLength = blockWords.length;
              var intermediate = block;
              for (var i = 1; i < iterations; i++) {
                intermediate = hmac.finalize(intermediate);
                hmac.reset();
                var intermediateWords = intermediate.words;
                for (var j = 0; j < blockWordsLength; j++) blockWords[j] ^= intermediateWords[j];
              }
              derivedKey.concat(block);
              blockIndexWords[0]++;
            }
            derivedKey.sigBytes = 4 * keySize;
            return derivedKey;
          }
        });
        C.PBKDF2 = function(password, salt, cfg) {
          return PBKDF2.create(cfg).compute(password, salt);
        };
      })();
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var MD5 = C_algo.MD5;
        var EvpKDF = C_algo.EvpKDF = Base.extend({
          cfg: Base.extend({
            keySize: 4,
            hasher: MD5,
            iterations: 1
          }),
          init: function init(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          compute: function compute(password, salt) {
            var cfg = this.cfg;
            var hasher = cfg.hasher.create();
            var derivedKey = WordArray.create();
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              block && hasher.update(block);
              var block = hasher.update(password).finalize(salt);
              hasher.reset();
              for (var i = 1; i < iterations; i++) {
                block = hasher.finalize(block);
                hasher.reset();
              }
              derivedKey.concat(block);
            }
            derivedKey.sigBytes = 4 * keySize;
            return derivedKey;
          }
        });
        C.EvpKDF = function(password, salt, cfg) {
          return EvpKDF.create(cfg).compute(password, salt);
        };
      })();
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA256 = C_algo.SHA256;
        var SHA224 = C_algo.SHA224 = SHA256.extend({
          _doReset: function _doReset() {
            this._hash = new WordArray.init([ 3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428 ]);
          },
          _doFinalize: function _doFinalize() {
            var hash = SHA256._doFinalize.call(this);
            hash.sigBytes -= 4;
            return hash;
          }
        });
        C.SHA224 = SHA256._createHelper(SHA224);
        C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
      })();
      (function(undefined) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var X32WordArray = C_lib.WordArray;
        var C_x64 = C.x64 = {};
        var X64Word = C_x64.Word = Base.extend({
          init: function init(high, low) {
            this.high = high;
            this.low = low;
          }
        });
        var X64WordArray = C_x64.WordArray = Base.extend({
          init: function init(words, sigBytes) {
            words = this.words = words || [];
            this.sigBytes = sigBytes != undefined ? sigBytes : 8 * words.length;
          },
          toX32: function toX32() {
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;
            var x32Words = [];
            for (var i = 0; i < x64WordsLength; i++) {
              var x64Word = x64Words[i];
              x32Words.push(x64Word.high);
              x32Words.push(x64Word.low);
            }
            return X32WordArray.create(x32Words, this.sigBytes);
          },
          clone: function clone() {
            var clone = Base.clone.call(this);
            var words = clone.words = this.words.slice(0);
            var wordsLength = words.length;
            for (var i = 0; i < wordsLength; i++) words[i] = words[i].clone();
            return clone;
          }
        });
      })();
      (function(Math) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var C_algo = C.algo;
        var RHO_OFFSETS = [];
        var PI_INDEXES = [];
        var ROUND_CONSTANTS = [];
        (function() {
          var x = 1, y = 0;
          for (var t = 0; t < 24; t++) {
            RHO_OFFSETS[x + 5 * y] = (t + 1) * (t + 2) / 2 % 64;
            var newX = y % 5;
            var newY = (2 * x + 3 * y) % 5;
            x = newX;
            y = newY;
          }
          for (var x = 0; x < 5; x++) for (var y = 0; y < 5; y++) PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;
          var LFSR = 1;
          for (var i = 0; i < 24; i++) {
            var roundConstantMsw = 0;
            var roundConstantLsw = 0;
            for (var j = 0; j < 7; j++) {
              if (1 & LFSR) {
                var bitPosition = (1 << j) - 1;
                bitPosition < 32 ? roundConstantLsw ^= 1 << bitPosition : roundConstantMsw ^= 1 << bitPosition - 32;
              }
              128 & LFSR ? LFSR = LFSR << 1 ^ 113 : LFSR <<= 1;
            }
            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
          }
        })();
        var T = [];
        (function() {
          for (var i = 0; i < 25; i++) T[i] = X64Word.create();
        })();
        var SHA3 = C_algo.SHA3 = Hasher.extend({
          cfg: Hasher.cfg.extend({
            outputLength: 512
          }),
          _doReset: function _doReset() {
            var state = this._state = [];
            for (var i = 0; i < 25; i++) state[i] = new X64Word.init();
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function _doProcessBlock(M, offset) {
            var state = this._state;
            var nBlockSizeLanes = this.blockSize / 2;
            for (var i = 0; i < nBlockSizeLanes; i++) {
              var M2i = M[offset + 2 * i];
              var M2i1 = M[offset + 2 * i + 1];
              M2i = 16711935 & (M2i << 8 | M2i >>> 24) | 4278255360 & (M2i << 24 | M2i >>> 8);
              M2i1 = 16711935 & (M2i1 << 8 | M2i1 >>> 24) | 4278255360 & (M2i1 << 24 | M2i1 >>> 8);
              var lane = state[i];
              lane.high ^= M2i1;
              lane.low ^= M2i;
            }
            for (var round = 0; round < 24; round++) {
              for (var x = 0; x < 5; x++) {
                var tMsw = 0, tLsw = 0;
                for (var y = 0; y < 5; y++) {
                  var lane = state[x + 5 * y];
                  tMsw ^= lane.high;
                  tLsw ^= lane.low;
                }
                var Tx = T[x];
                Tx.high = tMsw;
                Tx.low = tLsw;
              }
              for (var x = 0; x < 5; x++) {
                var Tx4 = T[(x + 4) % 5];
                var Tx1 = T[(x + 1) % 5];
                var Tx1Msw = Tx1.high;
                var Tx1Lsw = Tx1.low;
                var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                for (var y = 0; y < 5; y++) {
                  var lane = state[x + 5 * y];
                  lane.high ^= tMsw;
                  lane.low ^= tLsw;
                }
              }
              for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                var lane = state[laneIndex];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                var rhoOffset = RHO_OFFSETS[laneIndex];
                if (rhoOffset < 32) {
                  var tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                  var tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                } else {
                  var tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                  var tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                }
                var TPiLane = T[PI_INDEXES[laneIndex]];
                TPiLane.high = tMsw;
                TPiLane.low = tLsw;
              }
              var T0 = T[0];
              var state0 = state[0];
              T0.high = state0.high;
              T0.low = state0.low;
              for (var x = 0; x < 5; x++) for (var y = 0; y < 5; y++) {
                var laneIndex = x + 5 * y;
                var lane = state[laneIndex];
                var TLane = T[laneIndex];
                var Tx1Lane = T[(x + 1) % 5 + 5 * y];
                var Tx2Lane = T[(x + 2) % 5 + 5 * y];
                lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
              }
              var lane = state[0];
              var roundConstant = ROUND_CONSTANTS[round];
              lane.high ^= roundConstant.high;
              lane.low ^= roundConstant.low;
            }
          },
          _doFinalize: function _doFinalize() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = 8 * this._nDataBytes;
            var nBitsLeft = 8 * data.sigBytes;
            var blockSizeBits = 32 * this.blockSize;
            dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
            dataWords[(Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
            data.sigBytes = 4 * dataWords.length;
            this._process();
            var state = this._state;
            var outputLengthBytes = this.cfg.outputLength / 8;
            var outputLengthLanes = outputLengthBytes / 8;
            var hashWords = [];
            for (var i = 0; i < outputLengthLanes; i++) {
              var lane = state[i];
              var laneMsw = lane.high;
              var laneLsw = lane.low;
              laneMsw = 16711935 & (laneMsw << 8 | laneMsw >>> 24) | 4278255360 & (laneMsw << 24 | laneMsw >>> 8);
              laneLsw = 16711935 & (laneLsw << 8 | laneLsw >>> 24) | 4278255360 & (laneLsw << 24 | laneLsw >>> 8);
              hashWords.push(laneLsw);
              hashWords.push(laneMsw);
            }
            return new WordArray.init(hashWords, outputLengthBytes);
          },
          clone: function clone() {
            var clone = Hasher.clone.call(this);
            var state = clone._state = this._state.slice(0);
            for (var i = 0; i < 25; i++) state[i] = state[i].clone();
            return clone;
          }
        });
        C.SHA3 = Hasher._createHelper(SHA3);
        C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
      })(Math);
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        function X64Word_create() {
          return X64Word.create.apply(X64Word, arguments);
        }
        var K = [ X64Word_create(1116352408, 3609767458), X64Word_create(1899447441, 602891725), X64Word_create(3049323471, 3964484399), X64Word_create(3921009573, 2173295548), X64Word_create(961987163, 4081628472), X64Word_create(1508970993, 3053834265), X64Word_create(2453635748, 2937671579), X64Word_create(2870763221, 3664609560), X64Word_create(3624381080, 2734883394), X64Word_create(310598401, 1164996542), X64Word_create(607225278, 1323610764), X64Word_create(1426881987, 3590304994), X64Word_create(1925078388, 4068182383), X64Word_create(2162078206, 991336113), X64Word_create(2614888103, 633803317), X64Word_create(3248222580, 3479774868), X64Word_create(3835390401, 2666613458), X64Word_create(4022224774, 944711139), X64Word_create(264347078, 2341262773), X64Word_create(604807628, 2007800933), X64Word_create(770255983, 1495990901), X64Word_create(1249150122, 1856431235), X64Word_create(1555081692, 3175218132), X64Word_create(1996064986, 2198950837), X64Word_create(2554220882, 3999719339), X64Word_create(2821834349, 766784016), X64Word_create(2952996808, 2566594879), X64Word_create(3210313671, 3203337956), X64Word_create(3336571891, 1034457026), X64Word_create(3584528711, 2466948901), X64Word_create(113926993, 3758326383), X64Word_create(338241895, 168717936), X64Word_create(666307205, 1188179964), X64Word_create(773529912, 1546045734), X64Word_create(1294757372, 1522805485), X64Word_create(1396182291, 2643833823), X64Word_create(1695183700, 2343527390), X64Word_create(1986661051, 1014477480), X64Word_create(2177026350, 1206759142), X64Word_create(2456956037, 344077627), X64Word_create(2730485921, 1290863460), X64Word_create(2820302411, 3158454273), X64Word_create(3259730800, 3505952657), X64Word_create(3345764771, 106217008), X64Word_create(3516065817, 3606008344), X64Word_create(3600352804, 1432725776), X64Word_create(4094571909, 1467031594), X64Word_create(275423344, 851169720), X64Word_create(430227734, 3100823752), X64Word_create(506948616, 1363258195), X64Word_create(659060556, 3750685593), X64Word_create(883997877, 3785050280), X64Word_create(958139571, 3318307427), X64Word_create(1322822218, 3812723403), X64Word_create(1537002063, 2003034995), X64Word_create(1747873779, 3602036899), X64Word_create(1955562222, 1575990012), X64Word_create(2024104815, 1125592928), X64Word_create(2227730452, 2716904306), X64Word_create(2361852424, 442776044), X64Word_create(2428436474, 593698344), X64Word_create(2756734187, 3733110249), X64Word_create(3204031479, 2999351573), X64Word_create(3329325298, 3815920427), X64Word_create(3391569614, 3928383900), X64Word_create(3515267271, 566280711), X64Word_create(3940187606, 3454069534), X64Word_create(4118630271, 4000239992), X64Word_create(116418474, 1914138554), X64Word_create(174292421, 2731055270), X64Word_create(289380356, 3203993006), X64Word_create(460393269, 320620315), X64Word_create(685471733, 587496836), X64Word_create(852142971, 1086792851), X64Word_create(1017036298, 365543100), X64Word_create(1126000580, 2618297676), X64Word_create(1288033470, 3409855158), X64Word_create(1501505948, 4234509866), X64Word_create(1607167915, 987167468), X64Word_create(1816402316, 1246189591) ];
        var W = [];
        (function() {
          for (var i = 0; i < 80; i++) W[i] = X64Word_create();
        })();
        var SHA512 = C_algo.SHA512 = Hasher.extend({
          _doReset: function _doReset() {
            this._hash = new X64WordArray.init([ new X64Word.init(1779033703, 4089235720), new X64Word.init(3144134277, 2227873595), new X64Word.init(1013904242, 4271175723), new X64Word.init(2773480762, 1595750129), new X64Word.init(1359893119, 2917565137), new X64Word.init(2600822924, 725511199), new X64Word.init(528734635, 4215389547), new X64Word.init(1541459225, 327033209) ]);
          },
          _doProcessBlock: function _doProcessBlock(M, offset) {
            var H = this._hash.words;
            var H0 = H[0];
            var H1 = H[1];
            var H2 = H[2];
            var H3 = H[3];
            var H4 = H[4];
            var H5 = H[5];
            var H6 = H[6];
            var H7 = H[7];
            var H0h = H0.high;
            var H0l = H0.low;
            var H1h = H1.high;
            var H1l = H1.low;
            var H2h = H2.high;
            var H2l = H2.low;
            var H3h = H3.high;
            var H3l = H3.low;
            var H4h = H4.high;
            var H4l = H4.low;
            var H5h = H5.high;
            var H5l = H5.low;
            var H6h = H6.high;
            var H6l = H6.low;
            var H7h = H7.high;
            var H7l = H7.low;
            var ah = H0h;
            var al = H0l;
            var bh = H1h;
            var bl = H1l;
            var ch = H2h;
            var cl = H2l;
            var dh = H3h;
            var dl = H3l;
            var eh = H4h;
            var el = H4l;
            var fh = H5h;
            var fl = H5l;
            var gh = H6h;
            var gl = H6l;
            var hh = H7h;
            var hl = H7l;
            for (var i = 0; i < 80; i++) {
              var Wi = W[i];
              if (i < 16) {
                var Wih = Wi.high = 0 | M[offset + 2 * i];
                var Wil = Wi.low = 0 | M[offset + 2 * i + 1];
              } else {
                var gamma0x = W[i - 15];
                var gamma0xh = gamma0x.high;
                var gamma0xl = gamma0x.low;
                var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                var gamma1x = W[i - 2];
                var gamma1xh = gamma1x.high;
                var gamma1xl = gamma1x.low;
                var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                var Wi7 = W[i - 7];
                var Wi7h = Wi7.high;
                var Wi7l = Wi7.low;
                var Wi16 = W[i - 16];
                var Wi16h = Wi16.high;
                var Wi16l = Wi16.low;
                var Wil = gamma0l + Wi7l;
                var Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                var Wil = Wil + gamma1l;
                var Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                var Wil = Wil + Wi16l;
                var Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                Wi.high = Wih;
                Wi.low = Wil;
              }
              var chh = eh & fh ^ ~eh & gh;
              var chl = el & fl ^ ~el & gl;
              var majh = ah & bh ^ ah & ch ^ bh & ch;
              var majl = al & bl ^ al & cl ^ bl & cl;
              var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
              var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
              var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
              var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
              var Ki = K[i];
              var Kih = Ki.high;
              var Kil = Ki.low;
              var t1l = hl + sigma1l;
              var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
              var t1l = t1l + chl;
              var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
              var t1l = t1l + Kil;
              var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
              var t1l = t1l + Wil;
              var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
              var t2l = sigma0l + majl;
              var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
              hh = gh;
              hl = gl;
              gh = fh;
              gl = fl;
              fh = eh;
              fl = el;
              el = dl + t1l | 0;
              eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
              dh = ch;
              dl = cl;
              ch = bh;
              cl = bl;
              bh = ah;
              bl = al;
              al = t1l + t2l | 0;
              ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
            }
            H0l = H0.low = H0l + al;
            H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
            H1l = H1.low = H1l + bl;
            H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
            H2l = H2.low = H2l + cl;
            H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
            H3l = H3.low = H3l + dl;
            H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
            H4l = H4.low = H4l + el;
            H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
            H5l = H5.low = H5l + fl;
            H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
            H6l = H6.low = H6l + gl;
            H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
            H7l = H7.low = H7l + hl;
            H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
          },
          _doFinalize: function _doFinalize() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = 8 * this._nDataBytes;
            var nBitsLeft = 8 * data.sigBytes;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[30 + (nBitsLeft + 128 >>> 10 << 5)] = Math.floor(nBitsTotal / 4294967296);
            dataWords[31 + (nBitsLeft + 128 >>> 10 << 5)] = nBitsTotal;
            data.sigBytes = 4 * dataWords.length;
            this._process();
            var hash = this._hash.toX32();
            return hash;
          },
          clone: function clone() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          },
          blockSize: 32
        });
        C.SHA512 = Hasher._createHelper(SHA512);
        C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
      })();
      (function() {
        var C = CryptoJS;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        var SHA512 = C_algo.SHA512;
        var SHA384 = C_algo.SHA384 = SHA512.extend({
          _doReset: function _doReset() {
            this._hash = new X64WordArray.init([ new X64Word.init(3418070365, 3238371032), new X64Word.init(1654270250, 914150663), new X64Word.init(2438529370, 812702999), new X64Word.init(355462360, 4144912697), new X64Word.init(1731405415, 4290775857), new X64Word.init(2394180231, 1750603025), new X64Word.init(3675008525, 1694076839), new X64Word.init(1203062813, 3204075428) ]);
          },
          _doFinalize: function _doFinalize() {
            var hash = SHA512._doFinalize.call(this);
            hash.sigBytes -= 16;
            return hash;
          }
        });
        C.SHA384 = SHA512._createHelper(SHA384);
        C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
      })();
      CryptoJS.lib.Cipher || function(undefined) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var Base64 = C_enc.Base64;
        var C_algo = C.algo;
        var EvpKDF = C_algo.EvpKDF;
        var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          cfg: Base.extend(),
          createEncryptor: function createEncryptor(key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
          },
          createDecryptor: function createDecryptor(key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
          },
          init: function init(xformMode, key, cfg) {
            this.cfg = this.cfg.extend(cfg);
            this._xformMode = xformMode;
            this._key = key;
            this.reset();
          },
          reset: function reset() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          process: function process(dataUpdate) {
            this._append(dataUpdate);
            return this._process();
          },
          finalize: function finalize(dataUpdate) {
            dataUpdate && this._append(dataUpdate);
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          },
          keySize: 4,
          ivSize: 4,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          _createHelper: function() {
            function selectCipherStrategy(key) {
              return "string" == typeof key ? PasswordBasedCipher : SerializableCipher;
            }
            return function(cipher) {
              return {
                encrypt: function encrypt(message, key, cfg) {
                  return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                },
                decrypt: function decrypt(ciphertext, key, cfg) {
                  return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                }
              };
            };
          }()
        });
        var StreamCipher = C_lib.StreamCipher = Cipher.extend({
          _doFinalize: function _doFinalize() {
            var finalProcessedBlocks = this._process(true);
            return finalProcessedBlocks;
          },
          blockSize: 1
        });
        var C_mode = C.mode = {};
        var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
          createEncryptor: function createEncryptor(cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          },
          createDecryptor: function createDecryptor(cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          },
          init: function init(cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
          }
        });
        var CBC = C_mode.CBC = function() {
          var CBC = BlockCipherMode.extend();
          CBC.Encryptor = CBC.extend({
            processBlock: function processBlock(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              xorBlock.call(this, words, offset, blockSize);
              cipher.encryptBlock(words, offset);
              this._prevBlock = words.slice(offset, offset + blockSize);
            }
          });
          CBC.Decryptor = CBC.extend({
            processBlock: function processBlock(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words.slice(offset, offset + blockSize);
              cipher.decryptBlock(words, offset);
              xorBlock.call(this, words, offset, blockSize);
              this._prevBlock = thisBlock;
            }
          });
          function xorBlock(words, offset, blockSize) {
            var iv = this._iv;
            if (iv) {
              var block = iv;
              this._iv = undefined;
            } else var block = this._prevBlock;
            for (var i = 0; i < blockSize; i++) words[offset + i] ^= block[i];
          }
          return CBC;
        }();
        var C_pad = C.pad = {};
        var Pkcs7 = C_pad.Pkcs7 = {
          pad: function pad(data, blockSize) {
            var blockSizeBytes = 4 * blockSize;
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
            var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
            var paddingWords = [];
            for (var i = 0; i < nPaddingBytes; i += 4) paddingWords.push(paddingWord);
            var padding = WordArray.create(paddingWords, nPaddingBytes);
            data.concat(padding);
          },
          unpad: function unpad(data) {
            var nPaddingBytes = 255 & data.words[data.sigBytes - 1 >>> 2];
            data.sigBytes -= nPaddingBytes;
          }
        };
        var BlockCipher = C_lib.BlockCipher = Cipher.extend({
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: function reset() {
            Cipher.reset.call(this);
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) var modeCreator = mode.createEncryptor; else {
              var modeCreator = mode.createDecryptor;
              this._minBufferSize = 1;
            }
            if (this._mode && this._mode.__creator == modeCreator) this._mode.init(this, iv && iv.words); else {
              this._mode = modeCreator.call(mode, this, iv && iv.words);
              this._mode.__creator = modeCreator;
            }
          },
          _doProcessBlock: function _doProcessBlock(words, offset) {
            this._mode.processBlock(words, offset);
          },
          _doFinalize: function _doFinalize() {
            var padding = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              padding.pad(this._data, this.blockSize);
              var finalProcessedBlocks = this._process(true);
            } else {
              var finalProcessedBlocks = this._process(true);
              padding.unpad(finalProcessedBlocks);
            }
            return finalProcessedBlocks;
          },
          blockSize: 4
        });
        var CipherParams = C_lib.CipherParams = Base.extend({
          init: function init(cipherParams) {
            this.mixIn(cipherParams);
          },
          toString: function toString(formatter) {
            return (formatter || this.formatter).stringify(this);
          }
        });
        var C_format = C.format = {};
        var OpenSSLFormatter = C_format.OpenSSL = {
          stringify: function stringify(cipherParams) {
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;
            if (salt) var wordArray = WordArray.create([ 1398893684, 1701076831 ]).concat(salt).concat(ciphertext); else var wordArray = ciphertext;
            return wordArray.toString(Base64);
          },
          parse: function parse(openSSLStr) {
            var ciphertext = Base64.parse(openSSLStr);
            var ciphertextWords = ciphertext.words;
            if (1398893684 == ciphertextWords[0] && 1701076831 == ciphertextWords[1]) {
              var salt = WordArray.create(ciphertextWords.slice(2, 4));
              ciphertextWords.splice(0, 4);
              ciphertext.sigBytes -= 16;
            }
            return CipherParams.create({
              ciphertext: ciphertext,
              salt: salt
            });
          }
        };
        var SerializableCipher = C_lib.SerializableCipher = Base.extend({
          cfg: Base.extend({
            format: OpenSSLFormatter
          }),
          encrypt: function encrypt(cipher, message, key, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message);
            var cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext: ciphertext,
              key: key,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          },
          decrypt: function decrypt(cipher, ciphertext, key, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          },
          _parse: function _parse(ciphertext, format) {
            return "string" == typeof ciphertext ? format.parse(ciphertext, this) : ciphertext;
          }
        });
        var C_kdf = C.kdf = {};
        var OpenSSLKdf = C_kdf.OpenSSL = {
          execute: function execute(password, keySize, ivSize, salt) {
            salt || (salt = WordArray.random(8));
            var key = EvpKDF.create({
              keySize: keySize + ivSize
            }).compute(password, salt);
            var iv = WordArray.create(key.words.slice(keySize), 4 * ivSize);
            key.sigBytes = 4 * keySize;
            return CipherParams.create({
              key: key,
              iv: iv,
              salt: salt
            });
          }
        };
        var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          encrypt: function encrypt(cipher, message, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
            ciphertext.mixIn(derivedParams);
            return ciphertext;
          },
          decrypt: function decrypt(cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }
        });
      }();
      CryptoJS.mode.CFB = function() {
        var CFB = CryptoJS.lib.BlockCipherMode.extend();
        CFB.Encryptor = CFB.extend({
          processBlock: function processBlock(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = words.slice(offset, offset + blockSize);
          }
        });
        CFB.Decryptor = CFB.extend({
          processBlock: function processBlock(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var thisBlock = words.slice(offset, offset + blockSize);
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = thisBlock;
          }
        });
        function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
          var iv = this._iv;
          if (iv) {
            var keystream = iv.slice(0);
            this._iv = void 0;
          } else var keystream = this._prevBlock;
          cipher.encryptBlock(keystream, 0);
          for (var i = 0; i < blockSize; i++) words[offset + i] ^= keystream[i];
        }
        return CFB;
      }();
      CryptoJS.mode.ECB = function() {
        var ECB = CryptoJS.lib.BlockCipherMode.extend();
        ECB.Encryptor = ECB.extend({
          processBlock: function processBlock(words, offset) {
            this._cipher.encryptBlock(words, offset);
          }
        });
        ECB.Decryptor = ECB.extend({
          processBlock: function processBlock(words, offset) {
            this._cipher.decryptBlock(words, offset);
          }
        });
        return ECB;
      }();
      CryptoJS.pad.AnsiX923 = {
        pad: function pad(data, blockSize) {
          var dataSigBytes = data.sigBytes;
          var blockSizeBytes = 4 * blockSize;
          var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
          var lastBytePos = dataSigBytes + nPaddingBytes - 1;
          data.clamp();
          data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
          data.sigBytes += nPaddingBytes;
        },
        unpad: function unpad(data) {
          var nPaddingBytes = 255 & data.words[data.sigBytes - 1 >>> 2];
          data.sigBytes -= nPaddingBytes;
        }
      };
      CryptoJS.pad.Iso10126 = {
        pad: function pad(data, blockSize) {
          var blockSizeBytes = 4 * blockSize;
          var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
          data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([ nPaddingBytes << 24 ], 1));
        },
        unpad: function unpad(data) {
          var nPaddingBytes = 255 & data.words[data.sigBytes - 1 >>> 2];
          data.sigBytes -= nPaddingBytes;
        }
      };
      CryptoJS.pad.Iso97971 = {
        pad: function pad(data, blockSize) {
          data.concat(CryptoJS.lib.WordArray.create([ 2147483648 ], 1));
          CryptoJS.pad.ZeroPadding.pad(data, blockSize);
        },
        unpad: function unpad(data) {
          CryptoJS.pad.ZeroPadding.unpad(data);
          data.sigBytes--;
        }
      };
      CryptoJS.mode.OFB = function() {
        var OFB = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = OFB.Encryptor = OFB.extend({
          processBlock: function processBlock(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var keystream = this._keystream;
            if (iv) {
              keystream = this._keystream = iv.slice(0);
              this._iv = void 0;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i = 0; i < blockSize; i++) words[offset + i] ^= keystream[i];
          }
        });
        OFB.Decryptor = Encryptor;
        return OFB;
      }();
      CryptoJS.pad.NoPadding = {
        pad: function pad() {},
        unpad: function unpad() {}
      };
      (function(undefined) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var CipherParams = C_lib.CipherParams;
        var C_enc = C.enc;
        var Hex = C_enc.Hex;
        var C_format = C.format;
        var HexFormatter = C_format.Hex = {
          stringify: function stringify(cipherParams) {
            return cipherParams.ciphertext.toString(Hex);
          },
          parse: function parse(input) {
            var ciphertext = Hex.parse(input);
            return CipherParams.create({
              ciphertext: ciphertext
            });
          }
        };
      })();
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX_0 = [];
        var SUB_MIX_1 = [];
        var SUB_MIX_2 = [];
        var SUB_MIX_3 = [];
        var INV_SUB_MIX_0 = [];
        var INV_SUB_MIX_1 = [];
        var INV_SUB_MIX_2 = [];
        var INV_SUB_MIX_3 = [];
        (function() {
          var d = [];
          for (var i = 0; i < 256; i++) d[i] = i < 128 ? i << 1 : i << 1 ^ 283;
          var x = 0;
          var xi = 0;
          for (var i = 0; i < 256; i++) {
            var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
            sx = sx >>> 8 ^ 255 & sx ^ 99;
            SBOX[x] = sx;
            INV_SBOX[sx] = x;
            var x2 = d[x];
            var x4 = d[x2];
            var x8 = d[x4];
            var t = 257 * d[sx] ^ 16843008 * sx;
            SUB_MIX_0[x] = t << 24 | t >>> 8;
            SUB_MIX_1[x] = t << 16 | t >>> 16;
            SUB_MIX_2[x] = t << 8 | t >>> 24;
            SUB_MIX_3[x] = t;
            var t = 16843009 * x8 ^ 65537 * x4 ^ 257 * x2 ^ 16843008 * x;
            INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;
            INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;
            INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;
            INV_SUB_MIX_3[sx] = t;
            if (x) {
              x = x2 ^ d[d[d[x8 ^ x2]]];
              xi ^= d[d[xi]];
            } else x = xi = 1;
          }
        })();
        var RCON = [ 0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54 ];
        var AES = C_algo.AES = BlockCipher.extend({
          _doReset: function _doReset() {
            if (this._nRounds && this._keyPriorReset === this._key) return;
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            var nRounds = this._nRounds = keySize + 6;
            var ksRows = 4 * (nRounds + 1);
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) if (ksRow < keySize) keySchedule[ksRow] = keyWords[ksRow]; else {
              var t = keySchedule[ksRow - 1];
              if (ksRow % keySize) keySize > 6 && ksRow % keySize == 4 && (t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[255 & t]); else {
                t = t << 8 | t >>> 24;
                t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[255 & t];
                t ^= RCON[ksRow / keySize | 0] << 24;
              }
              keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
            }
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              var ksRow = ksRows - invKsRow;
              if (invKsRow % 4) var t = keySchedule[ksRow]; else var t = keySchedule[ksRow - 4];
              invKeySchedule[invKsRow] = invKsRow < 4 || ksRow <= 4 ? t : INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[t >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[255 & t]];
            }
          },
          encryptBlock: function encryptBlock(M, offset) {
            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          },
          decryptBlock: function decryptBlock(M, offset) {
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
          },
          _doCryptBlock: function _doCryptBlock(M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
            var nRounds = this._nRounds;
            var s0 = M[offset] ^ keySchedule[0];
            var s1 = M[offset + 1] ^ keySchedule[1];
            var s2 = M[offset + 2] ^ keySchedule[2];
            var s3 = M[offset + 3] ^ keySchedule[3];
            var ksRow = 4;
            for (var round = 1; round < nRounds; round++) {
              var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[s1 >>> 16 & 255] ^ SUB_MIX_2[s2 >>> 8 & 255] ^ SUB_MIX_3[255 & s3] ^ keySchedule[ksRow++];
              var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[s2 >>> 16 & 255] ^ SUB_MIX_2[s3 >>> 8 & 255] ^ SUB_MIX_3[255 & s0] ^ keySchedule[ksRow++];
              var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[s3 >>> 16 & 255] ^ SUB_MIX_2[s0 >>> 8 & 255] ^ SUB_MIX_3[255 & s1] ^ keySchedule[ksRow++];
              var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[s0 >>> 16 & 255] ^ SUB_MIX_2[s1 >>> 8 & 255] ^ SUB_MIX_3[255 & s2] ^ keySchedule[ksRow++];
              s0 = t0;
              s1 = t1;
              s2 = t2;
              s3 = t3;
            }
            var t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 | SBOX[s2 >>> 8 & 255] << 8 | SBOX[255 & s3]) ^ keySchedule[ksRow++];
            var t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 255] << 16 | SBOX[s3 >>> 8 & 255] << 8 | SBOX[255 & s0]) ^ keySchedule[ksRow++];
            var t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 255] << 16 | SBOX[s0 >>> 8 & 255] << 8 | SBOX[255 & s1]) ^ keySchedule[ksRow++];
            var t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 | SBOX[s1 >>> 8 & 255] << 8 | SBOX[255 & s2]) ^ keySchedule[ksRow++];
            M[offset] = t0;
            M[offset + 1] = t1;
            M[offset + 2] = t2;
            M[offset + 3] = t3;
          },
          keySize: 8
        });
        C.AES = BlockCipher._createHelper(AES);
      })();
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var PC1 = [ 57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4 ];
        var PC2 = [ 14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32 ];
        var BIT_SHIFTS = [ 1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28 ];
        var SBOX_P = [ {
          0: 8421888,
          268435456: 32768,
          536870912: 8421378,
          805306368: 2,
          1073741824: 512,
          1342177280: 8421890,
          1610612736: 8389122,
          1879048192: 8388608,
          2147483648: 514,
          2415919104: 8389120,
          2684354560: 33280,
          2952790016: 8421376,
          3221225472: 32770,
          3489660928: 8388610,
          3758096384: 0,
          4026531840: 33282,
          134217728: 0,
          402653184: 8421890,
          671088640: 33282,
          939524096: 32768,
          1207959552: 8421888,
          1476395008: 512,
          1744830464: 8421378,
          2013265920: 2,
          2281701376: 8389120,
          2550136832: 33280,
          2818572288: 8421376,
          3087007744: 8389122,
          3355443200: 8388610,
          3623878656: 32770,
          3892314112: 514,
          4160749568: 8388608,
          1: 32768,
          268435457: 2,
          536870913: 8421888,
          805306369: 8388608,
          1073741825: 8421378,
          1342177281: 33280,
          1610612737: 512,
          1879048193: 8389122,
          2147483649: 8421890,
          2415919105: 8421376,
          2684354561: 8388610,
          2952790017: 33282,
          3221225473: 514,
          3489660929: 8389120,
          3758096385: 32770,
          4026531841: 0,
          134217729: 8421890,
          402653185: 8421376,
          671088641: 8388608,
          939524097: 512,
          1207959553: 32768,
          1476395009: 8388610,
          1744830465: 2,
          2013265921: 33282,
          2281701377: 32770,
          2550136833: 8389122,
          2818572289: 514,
          3087007745: 8421888,
          3355443201: 8389120,
          3623878657: 0,
          3892314113: 33280,
          4160749569: 8421378
        }, {
          0: 1074282512,
          16777216: 16384,
          33554432: 524288,
          50331648: 1074266128,
          67108864: 1073741840,
          83886080: 1074282496,
          100663296: 1073758208,
          117440512: 16,
          134217728: 540672,
          150994944: 1073758224,
          167772160: 1073741824,
          184549376: 540688,
          201326592: 524304,
          218103808: 0,
          234881024: 16400,
          251658240: 1074266112,
          8388608: 1073758208,
          25165824: 540688,
          41943040: 16,
          58720256: 1073758224,
          75497472: 1074282512,
          92274688: 1073741824,
          109051904: 524288,
          125829120: 1074266128,
          142606336: 524304,
          159383552: 0,
          176160768: 16384,
          192937984: 1074266112,
          209715200: 1073741840,
          226492416: 540672,
          243269632: 1074282496,
          260046848: 16400,
          268435456: 0,
          285212672: 1074266128,
          301989888: 1073758224,
          318767104: 1074282496,
          335544320: 1074266112,
          352321536: 16,
          369098752: 540688,
          385875968: 16384,
          402653184: 16400,
          419430400: 524288,
          436207616: 524304,
          452984832: 1073741840,
          469762048: 540672,
          486539264: 1073758208,
          503316480: 1073741824,
          520093696: 1074282512,
          276824064: 540688,
          293601280: 524288,
          310378496: 1074266112,
          327155712: 16384,
          343932928: 1073758208,
          360710144: 1074282512,
          377487360: 16,
          394264576: 1073741824,
          411041792: 1074282496,
          427819008: 1073741840,
          444596224: 1073758224,
          461373440: 524304,
          478150656: 0,
          494927872: 16400,
          511705088: 1074266128,
          528482304: 540672
        }, {
          0: 260,
          1048576: 0,
          2097152: 67109120,
          3145728: 65796,
          4194304: 65540,
          5242880: 67108868,
          6291456: 67174660,
          7340032: 67174400,
          8388608: 67108864,
          9437184: 67174656,
          10485760: 65792,
          11534336: 67174404,
          12582912: 67109124,
          13631488: 65536,
          14680064: 4,
          15728640: 256,
          524288: 67174656,
          1572864: 67174404,
          2621440: 0,
          3670016: 67109120,
          4718592: 67108868,
          5767168: 65536,
          6815744: 65540,
          7864320: 260,
          8912896: 4,
          9961472: 256,
          11010048: 67174400,
          12058624: 65796,
          13107200: 65792,
          14155776: 67109124,
          15204352: 67174660,
          16252928: 67108864,
          16777216: 67174656,
          17825792: 65540,
          18874368: 65536,
          19922944: 67109120,
          20971520: 256,
          22020096: 67174660,
          23068672: 67108868,
          24117248: 0,
          25165824: 67109124,
          26214400: 67108864,
          27262976: 4,
          28311552: 65792,
          29360128: 67174400,
          30408704: 260,
          31457280: 65796,
          32505856: 67174404,
          17301504: 67108864,
          18350080: 260,
          19398656: 67174656,
          20447232: 0,
          21495808: 65540,
          22544384: 67109120,
          23592960: 256,
          24641536: 67174404,
          25690112: 65536,
          26738688: 67174660,
          27787264: 65796,
          28835840: 67108868,
          29884416: 67109124,
          30932992: 67174400,
          31981568: 4,
          33030144: 65792
        }, {
          0: 2151682048,
          65536: 2147487808,
          131072: 4198464,
          196608: 2151677952,
          262144: 0,
          327680: 4198400,
          393216: 2147483712,
          458752: 4194368,
          524288: 2147483648,
          589824: 4194304,
          655360: 64,
          720896: 2147487744,
          786432: 2151678016,
          851968: 4160,
          917504: 4096,
          983040: 2151682112,
          32768: 2147487808,
          98304: 64,
          163840: 2151678016,
          229376: 2147487744,
          294912: 4198400,
          360448: 2151682112,
          425984: 0,
          491520: 2151677952,
          557056: 4096,
          622592: 2151682048,
          688128: 4194304,
          753664: 4160,
          819200: 2147483648,
          884736: 4194368,
          950272: 4198464,
          1015808: 2147483712,
          1048576: 4194368,
          1114112: 4198400,
          1179648: 2147483712,
          1245184: 0,
          1310720: 4160,
          1376256: 2151678016,
          1441792: 2151682048,
          1507328: 2147487808,
          1572864: 2151682112,
          1638400: 2147483648,
          1703936: 2151677952,
          1769472: 4198464,
          1835008: 2147487744,
          1900544: 4194304,
          1966080: 64,
          2031616: 4096,
          1081344: 2151677952,
          1146880: 2151682112,
          1212416: 0,
          1277952: 4198400,
          1343488: 4194368,
          1409024: 2147483648,
          1474560: 2147487808,
          1540096: 64,
          1605632: 2147483712,
          1671168: 4096,
          1736704: 2147487744,
          1802240: 2151678016,
          1867776: 4160,
          1933312: 2151682048,
          1998848: 4194304,
          2064384: 4198464
        }, {
          0: 128,
          4096: 17039360,
          8192: 262144,
          12288: 536870912,
          16384: 537133184,
          20480: 16777344,
          24576: 553648256,
          28672: 262272,
          32768: 16777216,
          36864: 537133056,
          40960: 536871040,
          45056: 553910400,
          49152: 553910272,
          53248: 0,
          57344: 17039488,
          61440: 553648128,
          2048: 17039488,
          6144: 553648256,
          10240: 128,
          14336: 17039360,
          18432: 262144,
          22528: 537133184,
          26624: 553910272,
          30720: 536870912,
          34816: 537133056,
          38912: 0,
          43008: 553910400,
          47104: 16777344,
          51200: 536871040,
          55296: 553648128,
          59392: 16777216,
          63488: 262272,
          65536: 262144,
          69632: 128,
          73728: 536870912,
          77824: 553648256,
          81920: 16777344,
          86016: 553910272,
          90112: 537133184,
          94208: 16777216,
          98304: 553910400,
          102400: 553648128,
          106496: 17039360,
          110592: 537133056,
          114688: 262272,
          118784: 536871040,
          122880: 0,
          126976: 17039488,
          67584: 553648256,
          71680: 16777216,
          75776: 17039360,
          79872: 537133184,
          83968: 536870912,
          88064: 17039488,
          92160: 128,
          96256: 553910272,
          100352: 262272,
          104448: 553910400,
          108544: 0,
          112640: 553648128,
          116736: 16777344,
          120832: 262144,
          124928: 537133056,
          129024: 536871040
        }, {
          0: 268435464,
          256: 8192,
          512: 270532608,
          768: 270540808,
          1024: 268443648,
          1280: 2097152,
          1536: 2097160,
          1792: 268435456,
          2048: 0,
          2304: 268443656,
          2560: 2105344,
          2816: 8,
          3072: 270532616,
          3328: 2105352,
          3584: 8200,
          3840: 270540800,
          128: 270532608,
          384: 270540808,
          640: 8,
          896: 2097152,
          1152: 2105352,
          1408: 268435464,
          1664: 268443648,
          1920: 8200,
          2176: 2097160,
          2432: 8192,
          2688: 268443656,
          2944: 270532616,
          3200: 0,
          3456: 270540800,
          3712: 2105344,
          3968: 268435456,
          4096: 268443648,
          4352: 270532616,
          4608: 270540808,
          4864: 8200,
          5120: 2097152,
          5376: 268435456,
          5632: 268435464,
          5888: 2105344,
          6144: 2105352,
          6400: 0,
          6656: 8,
          6912: 270532608,
          7168: 8192,
          7424: 268443656,
          7680: 270540800,
          7936: 2097160,
          4224: 8,
          4480: 2105344,
          4736: 2097152,
          4992: 268435464,
          5248: 268443648,
          5504: 8200,
          5760: 270540808,
          6016: 270532608,
          6272: 270540800,
          6528: 270532616,
          6784: 8192,
          7040: 2105352,
          7296: 2097160,
          7552: 0,
          7808: 268435456,
          8064: 268443656
        }, {
          0: 1048576,
          16: 33555457,
          32: 1024,
          48: 1049601,
          64: 34604033,
          80: 0,
          96: 1,
          112: 34603009,
          128: 33555456,
          144: 1048577,
          160: 33554433,
          176: 34604032,
          192: 34603008,
          208: 1025,
          224: 1049600,
          240: 33554432,
          8: 34603009,
          24: 0,
          40: 33555457,
          56: 34604032,
          72: 1048576,
          88: 33554433,
          104: 33554432,
          120: 1025,
          136: 1049601,
          152: 33555456,
          168: 34603008,
          184: 1048577,
          200: 1024,
          216: 34604033,
          232: 1,
          248: 1049600,
          256: 33554432,
          272: 1048576,
          288: 33555457,
          304: 34603009,
          320: 1048577,
          336: 33555456,
          352: 34604032,
          368: 1049601,
          384: 1025,
          400: 34604033,
          416: 1049600,
          432: 1,
          448: 0,
          464: 34603008,
          480: 33554433,
          496: 1024,
          264: 1049600,
          280: 33555457,
          296: 34603009,
          312: 1,
          328: 33554432,
          344: 1048576,
          360: 1025,
          376: 34604032,
          392: 33554433,
          408: 34603008,
          424: 0,
          440: 34604033,
          456: 1049601,
          472: 1024,
          488: 33555456,
          504: 1048577
        }, {
          0: 134219808,
          1: 131072,
          2: 134217728,
          3: 32,
          4: 131104,
          5: 134350880,
          6: 134350848,
          7: 2048,
          8: 134348800,
          9: 134219776,
          10: 133120,
          11: 134348832,
          12: 2080,
          13: 0,
          14: 134217760,
          15: 133152,
          2147483648: 2048,
          2147483649: 134350880,
          2147483650: 134219808,
          2147483651: 134217728,
          2147483652: 134348800,
          2147483653: 133120,
          2147483654: 133152,
          2147483655: 32,
          2147483656: 134217760,
          2147483657: 2080,
          2147483658: 131104,
          2147483659: 134350848,
          2147483660: 0,
          2147483661: 134348832,
          2147483662: 134219776,
          2147483663: 131072,
          16: 133152,
          17: 134350848,
          18: 32,
          19: 2048,
          20: 134219776,
          21: 134217760,
          22: 134348832,
          23: 131072,
          24: 0,
          25: 131104,
          26: 134348800,
          27: 134219808,
          28: 134350880,
          29: 133120,
          30: 2080,
          31: 134217728,
          2147483664: 131072,
          2147483665: 2048,
          2147483666: 134348832,
          2147483667: 133152,
          2147483668: 32,
          2147483669: 134348800,
          2147483670: 134217728,
          2147483671: 134219808,
          2147483672: 134350880,
          2147483673: 134217760,
          2147483674: 134219776,
          2147483675: 0,
          2147483676: 133120,
          2147483677: 2080,
          2147483678: 131104,
          2147483679: 134350848
        } ];
        var SBOX_MASK = [ 4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679 ];
        var DES = C_algo.DES = BlockCipher.extend({
          _doReset: function _doReset() {
            var key = this._key;
            var keyWords = key.words;
            var keyBits = [];
            for (var i = 0; i < 56; i++) {
              var keyBitPos = PC1[i] - 1;
              keyBits[i] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
            }
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
              var subKey = subKeys[nSubKey] = [];
              var bitShift = BIT_SHIFTS[nSubKey];
              for (var i = 0; i < 24; i++) {
                subKey[i / 6 | 0] |= keyBits[(PC2[i] - 1 + bitShift) % 28] << 31 - i % 6;
                subKey[4 + (i / 6 | 0)] |= keyBits[28 + (PC2[i + 24] - 1 + bitShift) % 28] << 31 - i % 6;
              }
              subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
              for (var i = 1; i < 7; i++) subKey[i] = subKey[i] >>> 4 * (i - 1) + 3;
              subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
            }
            var invSubKeys = this._invSubKeys = [];
            for (var i = 0; i < 16; i++) invSubKeys[i] = subKeys[15 - i];
          },
          encryptBlock: function encryptBlock(M, offset) {
            this._doCryptBlock(M, offset, this._subKeys);
          },
          decryptBlock: function decryptBlock(M, offset) {
            this._doCryptBlock(M, offset, this._invSubKeys);
          },
          _doCryptBlock: function _doCryptBlock(M, offset, subKeys) {
            this._lBlock = M[offset];
            this._rBlock = M[offset + 1];
            exchangeLR.call(this, 4, 252645135);
            exchangeLR.call(this, 16, 65535);
            exchangeRL.call(this, 2, 858993459);
            exchangeRL.call(this, 8, 16711935);
            exchangeLR.call(this, 1, 1431655765);
            for (var round = 0; round < 16; round++) {
              var subKey = subKeys[round];
              var lBlock = this._lBlock;
              var rBlock = this._rBlock;
              var f = 0;
              for (var i = 0; i < 8; i++) f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
              this._lBlock = rBlock;
              this._rBlock = lBlock ^ f;
            }
            var t = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t;
            exchangeLR.call(this, 1, 1431655765);
            exchangeRL.call(this, 8, 16711935);
            exchangeRL.call(this, 2, 858993459);
            exchangeLR.call(this, 16, 65535);
            exchangeLR.call(this, 4, 252645135);
            M[offset] = this._lBlock;
            M[offset + 1] = this._rBlock;
          },
          keySize: 2,
          ivSize: 2,
          blockSize: 2
        });
        function exchangeLR(offset, mask) {
          var t = (this._lBlock >>> offset ^ this._rBlock) & mask;
          this._rBlock ^= t;
          this._lBlock ^= t << offset;
        }
        function exchangeRL(offset, mask) {
          var t = (this._rBlock >>> offset ^ this._lBlock) & mask;
          this._lBlock ^= t;
          this._rBlock ^= t << offset;
        }
        C.DES = BlockCipher._createHelper(DES);
        var TripleDES = C_algo.TripleDES = BlockCipher.extend({
          _doReset: function _doReset() {
            var key = this._key;
            var keyWords = key.words;
            this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));
            this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));
            this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));
          },
          encryptBlock: function encryptBlock(M, offset) {
            this._des1.encryptBlock(M, offset);
            this._des2.decryptBlock(M, offset);
            this._des3.encryptBlock(M, offset);
          },
          decryptBlock: function decryptBlock(M, offset) {
            this._des3.decryptBlock(M, offset);
            this._des2.encryptBlock(M, offset);
            this._des1.decryptBlock(M, offset);
          },
          keySize: 6,
          ivSize: 2,
          blockSize: 2
        });
        C.TripleDES = BlockCipher._createHelper(TripleDES);
      })();
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var RC4 = C_algo.RC4 = StreamCipher.extend({
          _doReset: function _doReset() {
            var key = this._key;
            var keyWords = key.words;
            var keySigBytes = key.sigBytes;
            var S = this._S = [];
            for (var i = 0; i < 256; i++) S[i] = i;
            for (var i = 0, j = 0; i < 256; i++) {
              var keyByteIndex = i % keySigBytes;
              var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
              j = (j + S[i] + keyByte) % 256;
              var t = S[i];
              S[i] = S[j];
              S[j] = t;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function _doProcessBlock(M, offset) {
            M[offset] ^= generateKeystreamWord.call(this);
          },
          keySize: 8,
          ivSize: 0
        });
        function generateKeystreamWord() {
          var S = this._S;
          var i = this._i;
          var j = this._j;
          var keystreamWord = 0;
          for (var n = 0; n < 4; n++) {
            i = (i + 1) % 256;
            j = (j + S[i]) % 256;
            var t = S[i];
            S[i] = S[j];
            S[j] = t;
            keystreamWord |= S[(S[i] + S[j]) % 256] << 24 - 8 * n;
          }
          this._i = i;
          this._j = j;
          return keystreamWord;
        }
        C.RC4 = StreamCipher._createHelper(RC4);
        var RC4Drop = C_algo.RC4Drop = RC4.extend({
          cfg: RC4.cfg.extend({
            drop: 192
          }),
          _doReset: function _doReset() {
            RC4._doReset.call(this);
            for (var i = this.cfg.drop; i > 0; i--) generateKeystreamWord.call(this);
          }
        });
        C.RC4Drop = StreamCipher._createHelper(RC4Drop);
      })();
      CryptoJS.mode.CTRGladman = function() {
        var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
        function incWord(word) {
          if (255 === (word >> 24 & 255)) {
            var b1 = word >> 16 & 255;
            var b2 = word >> 8 & 255;
            var b3 = 255 & word;
            if (255 === b1) {
              b1 = 0;
              if (255 === b2) {
                b2 = 0;
                255 === b3 ? b3 = 0 : ++b3;
              } else ++b2;
            } else ++b1;
            word = 0;
            word += b1 << 16;
            word += b2 << 8;
            word += b3;
          } else word += 1 << 24;
          return word;
        }
        function incCounter(counter) {
          0 === (counter[0] = incWord(counter[0])) && (counter[1] = incWord(counter[1]));
          return counter;
        }
        var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
          processBlock: function processBlock(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            incCounter(counter);
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            for (var i = 0; i < blockSize; i++) words[offset + i] ^= keystream[i];
          }
        });
        CTRGladman.Decryptor = Encryptor;
        return CTRGladman;
      }();
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S = [];
        var C_ = [];
        var G = [];
        var Rabbit = C_algo.Rabbit = StreamCipher.extend({
          _doReset: function _doReset() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            for (var i = 0; i < 4; i++) K[i] = 16711935 & (K[i] << 8 | K[i] >>> 24) | 4278255360 & (K[i] << 24 | K[i] >>> 8);
            var X = this._X = [ K[0], K[3] << 16 | K[2] >>> 16, K[1], K[0] << 16 | K[3] >>> 16, K[2], K[1] << 16 | K[0] >>> 16, K[3], K[2] << 16 | K[1] >>> 16 ];
            var C = this._C = [ K[2] << 16 | K[2] >>> 16, 4294901760 & K[0] | 65535 & K[1], K[3] << 16 | K[3] >>> 16, 4294901760 & K[1] | 65535 & K[2], K[0] << 16 | K[0] >>> 16, 4294901760 & K[2] | 65535 & K[3], K[1] << 16 | K[1] >>> 16, 4294901760 & K[3] | 65535 & K[0] ];
            this._b = 0;
            for (var i = 0; i < 4; i++) nextState.call(this);
            for (var i = 0; i < 8; i++) C[i] ^= X[i + 4 & 7];
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = 16711935 & (IV_0 << 8 | IV_0 >>> 24) | 4278255360 & (IV_0 << 24 | IV_0 >>> 8);
              var i2 = 16711935 & (IV_1 << 8 | IV_1 >>> 24) | 4278255360 & (IV_1 << 24 | IV_1 >>> 8);
              var i1 = i0 >>> 16 | 4294901760 & i2;
              var i3 = i2 << 16 | 65535 & i0;
              C[0] ^= i0;
              C[1] ^= i1;
              C[2] ^= i2;
              C[3] ^= i3;
              C[4] ^= i0;
              C[5] ^= i1;
              C[6] ^= i2;
              C[7] ^= i3;
              for (var i = 0; i < 4; i++) nextState.call(this);
            }
          },
          _doProcessBlock: function _doProcessBlock(M, offset) {
            var X = this._X;
            nextState.call(this);
            S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i = 0; i < 4; i++) {
              S[i] = 16711935 & (S[i] << 8 | S[i] >>> 24) | 4278255360 & (S[i] << 24 | S[i] >>> 8);
              M[offset + i] ^= S[i];
            }
          },
          blockSize: 4,
          ivSize: 2
        });
        function nextState() {
          var X = this._X;
          var C = this._C;
          for (var i = 0; i < 8; i++) C_[i] = C[i];
          C[0] = C[0] + 1295307597 + this._b | 0;
          C[1] = C[1] + 3545052371 + (C[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C[2] = C[2] + 886263092 + (C[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C[3] = C[3] + 1295307597 + (C[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C[4] = C[4] + 3545052371 + (C[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C[5] = C[5] + 886263092 + (C[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C[6] = C[6] + 1295307597 + (C[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C[7] = C[7] + 3545052371 + (C[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i = 0; i < 8; i++) {
            var gx = X[i] + C[i];
            var ga = 65535 & gx;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((4294901760 & gx) * gx | 0) + ((65535 & gx) * gx | 0);
            G[i] = gh ^ gl;
          }
          X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        C.Rabbit = StreamCipher._createHelper(Rabbit);
      })();
      CryptoJS.mode.CTR = function() {
        var CTR = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = CTR.Encryptor = CTR.extend({
          processBlock: function processBlock(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
            for (var i = 0; i < blockSize; i++) words[offset + i] ^= keystream[i];
          }
        });
        CTR.Decryptor = Encryptor;
        return CTR;
      }();
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S = [];
        var C_ = [];
        var G = [];
        var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
          _doReset: function _doReset() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            var X = this._X = [ K[0], K[3] << 16 | K[2] >>> 16, K[1], K[0] << 16 | K[3] >>> 16, K[2], K[1] << 16 | K[0] >>> 16, K[3], K[2] << 16 | K[1] >>> 16 ];
            var C = this._C = [ K[2] << 16 | K[2] >>> 16, 4294901760 & K[0] | 65535 & K[1], K[3] << 16 | K[3] >>> 16, 4294901760 & K[1] | 65535 & K[2], K[0] << 16 | K[0] >>> 16, 4294901760 & K[2] | 65535 & K[3], K[1] << 16 | K[1] >>> 16, 4294901760 & K[3] | 65535 & K[0] ];
            this._b = 0;
            for (var i = 0; i < 4; i++) nextState.call(this);
            for (var i = 0; i < 8; i++) C[i] ^= X[i + 4 & 7];
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = 16711935 & (IV_0 << 8 | IV_0 >>> 24) | 4278255360 & (IV_0 << 24 | IV_0 >>> 8);
              var i2 = 16711935 & (IV_1 << 8 | IV_1 >>> 24) | 4278255360 & (IV_1 << 24 | IV_1 >>> 8);
              var i1 = i0 >>> 16 | 4294901760 & i2;
              var i3 = i2 << 16 | 65535 & i0;
              C[0] ^= i0;
              C[1] ^= i1;
              C[2] ^= i2;
              C[3] ^= i3;
              C[4] ^= i0;
              C[5] ^= i1;
              C[6] ^= i2;
              C[7] ^= i3;
              for (var i = 0; i < 4; i++) nextState.call(this);
            }
          },
          _doProcessBlock: function _doProcessBlock(M, offset) {
            var X = this._X;
            nextState.call(this);
            S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i = 0; i < 4; i++) {
              S[i] = 16711935 & (S[i] << 8 | S[i] >>> 24) | 4278255360 & (S[i] << 24 | S[i] >>> 8);
              M[offset + i] ^= S[i];
            }
          },
          blockSize: 4,
          ivSize: 2
        });
        function nextState() {
          var X = this._X;
          var C = this._C;
          for (var i = 0; i < 8; i++) C_[i] = C[i];
          C[0] = C[0] + 1295307597 + this._b | 0;
          C[1] = C[1] + 3545052371 + (C[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C[2] = C[2] + 886263092 + (C[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C[3] = C[3] + 1295307597 + (C[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C[4] = C[4] + 3545052371 + (C[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C[5] = C[5] + 886263092 + (C[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C[6] = C[6] + 1295307597 + (C[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C[7] = C[7] + 3545052371 + (C[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i = 0; i < 8; i++) {
            var gx = X[i] + C[i];
            var ga = 65535 & gx;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((4294901760 & gx) * gx | 0) + ((65535 & gx) * gx | 0);
            G[i] = gh ^ gl;
          }
          X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
      })();
      CryptoJS.pad.ZeroPadding = {
        pad: function pad(data, blockSize) {
          var blockSizeBytes = 4 * blockSize;
          data.clamp();
          data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
        },
        unpad: function unpad(data) {
          var dataWords = data.words;
          var i = data.sigBytes - 1;
          while (!(dataWords[i >>> 2] >>> 24 - i % 4 * 8 & 255)) i--;
          data.sigBytes = i + 1;
        }
      };
      return CryptoJS;
    });
    cc._RF.pop();
  }, {} ],
  "enc-base64": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "34b33oLo4JEnJCWiiOufAkL", "enc-base64");
    "use strict";
    (function(root, factory) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core")) : "function" === typeof define && define.amd ? define([ "./core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Base64 = C_enc.Base64 = {
          stringify: function stringify(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
              var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
              var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i + .75 * j < sigBytes; j++) base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) while (base64Chars.length % 4) base64Chars.push(paddingChar);
            return base64Chars.join("");
          },
          parse: function parse(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) reverseMap[map.charCodeAt(j)] = j;
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              -1 !== paddingIndex && (base64StrLength = paddingIndex);
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i = 0; i < base64StrLength; i++) if (i % 4) {
            var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
            var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
            words[nBytes >>> 2] |= (bits1 | bits2) << 24 - nBytes % 4 * 8;
            nBytes++;
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS.enc.Base64;
    });
    cc._RF.pop();
  }, {
    "./core": "core"
  } ],
  "enc-hex": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "1dc27PQNk5NeqZBPUSdvkAJ", "enc-hex");
    "use strict";
    (function(root, factory) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core")) : "function" === typeof define && define.amd ? define([ "./core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      return CryptoJS.enc.Hex;
    });
    cc._RF.pop();
  }, {
    "./core": "core"
  } ],
  "enc-latin1": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "4b58dH0LfFFmKX3tTjU8Oj9", "enc-latin1");
    "use strict";
    (function(root, factory) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core")) : "function" === typeof define && define.amd ? define([ "./core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      return CryptoJS.enc.Latin1;
    });
    cc._RF.pop();
  }, {
    "./core": "core"
  } ],
  "enc-utf16": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "b9ccbGKg7hCm7C+NCgYUtVV", "enc-utf16");
    "use strict";
    (function(root, factory) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core")) : "function" === typeof define && define.amd ? define([ "./core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
          stringify: function stringify(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i = 0; i < sigBytes; i += 2) {
              var codePoint = words[i >>> 2] >>> 16 - i % 4 * 8 & 65535;
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          parse: function parse(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i = 0; i < utf16StrLength; i++) words[i >>> 1] |= utf16Str.charCodeAt(i) << 16 - i % 2 * 16;
            return WordArray.create(words, 2 * utf16StrLength);
          }
        };
        C_enc.Utf16LE = {
          stringify: function stringify(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i = 0; i < sigBytes; i += 2) {
              var codePoint = swapEndian(words[i >>> 2] >>> 16 - i % 4 * 8 & 65535);
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          parse: function parse(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i = 0; i < utf16StrLength; i++) words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << 16 - i % 2 * 16);
            return WordArray.create(words, 2 * utf16StrLength);
          }
        };
        function swapEndian(word) {
          return word << 8 & 4278255360 | word >>> 8 & 16711935;
        }
      })();
      return CryptoJS.enc.Utf16;
    });
    cc._RF.pop();
  }, {
    "./core": "core"
  } ],
  "enc-utf8": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "9f8b89C9ihP5bpWniuVixJe", "enc-utf8");
    "use strict";
    (function(root, factory) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core")) : "function" === typeof define && define.amd ? define([ "./core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      return CryptoJS.enc.Utf8;
    });
    cc._RF.pop();
  }, {
    "./core": "core"
  } ],
  evpkdf: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "113b873c/tPf5jZuRsfZaYa", "evpkdf");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./sha1"), require("./hmac")) : "function" === typeof define && define.amd ? define([ "./core", "./sha1", "./hmac" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var MD5 = C_algo.MD5;
        var EvpKDF = C_algo.EvpKDF = Base.extend({
          cfg: Base.extend({
            keySize: 4,
            hasher: MD5,
            iterations: 1
          }),
          init: function init(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          compute: function compute(password, salt) {
            var cfg = this.cfg;
            var hasher = cfg.hasher.create();
            var derivedKey = WordArray.create();
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              block && hasher.update(block);
              var block = hasher.update(password).finalize(salt);
              hasher.reset();
              for (var i = 1; i < iterations; i++) {
                block = hasher.finalize(block);
                hasher.reset();
              }
              derivedKey.concat(block);
            }
            derivedKey.sigBytes = 4 * keySize;
            return derivedKey;
          }
        });
        C.EvpKDF = function(password, salt, cfg) {
          return EvpKDF.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.EvpKDF;
    });
    cc._RF.pop();
  }, {
    "./core": "core",
    "./hmac": "hmac",
    "./sha1": "sha1"
  } ],
  "format-hex": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "39c80WO3/RLAoKpj3oOi0cW", "format-hex");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./cipher-core")) : "function" === typeof define && define.amd ? define([ "./core", "./cipher-core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      (function(undefined) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var CipherParams = C_lib.CipherParams;
        var C_enc = C.enc;
        var Hex = C_enc.Hex;
        var C_format = C.format;
        var HexFormatter = C_format.Hex = {
          stringify: function stringify(cipherParams) {
            return cipherParams.ciphertext.toString(Hex);
          },
          parse: function parse(input) {
            var ciphertext = Hex.parse(input);
            return CipherParams.create({
              ciphertext: ciphertext
            });
          }
        };
      })();
      return CryptoJS.format.Hex;
    });
    cc._RF.pop();
  }, {
    "./cipher-core": "cipher-core",
    "./core": "core"
  } ],
  "format-openssl": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "65812lEIhpDNKzH+QD+kFLN", "format-openssl");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./cipher-core")) : "function" === typeof define && define.amd ? define([ "./core", "./cipher-core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      return CryptoJS.format.OpenSSL;
    });
    cc._RF.pop();
  }, {
    "./cipher-core": "cipher-core",
    "./core": "core"
  } ],
  "hmac-md5": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "c52a8iINOhPiZJ2nOAEsMe0", "hmac-md5");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./md5"), require("./hmac")) : "function" === typeof define && define.amd ? define([ "./core", "./md5", "./hmac" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      return CryptoJS.HmacMD5;
    });
    cc._RF.pop();
  }, {
    "./core": "core",
    "./hmac": "hmac",
    "./md5": "md5"
  } ],
  "hmac-ripemd160": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "acb8enjI1dJvIP2RjWOgFcw", "hmac-ripemd160");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./ripemd160"), require("./hmac")) : "function" === typeof define && define.amd ? define([ "./core", "./ripemd160", "./hmac" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      return CryptoJS.HmacRIPEMD160;
    });
    cc._RF.pop();
  }, {
    "./core": "core",
    "./hmac": "hmac",
    "./ripemd160": "ripemd160"
  } ],
  "hmac-sha1": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "bf852Y8WqRE5pyAFG9m9mHM", "hmac-sha1");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./sha1"), require("./hmac")) : "function" === typeof define && define.amd ? define([ "./core", "./sha1", "./hmac" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      return CryptoJS.HmacSHA1;
    });
    cc._RF.pop();
  }, {
    "./core": "core",
    "./hmac": "hmac",
    "./sha1": "sha1"
  } ],
  "hmac-sha224": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "4d3ef0QhWFG64KeDRXXIAe8", "hmac-sha224");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./sha256"), require("./sha224"), require("./hmac")) : "function" === typeof define && define.amd ? define([ "./core", "./sha256", "./sha224", "./hmac" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      return CryptoJS.HmacSHA224;
    });
    cc._RF.pop();
  }, {
    "./core": "core",
    "./hmac": "hmac",
    "./sha224": "sha224",
    "./sha256": "sha256"
  } ],
  "hmac-sha256": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "722d6oiAApMr4agtjhKqDgU", "hmac-sha256");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./sha256"), require("./hmac")) : "function" === typeof define && define.amd ? define([ "./core", "./sha256", "./hmac" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      return CryptoJS.HmacSHA256;
    });
    cc._RF.pop();
  }, {
    "./core": "core",
    "./hmac": "hmac",
    "./sha256": "sha256"
  } ],
  "hmac-sha384": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "4ddd9jUUAJMRp8VhJl3irvA", "hmac-sha384");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./x64-core"), require("./sha512"), require("./sha384"), require("./hmac")) : "function" === typeof define && define.amd ? define([ "./core", "./x64-core", "./sha512", "./sha384", "./hmac" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      return CryptoJS.HmacSHA384;
    });
    cc._RF.pop();
  }, {
    "./core": "core",
    "./hmac": "hmac",
    "./sha384": "sha384",
    "./sha512": "sha512",
    "./x64-core": "x64-core"
  } ],
  "hmac-sha3": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "1a534EFeVNLvI3qn7QBm0lC", "hmac-sha3");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./x64-core"), require("./sha3"), require("./hmac")) : "function" === typeof define && define.amd ? define([ "./core", "./x64-core", "./sha3", "./hmac" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      return CryptoJS.HmacSHA3;
    });
    cc._RF.pop();
  }, {
    "./core": "core",
    "./hmac": "hmac",
    "./sha3": "sha3",
    "./x64-core": "x64-core"
  } ],
  "hmac-sha512": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "0f002mjg7NE/Lw1T2HsvA+Y", "hmac-sha512");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./x64-core"), require("./sha512"), require("./hmac")) : "function" === typeof define && define.amd ? define([ "./core", "./x64-core", "./sha512", "./hmac" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      return CryptoJS.HmacSHA512;
    });
    cc._RF.pop();
  }, {
    "./core": "core",
    "./hmac": "hmac",
    "./sha512": "sha512",
    "./x64-core": "x64-core"
  } ],
  hmac: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "f6c22cyoiJMYbE7Kacwtxf5", "hmac");
    "use strict";
    (function(root, factory) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core")) : "function" === typeof define && define.amd ? define([ "./core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C.algo;
        var HMAC = C_algo.HMAC = Base.extend({
          init: function init(hasher, key) {
            hasher = this._hasher = new hasher.init();
            "string" == typeof key && (key = Utf8.parse(key));
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = 4 * hasherBlockSize;
            key.sigBytes > hasherBlockSizeBytes && (key = hasher.finalize(key));
            key.clamp();
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i = 0; i < hasherBlockSize; i++) {
              oKeyWords[i] ^= 1549556828;
              iKeyWords[i] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          reset: function reset() {
            var hasher = this._hasher;
            hasher.reset();
            hasher.update(this._iKey);
          },
          update: function update(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          finalize: function finalize(messageUpdate) {
            var hasher = this._hasher;
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac;
          }
        });
      })();
    });
    cc._RF.pop();
  }, {
    "./core": "core"
  } ],
  index: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "c078cqwugpOsoMRfzxvExZg", "index");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./x64-core"), require("./lib-typedarrays"), require("./enc-utf16"), require("./enc-base64"), require("./md5"), require("./sha1"), require("./sha256"), require("./sha224"), require("./sha512"), require("./sha384"), require("./sha3"), require("./ripemd160"), require("./hmac"), require("./pbkdf2"), require("./evpkdf"), require("./cipher-core"), require("./mode-cfb"), require("./mode-ctr"), require("./mode-ctr-gladman"), require("./mode-ofb"), require("./mode-ecb"), require("./pad-ansix923"), require("./pad-iso10126"), require("./pad-iso97971"), require("./pad-zeropadding"), require("./pad-nopadding"), require("./format-hex"), require("./aes"), require("./tripledes"), require("./rc4"), require("./rabbit"), require("./rabbit-legacy")) : "function" === typeof define && define.amd ? define([ "./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy" ], factory) : root.CryptoJS = factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      return CryptoJS;
    });
    cc._RF.pop();
  }, {
    "./aes": "aes",
    "./cipher-core": "cipher-core",
    "./core": "core",
    "./enc-base64": "enc-base64",
    "./enc-utf16": "enc-utf16",
    "./evpkdf": "evpkdf",
    "./format-hex": "format-hex",
    "./hmac": "hmac",
    "./lib-typedarrays": "lib-typedarrays",
    "./md5": "md5",
    "./mode-cfb": "mode-cfb",
    "./mode-ctr": "mode-ctr",
    "./mode-ctr-gladman": "mode-ctr-gladman",
    "./mode-ecb": "mode-ecb",
    "./mode-ofb": "mode-ofb",
    "./pad-ansix923": "pad-ansix923",
    "./pad-iso10126": "pad-iso10126",
    "./pad-iso97971": "pad-iso97971",
    "./pad-nopadding": "pad-nopadding",
    "./pad-zeropadding": "pad-zeropadding",
    "./pbkdf2": "pbkdf2",
    "./rabbit": "rabbit",
    "./rabbit-legacy": "rabbit-legacy",
    "./rc4": "rc4",
    "./ripemd160": "ripemd160",
    "./sha1": "sha1",
    "./sha224": "sha224",
    "./sha256": "sha256",
    "./sha3": "sha3",
    "./sha384": "sha384",
    "./sha512": "sha512",
    "./tripledes": "tripledes",
    "./x64-core": "x64-core"
  } ],
  "lib-typedarrays": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "afc22vSEDdC8aK6iogLo4QL", "lib-typedarrays");
    "use strict";
    (function(root, factory) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core")) : "function" === typeof define && define.amd ? define([ "./core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      (function() {
        if ("function" != typeof ArrayBuffer) return;
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var superInit = WordArray.init;
        var subInit = WordArray.init = function(typedArray) {
          typedArray instanceof ArrayBuffer && (typedArray = new Uint8Array(typedArray));
          (typedArray instanceof Int8Array || "undefined" !== typeof Uint8ClampedArray && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) && (typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength));
          if (typedArray instanceof Uint8Array) {
            var typedArrayByteLength = typedArray.byteLength;
            var words = [];
            for (var i = 0; i < typedArrayByteLength; i++) words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;
            superInit.call(this, words, typedArrayByteLength);
          } else superInit.apply(this, arguments);
        };
        subInit.prototype = WordArray;
      })();
      return CryptoJS.lib.WordArray;
    });
    cc._RF.pop();
  }, {
    "./core": "core"
  } ],
  md5: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "50204ZXJshB9bSltwjujVuZ", "md5");
    "use strict";
    (function(root, factory) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core")) : "function" === typeof define && define.amd ? define([ "./core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      (function(Math) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var T = [];
        (function() {
          for (var i = 0; i < 64; i++) T[i] = 4294967296 * Math.abs(Math.sin(i + 1)) | 0;
        })();
        var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function _doReset() {
            this._hash = new WordArray.init([ 1732584193, 4023233417, 2562383102, 271733878 ]);
          },
          _doProcessBlock: function _doProcessBlock(M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = 16711935 & (M_offset_i << 8 | M_offset_i >>> 24) | 4278255360 & (M_offset_i << 24 | M_offset_i >>> 8);
            }
            var H = this._hash.words;
            var M_offset_0 = M[offset + 0];
            var M_offset_1 = M[offset + 1];
            var M_offset_2 = M[offset + 2];
            var M_offset_3 = M[offset + 3];
            var M_offset_4 = M[offset + 4];
            var M_offset_5 = M[offset + 5];
            var M_offset_6 = M[offset + 6];
            var M_offset_7 = M[offset + 7];
            var M_offset_8 = M[offset + 8];
            var M_offset_9 = M[offset + 9];
            var M_offset_10 = M[offset + 10];
            var M_offset_11 = M[offset + 11];
            var M_offset_12 = M[offset + 12];
            var M_offset_13 = M[offset + 13];
            var M_offset_14 = M[offset + 14];
            var M_offset_15 = M[offset + 15];
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            a = FF(a, b, c, d, M_offset_0, 7, T[0]);
            d = FF(d, a, b, c, M_offset_1, 12, T[1]);
            c = FF(c, d, a, b, M_offset_2, 17, T[2]);
            b = FF(b, c, d, a, M_offset_3, 22, T[3]);
            a = FF(a, b, c, d, M_offset_4, 7, T[4]);
            d = FF(d, a, b, c, M_offset_5, 12, T[5]);
            c = FF(c, d, a, b, M_offset_6, 17, T[6]);
            b = FF(b, c, d, a, M_offset_7, 22, T[7]);
            a = FF(a, b, c, d, M_offset_8, 7, T[8]);
            d = FF(d, a, b, c, M_offset_9, 12, T[9]);
            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
            a = FF(a, b, c, d, M_offset_12, 7, T[12]);
            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
            b = FF(b, c, d, a, M_offset_15, 22, T[15]);
            a = GG(a, b, c, d, M_offset_1, 5, T[16]);
            d = GG(d, a, b, c, M_offset_6, 9, T[17]);
            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
            b = GG(b, c, d, a, M_offset_0, 20, T[19]);
            a = GG(a, b, c, d, M_offset_5, 5, T[20]);
            d = GG(d, a, b, c, M_offset_10, 9, T[21]);
            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
            b = GG(b, c, d, a, M_offset_4, 20, T[23]);
            a = GG(a, b, c, d, M_offset_9, 5, T[24]);
            d = GG(d, a, b, c, M_offset_14, 9, T[25]);
            c = GG(c, d, a, b, M_offset_3, 14, T[26]);
            b = GG(b, c, d, a, M_offset_8, 20, T[27]);
            a = GG(a, b, c, d, M_offset_13, 5, T[28]);
            d = GG(d, a, b, c, M_offset_2, 9, T[29]);
            c = GG(c, d, a, b, M_offset_7, 14, T[30]);
            b = GG(b, c, d, a, M_offset_12, 20, T[31]);
            a = HH(a, b, c, d, M_offset_5, 4, T[32]);
            d = HH(d, a, b, c, M_offset_8, 11, T[33]);
            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
            a = HH(a, b, c, d, M_offset_1, 4, T[36]);
            d = HH(d, a, b, c, M_offset_4, 11, T[37]);
            c = HH(c, d, a, b, M_offset_7, 16, T[38]);
            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
            a = HH(a, b, c, d, M_offset_13, 4, T[40]);
            d = HH(d, a, b, c, M_offset_0, 11, T[41]);
            c = HH(c, d, a, b, M_offset_3, 16, T[42]);
            b = HH(b, c, d, a, M_offset_6, 23, T[43]);
            a = HH(a, b, c, d, M_offset_9, 4, T[44]);
            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
            b = HH(b, c, d, a, M_offset_2, 23, T[47]);
            a = II(a, b, c, d, M_offset_0, 6, T[48]);
            d = II(d, a, b, c, M_offset_7, 10, T[49]);
            c = II(c, d, a, b, M_offset_14, 15, T[50]);
            b = II(b, c, d, a, M_offset_5, 21, T[51]);
            a = II(a, b, c, d, M_offset_12, 6, T[52]);
            d = II(d, a, b, c, M_offset_3, 10, T[53]);
            c = II(c, d, a, b, M_offset_10, 15, T[54]);
            b = II(b, c, d, a, M_offset_1, 21, T[55]);
            a = II(a, b, c, d, M_offset_8, 6, T[56]);
            d = II(d, a, b, c, M_offset_15, 10, T[57]);
            c = II(c, d, a, b, M_offset_6, 15, T[58]);
            b = II(b, c, d, a, M_offset_13, 21, T[59]);
            a = II(a, b, c, d, M_offset_4, 6, T[60]);
            d = II(d, a, b, c, M_offset_11, 10, T[61]);
            c = II(c, d, a, b, M_offset_2, 15, T[62]);
            b = II(b, c, d, a, M_offset_9, 21, T[63]);
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
          },
          _doFinalize: function _doFinalize() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = 8 * this._nDataBytes;
            var nBitsLeft = 8 * data.sigBytes;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[15 + (nBitsLeft + 64 >>> 9 << 4)] = 16711935 & (nBitsTotalH << 8 | nBitsTotalH >>> 24) | 4278255360 & (nBitsTotalH << 24 | nBitsTotalH >>> 8);
            dataWords[14 + (nBitsLeft + 64 >>> 9 << 4)] = 16711935 & (nBitsTotalL << 8 | nBitsTotalL >>> 24) | 4278255360 & (nBitsTotalL << 24 | nBitsTotalL >>> 8);
            data.sigBytes = 4 * (dataWords.length + 1);
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i = 0; i < 4; i++) {
              var H_i = H[i];
              H[i] = 16711935 & (H_i << 8 | H_i >>> 24) | 4278255360 & (H_i << 24 | H_i >>> 8);
            }
            return hash;
          },
          clone: function clone() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a, b, c, d, x, s, t) {
          var n = a + (b & c | ~b & d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function GG(a, b, c, d, x, s, t) {
          var n = a + (b & d | c & ~d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function HH(a, b, c, d, x, s, t) {
          var n = a + (b ^ c ^ d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function II(a, b, c, d, x, s, t) {
          var n = a + (c ^ (b | ~d)) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        C.MD5 = Hasher._createHelper(MD5);
        C.HmacMD5 = Hasher._createHmacHelper(MD5);
      })(Math);
      return CryptoJS.MD5;
    });
    cc._RF.pop();
  }, {
    "./core": "core"
  } ],
  mobx: [ function(require, module, exports) {
    (function(global) {
      "use strict";
      cc._RF.push(module, "de3aaq1fItEy5tKcvHOTs15", "mobx");
      "use strict";
      exports.__esModule = true;
      exports.$mobx = void 0;
      exports.FlowCancellationError = FlowCancellationError;
      exports.Reaction = exports.ObservableSet = exports.ObservableMap = void 0;
      exports._allowStateChanges = allowStateChanges;
      exports.runInAction = exports._allowStateChangesInsideComputed = runInAction;
      exports._allowStateReadsEnd = allowStateReadsEnd;
      exports._allowStateReadsStart = allowStateReadsStart;
      exports._autoAction = void 0;
      exports._endAction = _endAction;
      exports._getAdministration = getAdministration;
      exports._getGlobalState = getGlobalState;
      exports._interceptReads = interceptReads;
      exports._isComputingDerivation = isComputingDerivation;
      exports._resetGlobalState = resetGlobalState;
      exports._startAction = _startAction;
      exports.action = void 0;
      exports.autorun = autorun;
      exports.computed = exports.comparer = void 0;
      exports.configure = configure;
      exports.createAtom = createAtom;
      exports.defineProperty = apiDefineProperty;
      exports.entries = entries;
      exports.extendObservable = extendObservable;
      exports.flow = void 0;
      exports.flowResult = flowResult;
      exports.get = get;
      exports.getAtom = getAtom;
      exports.getDebugName = getDebugName;
      exports.getDependencyTree = getDependencyTree;
      exports.getObserverTree = getObserverTree;
      exports.has = has;
      exports.intercept = intercept;
      exports.isAction = isAction;
      exports.isBoxedObservable = void 0;
      exports.isComputed = isComputed;
      exports.isComputedProp = isComputedProp;
      exports.isFlow = isFlow;
      exports.isFlowCancellationError = isFlowCancellationError;
      exports.isObservable = isObservable;
      exports.isObservableArray = isObservableArray;
      exports.isObservableMap = void 0;
      exports.isObservableObject = isObservableObject;
      exports.isObservableProp = isObservableProp;
      exports.isObservableSet = void 0;
      exports.keys = keys;
      exports.makeAutoObservable = makeAutoObservable;
      exports.makeObservable = makeObservable;
      exports.observable = void 0;
      exports.observe = observe;
      exports.onBecomeObserved = onBecomeObserved;
      exports.onBecomeUnobserved = onBecomeUnobserved;
      exports.onReactionError = onReactionError;
      exports.override = void 0;
      exports.ownKeys = apiOwnKeys;
      exports.reaction = reaction;
      exports.remove = remove;
      exports.set = set;
      exports.spy = spy;
      exports.toJS = toJS;
      exports.trace = trace;
      exports.transaction = transaction;
      exports.untracked = untracked;
      exports.values = values;
      exports.when = when;
      var NODE_ENV = "production";
      var niceErrors = {
        0: "Invalid value for configuration 'enforceActions', expected 'never', 'always' or 'observed'",
        1: function _(annotationType, key) {
          return "Cannot apply '" + annotationType + "' to '" + key.toString() + "': Field not found.";
        },
        5: "'keys()' can only be used on observable objects, arrays, sets and maps",
        6: "'values()' can only be used on observable objects, arrays, sets and maps",
        7: "'entries()' can only be used on observable objects, arrays and maps",
        8: "'set()' can only be used on observable objects, arrays and maps",
        9: "'remove()' can only be used on observable objects, arrays and maps",
        10: "'has()' can only be used on observable objects, arrays and maps",
        11: "'get()' can only be used on observable objects, arrays and maps",
        12: "Invalid annotation",
        13: "Dynamic observable objects cannot be frozen",
        14: "Intercept handlers should return nothing or a change object",
        15: "Observable arrays cannot be frozen",
        16: "Modification exception: the internal structure of an observable array was changed.",
        17: function _(index, length) {
          return "[mobx.array] Index out of bounds, " + index + " is larger than " + length;
        },
        18: "mobx.map requires Map polyfill for the current browser. Check babel-polyfill or core-js/es6/map.js",
        19: function _(other) {
          return "Cannot initialize from classes that inherit from Map: " + other.constructor.name;
        },
        20: function _(other) {
          return "Cannot initialize map from " + other;
        },
        21: function _(dataStructure) {
          return "Cannot convert to map from '" + dataStructure + "'";
        },
        22: "mobx.set requires Set polyfill for the current browser. Check babel-polyfill or core-js/es6/set.js",
        23: "It is not possible to get index atoms from arrays",
        24: function _(thing) {
          return "Cannot obtain administration from " + thing;
        },
        25: function _(property, name) {
          return "the entry '" + property + "' does not exist in the observable map '" + name + "'";
        },
        26: "please specify a property",
        27: function _(property, name) {
          return "no observable property '" + property.toString() + "' found on the observable object '" + name + "'";
        },
        28: function _(thing) {
          return "Cannot obtain atom from " + thing;
        },
        29: "Expecting some object",
        30: "invalid action stack. did you forget to finish an action?",
        31: "missing option for computed: get",
        32: function _(name, derivation) {
          return "Cycle detected in computation " + name + ": " + derivation;
        },
        33: function _(name) {
          return "The setter of computed value '" + name + "' is trying to update itself. Did you intend to update an _observable_ value, instead of the computed property?";
        },
        34: function _(name) {
          return "[ComputedValue '" + name + "'] It is not possible to assign a new value to a computed value.";
        },
        35: "There are multiple, different versions of MobX active. Make sure MobX is loaded only once or use `configure({ isolateGlobalState: true })`",
        36: "isolateGlobalState should be called before MobX is running any reactions",
        37: function _(method) {
          return "[mobx] `observableArray." + method + "()` mutates the array in-place, which is not allowed inside a derivation. Use `array.slice()." + method + "()` instead";
        },
        38: "'ownKeys()' can only be used on observable objects",
        39: "'defineProperty()' can only be used on observable objects"
      };
      var errors = "production" !== NODE_ENV ? niceErrors : {};
      function die(error) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) args[_key - 1] = arguments[_key];
        if ("production" !== NODE_ENV) {
          var e = "string" === typeof error ? error : errors[error];
          "function" === typeof e && (e = e.apply(null, args));
          throw new Error("[MobX] " + e);
        }
        throw new Error("number" === typeof error ? "[MobX] minified error nr: " + error + (args.length ? " " + args.map(String).join(",") : "") + ". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts" : "[MobX] " + error);
      }
      var mockGlobal = {};
      function getGlobal() {
        if ("undefined" !== typeof globalThis) return globalThis;
        if ("undefined" !== typeof window) return window;
        if ("undefined" !== typeof global) return global;
        if ("undefined" !== typeof self) return self;
        return mockGlobal;
      }
      var assign = Object.assign;
      var getDescriptor = Object.getOwnPropertyDescriptor;
      var defineProperty = Object.defineProperty;
      var objectPrototype = Object.prototype;
      var EMPTY_ARRAY = [];
      Object.freeze(EMPTY_ARRAY);
      var EMPTY_OBJECT = {};
      Object.freeze(EMPTY_OBJECT);
      var hasProxy = "undefined" !== typeof Proxy;
      var plainObjectString = Object.toString();
      function assertProxies() {
        hasProxy || die("production" !== NODE_ENV ? "`Proxy` objects are not available in the current environment. Please configure MobX to enable a fallback implementation.`" : "Proxy not available");
      }
      function warnAboutProxyRequirement(msg) {
        "production" !== NODE_ENV && globalState.verifyProxies && die("MobX is currently configured to be able to run in ES5 mode, but in ES5 MobX won't be able to " + msg);
      }
      function getNextId() {
        return ++globalState.mobxGuid;
      }
      function once(func) {
        var invoked = false;
        return function() {
          if (invoked) return;
          invoked = true;
          return func.apply(this, arguments);
        };
      }
      var noop = function noop() {};
      function isFunction(fn) {
        return "function" === typeof fn;
      }
      function isStringish(value) {
        var t = typeof value;
        switch (t) {
         case "string":
         case "symbol":
         case "number":
          return true;
        }
        return false;
      }
      function isObject(value) {
        return null !== value && "object" === typeof value;
      }
      function isPlainObject(value) {
        var _proto$constructor;
        if (!isObject(value)) return false;
        var proto = Object.getPrototypeOf(value);
        if (null == proto) return true;
        return (null == (_proto$constructor = proto.constructor) ? void 0 : _proto$constructor.toString()) === plainObjectString;
      }
      function isGenerator(obj) {
        var constructor = null == obj ? void 0 : obj.constructor;
        if (!constructor) return false;
        if ("GeneratorFunction" === constructor.name || "GeneratorFunction" === constructor.displayName) return true;
        return false;
      }
      function addHiddenProp(object, propName, value) {
        defineProperty(object, propName, {
          enumerable: false,
          writable: true,
          configurable: true,
          value: value
        });
      }
      function addHiddenFinalProp(object, propName, value) {
        defineProperty(object, propName, {
          enumerable: false,
          writable: false,
          configurable: true,
          value: value
        });
      }
      function createInstanceofPredicate(name, theClass) {
        var propName = "isMobX" + name;
        theClass.prototype[propName] = true;
        return function(x) {
          return isObject(x) && true === x[propName];
        };
      }
      function isES6Map(thing) {
        return thing instanceof Map;
      }
      function isES6Set(thing) {
        return thing instanceof Set;
      }
      var hasGetOwnPropertySymbols = "undefined" !== typeof Object.getOwnPropertySymbols;
      function getPlainObjectKeys(object) {
        var keys = Object.keys(object);
        if (!hasGetOwnPropertySymbols) return keys;
        var symbols = Object.getOwnPropertySymbols(object);
        if (!symbols.length) return keys;
        return [].concat(keys, symbols.filter(function(s) {
          return objectPrototype.propertyIsEnumerable.call(object, s);
        }));
      }
      var ownKeys = "undefined" !== typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function(obj) {
        return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
      } : Object.getOwnPropertyNames;
      function stringifyKey(key) {
        if ("string" === typeof key) return key;
        if ("symbol" === typeof key) return key.toString();
        return new String(key).toString();
      }
      function toPrimitive(value) {
        return null === value ? null : "object" === typeof value ? "" + value : value;
      }
      function hasProp(target, prop) {
        return objectPrototype.hasOwnProperty.call(target, prop);
      }
      var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(target) {
        var res = {};
        ownKeys(target).forEach(function(key) {
          res[key] = getDescriptor(target, key);
        });
        return res;
      };
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          "value" in descriptor && (descriptor.writable = true);
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        protoProps && _defineProperties(Constructor.prototype, protoProps);
        staticProps && _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      function _extends() {
        _extends = Object.assign || function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) Object.prototype.hasOwnProperty.call(source, key) && (target[key] = source[key]);
          }
          return target;
        };
        return _extends.apply(this, arguments);
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      function _assertThisInitialized(self) {
        if (void 0 === self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return self;
      }
      function _unsupportedIterableToArray(o, minLen) {
        if (!o) return;
        if ("string" === typeof o) return _arrayLikeToArray(o, minLen);
        var n = Object.prototype.toString.call(o).slice(8, -1);
        "Object" === n && o.constructor && (n = o.constructor.name);
        if ("Map" === n || "Set" === n) return Array.from(o);
        if ("Arguments" === n || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
      }
      function _arrayLikeToArray(arr, len) {
        (null == len || len > arr.length) && (len = arr.length);
        for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
        return arr2;
      }
      function _createForOfIteratorHelperLoose(o, allowArrayLike) {
        var it;
        if ("undefined" === typeof Symbol || null == o[Symbol.iterator]) {
          if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && "number" === typeof o.length) {
            it && (o = it);
            var i = 0;
            return function() {
              if (i >= o.length) return {
                done: true
              };
              return {
                done: false,
                value: o[i++]
              };
            };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        it = o[Symbol.iterator]();
        return it.next.bind(it);
      }
      var storedAnnotationsSymbol = Symbol("mobx-stored-annotations");
      function createDecoratorAnnotation(annotation) {
        function decorator(target, property) {
          storeAnnotation(target, property, annotation);
        }
        return Object.assign(decorator, annotation);
      }
      function storeAnnotation(prototype, key, annotation) {
        hasProp(prototype, storedAnnotationsSymbol) || addHiddenProp(prototype, storedAnnotationsSymbol, _extends({}, prototype[storedAnnotationsSymbol]));
        if ("production" !== NODE_ENV && isOverride(annotation) && !hasProp(prototype[storedAnnotationsSymbol], key)) {
          var fieldName = prototype.constructor.name + ".prototype." + key.toString();
          die("'" + fieldName + "' is decorated with 'override', but no such decorated member was found on prototype.");
        }
        assertNotDecorated(prototype, annotation, key);
        isOverride(annotation) || (prototype[storedAnnotationsSymbol][key] = annotation);
      }
      function assertNotDecorated(prototype, annotation, key) {
        if ("production" !== NODE_ENV && !isOverride(annotation) && hasProp(prototype[storedAnnotationsSymbol], key)) {
          var fieldName = prototype.constructor.name + ".prototype." + key.toString();
          var currentAnnotationType = prototype[storedAnnotationsSymbol][key].annotationType_;
          var requestedAnnotationType = annotation.annotationType_;
          die("Cannot apply '@" + requestedAnnotationType + "' to '" + fieldName + "':\nThe field is already decorated with '@" + currentAnnotationType + "'.\nRe-decorating fields is not allowed.\nUse '@override' decorator for methods overriden by subclass.");
        }
      }
      function collectStoredAnnotations(target) {
        if (!hasProp(target, storedAnnotationsSymbol)) {
          "production" === NODE_ENV || target[storedAnnotationsSymbol] || die("No annotations were passed to makeObservable, but no decorated members have been found either");
          addHiddenProp(target, storedAnnotationsSymbol, _extends({}, target[storedAnnotationsSymbol]));
        }
        return target[storedAnnotationsSymbol];
      }
      var $mobx = Symbol("mobx administration");
      exports.$mobx = $mobx;
      var Atom = function() {
        function Atom(name_) {
          void 0 === name_ && (name_ = "production" !== NODE_ENV ? "Atom@" + getNextId() : "Atom");
          this.name_ = void 0;
          this.isPendingUnobservation_ = false;
          this.isBeingObserved_ = false;
          this.observers_ = new Set();
          this.diffValue_ = 0;
          this.lastAccessedBy_ = 0;
          this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_;
          this.onBOL = void 0;
          this.onBUOL = void 0;
          this.name_ = name_;
        }
        var _proto = Atom.prototype;
        _proto.onBO = function onBO() {
          this.onBOL && this.onBOL.forEach(function(listener) {
            return listener();
          });
        };
        _proto.onBUO = function onBUO() {
          this.onBUOL && this.onBUOL.forEach(function(listener) {
            return listener();
          });
        };
        _proto.reportObserved = function reportObserved$1() {
          return reportObserved(this);
        };
        _proto.reportChanged = function reportChanged() {
          startBatch();
          propagateChanged(this);
          endBatch();
        };
        _proto.toString = function toString() {
          return this.name_;
        };
        return Atom;
      }();
      var isAtom = createInstanceofPredicate("Atom", Atom);
      function createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
        void 0 === onBecomeObservedHandler && (onBecomeObservedHandler = noop);
        void 0 === onBecomeUnobservedHandler && (onBecomeUnobservedHandler = noop);
        var atom = new Atom(name);
        onBecomeObservedHandler !== noop && onBecomeObserved(atom, onBecomeObservedHandler);
        onBecomeUnobservedHandler !== noop && onBecomeUnobserved(atom, onBecomeUnobservedHandler);
        return atom;
      }
      function identityComparer(a, b) {
        return a === b;
      }
      function structuralComparer(a, b) {
        return deepEqual(a, b);
      }
      function shallowComparer(a, b) {
        return deepEqual(a, b, 1);
      }
      function defaultComparer(a, b) {
        return Object.is(a, b);
      }
      var comparer = {
        identity: identityComparer,
        structural: structuralComparer,
        default: defaultComparer,
        shallow: shallowComparer
      };
      exports.comparer = comparer;
      function deepEnhancer(v, _, name) {
        if (isObservable(v)) return v;
        if (Array.isArray(v)) return observable.array(v, {
          name: name
        });
        if (isPlainObject(v)) return observable.object(v, void 0, {
          name: name
        });
        if (isES6Map(v)) return observable.map(v, {
          name: name
        });
        if (isES6Set(v)) return observable.set(v, {
          name: name
        });
        if ("function" === typeof v && !isAction(v) && !isFlow(v)) return isGenerator(v) ? flow(v) : autoAction(name, v);
        return v;
      }
      function shallowEnhancer(v, _, name) {
        if (void 0 === v || null === v) return v;
        if (isObservableObject(v) || isObservableArray(v) || isObservableMap(v) || isObservableSet(v)) return v;
        if (Array.isArray(v)) return observable.array(v, {
          name: name,
          deep: false
        });
        if (isPlainObject(v)) return observable.object(v, void 0, {
          name: name,
          deep: false
        });
        if (isES6Map(v)) return observable.map(v, {
          name: name,
          deep: false
        });
        if (isES6Set(v)) return observable.set(v, {
          name: name,
          deep: false
        });
        "production" !== NODE_ENV && die("The shallow modifier / decorator can only used in combination with arrays, objects, maps and sets");
      }
      function referenceEnhancer(newValue) {
        return newValue;
      }
      function refStructEnhancer(v, oldValue) {
        "production" !== NODE_ENV && isObservable(v) && die("observable.struct should not be used with observable values");
        if (deepEqual(v, oldValue)) return oldValue;
        return v;
      }
      var OVERRIDE = "override";
      var override = createDecoratorAnnotation({
        annotationType_: OVERRIDE,
        make_: make_,
        extend_: extend_
      });
      exports.override = override;
      function isOverride(annotation) {
        return annotation.annotationType_ === OVERRIDE;
      }
      function make_(adm, key) {
        "production" !== NODE_ENV && adm.isPlainObject_ && die("Cannot apply '" + this.annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':\n'" + this.annotationType_ + "' cannot be used on plain objects.");
        "production" === NODE_ENV || hasProp(adm.appliedAnnotations_, key) || die("'" + adm.name_ + "." + key.toString() + "' is annotated with '" + this.annotationType_ + "', but no such annotated member was found on prototype.");
        return 0;
      }
      function extend_(adm, key, descriptor, proxyTrap) {
        die("'" + this.annotationType_ + "' can only be used with 'makeObservable'");
      }
      function createActionAnnotation(name, options) {
        return {
          annotationType_: name,
          options_: options,
          make_: make_$1,
          extend_: extend_$1
        };
      }
      function make_$1(adm, key, descriptor, source) {
        var _this$options_;
        if (null == (_this$options_ = this.options_) ? void 0 : _this$options_.bound) return null === this.extend_(adm, key, descriptor, false) ? 0 : 1;
        if (source === adm.target_) return null === this.extend_(adm, key, descriptor, false) ? 0 : 2;
        if (isAction(descriptor.value)) return 1;
        var actionDescriptor = createActionDescriptor(adm, this, key, descriptor, false);
        defineProperty(source, key, actionDescriptor);
        return 2;
      }
      function extend_$1(adm, key, descriptor, proxyTrap) {
        var actionDescriptor = createActionDescriptor(adm, this, key, descriptor);
        return adm.defineProperty_(key, actionDescriptor, proxyTrap);
      }
      function assertActionDescriptor(adm, _ref, key, _ref2) {
        var annotationType_ = _ref.annotationType_;
        var value = _ref2.value;
        "production" === NODE_ENV || isFunction(value) || die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':\n'" + annotationType_ + "' can only be used on properties with a function value.");
      }
      function createActionDescriptor(adm, annotation, key, descriptor, safeDescriptors) {
        var _annotation$options_, _annotation$options_$, _annotation$options_2, _annotation$options_$2, _annotation$options_3;
        void 0 === safeDescriptors && (safeDescriptors = globalState.safeDescriptors);
        assertActionDescriptor(adm, annotation, key, descriptor);
        var value = descriptor.value;
        if (null == (_annotation$options_ = annotation.options_) ? void 0 : _annotation$options_.bound) {
          var _adm$proxy_;
          value = value.bind(null != (_adm$proxy_ = adm.proxy_) ? _adm$proxy_ : adm.target_);
        }
        return {
          value: createAction(null != (_annotation$options_$ = null == (_annotation$options_2 = annotation.options_) ? void 0 : _annotation$options_2.name) ? _annotation$options_$ : key.toString(), value, null != (_annotation$options_$2 = null == (_annotation$options_3 = annotation.options_) ? void 0 : _annotation$options_3.autoAction) && _annotation$options_$2),
          configurable: !safeDescriptors || adm.isPlainObject_,
          enumerable: false,
          writable: !safeDescriptors
        };
      }
      function createFlowAnnotation(name, options) {
        return {
          annotationType_: name,
          options_: options,
          make_: make_$2,
          extend_: extend_$2
        };
      }
      function make_$2(adm, key, descriptor, source) {
        var _this$options_;
        if (source === adm.target_) return null === this.extend_(adm, key, descriptor, false) ? 0 : 2;
        if ((null == (_this$options_ = this.options_) ? void 0 : _this$options_.bound) && !isFlow(adm.target_[key]) && null === this.extend_(adm, key, descriptor, false)) return 0;
        if (isFlow(descriptor.value)) return 1;
        var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, false, false);
        defineProperty(source, key, flowDescriptor);
        return 2;
      }
      function extend_$2(adm, key, descriptor, proxyTrap) {
        var _this$options_2;
        var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, null == (_this$options_2 = this.options_) ? void 0 : _this$options_2.bound);
        return adm.defineProperty_(key, flowDescriptor, proxyTrap);
      }
      function assertFlowDescriptor(adm, _ref, key, _ref2) {
        var annotationType_ = _ref.annotationType_;
        var value = _ref2.value;
        "production" === NODE_ENV || isFunction(value) || die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':\n'" + annotationType_ + "' can only be used on properties with a generator function value.");
      }
      function createFlowDescriptor(adm, annotation, key, descriptor, bound, safeDescriptors) {
        void 0 === safeDescriptors && (safeDescriptors = globalState.safeDescriptors);
        assertFlowDescriptor(adm, annotation, key, descriptor);
        var value = descriptor.value;
        if (bound) {
          var _adm$proxy_;
          value = value.bind(null != (_adm$proxy_ = adm.proxy_) ? _adm$proxy_ : adm.target_);
        }
        return {
          value: flow(value),
          configurable: !safeDescriptors || adm.isPlainObject_,
          enumerable: false,
          writable: !safeDescriptors
        };
      }
      function createComputedAnnotation(name, options) {
        return {
          annotationType_: name,
          options_: options,
          make_: make_$3,
          extend_: extend_$3
        };
      }
      function make_$3(adm, key, descriptor) {
        return null === this.extend_(adm, key, descriptor, false) ? 0 : 1;
      }
      function extend_$3(adm, key, descriptor, proxyTrap) {
        assertComputedDescriptor(adm, this, key, descriptor);
        return adm.defineComputedProperty_(key, _extends({}, this.options_, {
          get: descriptor.get,
          set: descriptor.set
        }), proxyTrap);
      }
      function assertComputedDescriptor(adm, _ref, key, _ref2) {
        var annotationType_ = _ref.annotationType_;
        var get = _ref2.get;
        "production" === NODE_ENV || get || die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':\n'" + annotationType_ + "' can only be used on getter(+setter) properties.");
      }
      function createObservableAnnotation(name, options) {
        return {
          annotationType_: name,
          options_: options,
          make_: make_$4,
          extend_: extend_$4
        };
      }
      function make_$4(adm, key, descriptor) {
        return null === this.extend_(adm, key, descriptor, false) ? 0 : 1;
      }
      function extend_$4(adm, key, descriptor, proxyTrap) {
        var _this$options_$enhanc, _this$options_;
        assertObservableDescriptor(adm, this, key, descriptor);
        return adm.defineObservableProperty_(key, descriptor.value, null != (_this$options_$enhanc = null == (_this$options_ = this.options_) ? void 0 : _this$options_.enhancer) ? _this$options_$enhanc : deepEnhancer, proxyTrap);
      }
      function assertObservableDescriptor(adm, _ref, key, descriptor) {
        var annotationType_ = _ref.annotationType_;
        "production" === NODE_ENV || "value" in descriptor || die("Cannot apply '" + annotationType_ + "' to '" + adm.name_ + "." + key.toString() + "':\n'" + annotationType_ + "' cannot be used on getter/setter properties");
      }
      var AUTO = "true";
      var autoAnnotation = createAutoAnnotation();
      function createAutoAnnotation(options) {
        return {
          annotationType_: AUTO,
          options_: options,
          make_: make_$5,
          extend_: extend_$5
        };
      }
      function make_$5(adm, key, descriptor, source) {
        var _this$options_3, _this$options_4;
        if (descriptor.get) return computed.make_(adm, key, descriptor, source);
        if (descriptor.set) {
          var set = createAction(key.toString(), descriptor.set);
          if (source === adm.target_) return null === adm.defineProperty_(key, {
            configurable: !globalState.safeDescriptors || adm.isPlainObject_,
            set: set
          }) ? 0 : 2;
          defineProperty(source, key, {
            configurable: true,
            set: set
          });
          return 2;
        }
        if (source !== adm.target_ && "function" === typeof descriptor.value) {
          var _this$options_2;
          if (isGenerator(descriptor.value)) {
            var _this$options_;
            var flowAnnotation = (null == (_this$options_ = this.options_) ? void 0 : _this$options_.autoBind) ? flow.bound : flow;
            return flowAnnotation.make_(adm, key, descriptor, source);
          }
          var actionAnnotation = (null == (_this$options_2 = this.options_) ? void 0 : _this$options_2.autoBind) ? autoAction.bound : autoAction;
          return actionAnnotation.make_(adm, key, descriptor, source);
        }
        var observableAnnotation = false === (null == (_this$options_3 = this.options_) ? void 0 : _this$options_3.deep) ? observable.ref : observable;
        if ("function" === typeof descriptor.value && (null == (_this$options_4 = this.options_) ? void 0 : _this$options_4.autoBind)) {
          var _adm$proxy_;
          descriptor.value = descriptor.value.bind(null != (_adm$proxy_ = adm.proxy_) ? _adm$proxy_ : adm.target_);
        }
        return observableAnnotation.make_(adm, key, descriptor, source);
      }
      function extend_$5(adm, key, descriptor, proxyTrap) {
        var _this$options_5, _this$options_6;
        if (descriptor.get) return computed.extend_(adm, key, descriptor, proxyTrap);
        if (descriptor.set) return adm.defineProperty_(key, {
          configurable: !globalState.safeDescriptors || adm.isPlainObject_,
          set: createAction(key.toString(), descriptor.set)
        }, proxyTrap);
        if ("function" === typeof descriptor.value && (null == (_this$options_5 = this.options_) ? void 0 : _this$options_5.autoBind)) {
          var _adm$proxy_2;
          descriptor.value = descriptor.value.bind(null != (_adm$proxy_2 = adm.proxy_) ? _adm$proxy_2 : adm.target_);
        }
        var observableAnnotation = false === (null == (_this$options_6 = this.options_) ? void 0 : _this$options_6.deep) ? observable.ref : observable;
        return observableAnnotation.extend_(adm, key, descriptor, proxyTrap);
      }
      var defaultCreateObservableOptions = {
        deep: true,
        name: void 0,
        defaultDecorator: void 0,
        proxy: true
      };
      Object.freeze(defaultCreateObservableOptions);
      function asCreateObservableOptions(thing) {
        return thing || defaultCreateObservableOptions;
      }
      var observableAnnotation = createObservableAnnotation("observable");
      var observableRefAnnotation = createObservableAnnotation("observable.ref", {
        enhancer: referenceEnhancer
      });
      var observableShallowAnnotation = createObservableAnnotation("observable.shallow", {
        enhancer: shallowEnhancer
      });
      var observableStructAnnotation = createObservableAnnotation("observable.struct", {
        enhancer: refStructEnhancer
      });
      var observableDecoratorAnnotation = createDecoratorAnnotation(observableAnnotation);
      function getEnhancerFromOptions(options) {
        return true === options.deep ? deepEnhancer : false === options.deep ? referenceEnhancer : getEnhancerFromAnnotation(options.defaultDecorator);
      }
      function getAnnotationFromOptions(options) {
        var _options$defaultDecor;
        return options ? null != (_options$defaultDecor = options.defaultDecorator) ? _options$defaultDecor : createAutoAnnotation(options) : void 0;
      }
      function getEnhancerFromAnnotation(annotation) {
        var _annotation$options_$, _annotation$options_;
        return annotation && null != (_annotation$options_$ = null == (_annotation$options_ = annotation.options_) ? void 0 : _annotation$options_.enhancer) ? _annotation$options_$ : deepEnhancer;
      }
      function createObservable(v, arg2, arg3) {
        if (isStringish(arg2)) {
          storeAnnotation(v, arg2, observableAnnotation);
          return;
        }
        if (isObservable(v)) return v;
        if (isPlainObject(v)) return observable.object(v, arg2, arg3);
        if (Array.isArray(v)) return observable.array(v, arg2);
        if (isES6Map(v)) return observable.map(v, arg2);
        if (isES6Set(v)) return observable.set(v, arg2);
        if ("object" === typeof v && null !== v) return v;
        return observable.box(v, arg2);
      }
      Object.assign(createObservable, observableDecoratorAnnotation);
      var observableFactories = {
        box: function box(value, options) {
          var o = asCreateObservableOptions(options);
          return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals);
        },
        array: function array(initialValues, options) {
          var o = asCreateObservableOptions(options);
          return (false === globalState.useProxies || false === o.proxy ? createLegacyArray : createObservableArray)(initialValues, getEnhancerFromOptions(o), o.name);
        },
        map: function map(initialValues, options) {
          var o = asCreateObservableOptions(options);
          return new ObservableMap(initialValues, getEnhancerFromOptions(o), o.name);
        },
        set: function set(initialValues, options) {
          var o = asCreateObservableOptions(options);
          return new ObservableSet(initialValues, getEnhancerFromOptions(o), o.name);
        },
        object: function object(props, decorators, options) {
          return extendObservable(false === globalState.useProxies || false === (null == options ? void 0 : options.proxy) ? asObservableObject({}, options) : asDynamicObservableObject({}, options), props, decorators);
        },
        ref: createDecoratorAnnotation(observableRefAnnotation),
        shallow: createDecoratorAnnotation(observableShallowAnnotation),
        deep: observableDecoratorAnnotation,
        struct: createDecoratorAnnotation(observableStructAnnotation)
      };
      var observable = assign(createObservable, observableFactories);
      exports.observable = observable;
      var COMPUTED = "computed";
      var COMPUTED_STRUCT = "computed.struct";
      var computedAnnotation = createComputedAnnotation(COMPUTED);
      var computedStructAnnotation = createComputedAnnotation(COMPUTED_STRUCT, {
        equals: comparer.structural
      });
      var computed = function computed(arg1, arg2) {
        if (isStringish(arg2)) return storeAnnotation(arg1, arg2, computedAnnotation);
        if (isPlainObject(arg1)) return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1));
        if ("production" !== NODE_ENV) {
          isFunction(arg1) || die("First argument to `computed` should be an expression.");
          isFunction(arg2) && die("A setter as second argument is no longer supported, use `{ set: fn }` option instead");
        }
        var opts = isPlainObject(arg2) ? arg2 : {};
        opts.get = arg1;
        opts.name || (opts.name = arg1.name || "");
        return new ComputedValue(opts);
      };
      exports.computed = computed;
      Object.assign(computed, computedAnnotation);
      computed.struct = createDecoratorAnnotation(computedStructAnnotation);
      var _getDescriptor$config, _getDescriptor;
      var currentActionId = 0;
      var nextActionId = 1;
      var isFunctionNameConfigurable = null != (_getDescriptor$config = null == (_getDescriptor = getDescriptor(function() {}, "name")) ? void 0 : _getDescriptor.configurable) && _getDescriptor$config;
      var tmpNameDescriptor = {
        value: "action",
        configurable: true,
        writable: false,
        enumerable: false
      };
      function createAction(actionName, fn, autoAction, ref) {
        void 0 === autoAction && (autoAction = false);
        if ("production" !== NODE_ENV) {
          isFunction(fn) || die("`action` can only be invoked on functions");
          "string" === typeof actionName && actionName || die("actions should have valid names, got: '" + actionName + "'");
        }
        function res() {
          return executeAction(actionName, autoAction, fn, ref || this, arguments);
        }
        res.isMobxAction = true;
        if (isFunctionNameConfigurable) {
          tmpNameDescriptor.value = actionName;
          Object.defineProperty(res, "name", tmpNameDescriptor);
        }
        return res;
      }
      function executeAction(actionName, canRunAsDerivation, fn, scope, args) {
        var runInfo = _startAction(actionName, canRunAsDerivation, scope, args);
        try {
          return fn.apply(scope, args);
        } catch (err) {
          runInfo.error_ = err;
          throw err;
        } finally {
          _endAction(runInfo);
        }
      }
      function _startAction(actionName, canRunAsDerivation, scope, args) {
        var notifySpy_ = "production" !== NODE_ENV && isSpyEnabled() && !!actionName;
        var startTime_ = 0;
        if ("production" !== NODE_ENV && notifySpy_) {
          startTime_ = Date.now();
          var flattenedArgs = args ? Array.from(args) : EMPTY_ARRAY;
          spyReportStart({
            type: ACTION,
            name: actionName,
            object: scope,
            arguments: flattenedArgs
          });
        }
        var prevDerivation_ = globalState.trackingDerivation;
        var runAsAction = !canRunAsDerivation || !prevDerivation_;
        startBatch();
        var prevAllowStateChanges_ = globalState.allowStateChanges;
        if (runAsAction) {
          untrackedStart();
          prevAllowStateChanges_ = allowStateChangesStart(true);
        }
        var prevAllowStateReads_ = allowStateReadsStart(true);
        var runInfo = {
          runAsAction_: runAsAction,
          prevDerivation_: prevDerivation_,
          prevAllowStateChanges_: prevAllowStateChanges_,
          prevAllowStateReads_: prevAllowStateReads_,
          notifySpy_: notifySpy_,
          startTime_: startTime_,
          actionId_: nextActionId++,
          parentActionId_: currentActionId
        };
        currentActionId = runInfo.actionId_;
        return runInfo;
      }
      function _endAction(runInfo) {
        currentActionId !== runInfo.actionId_ && die(30);
        currentActionId = runInfo.parentActionId_;
        void 0 !== runInfo.error_ && (globalState.suppressReactionErrors = true);
        allowStateChangesEnd(runInfo.prevAllowStateChanges_);
        allowStateReadsEnd(runInfo.prevAllowStateReads_);
        endBatch();
        runInfo.runAsAction_ && untrackedEnd(runInfo.prevDerivation_);
        "production" !== NODE_ENV && runInfo.notifySpy_ && spyReportEnd({
          time: Date.now() - runInfo.startTime_
        });
        globalState.suppressReactionErrors = false;
      }
      function allowStateChanges(allowStateChanges, func) {
        var prev = allowStateChangesStart(allowStateChanges);
        try {
          return func();
        } finally {
          allowStateChangesEnd(prev);
        }
      }
      function allowStateChangesStart(allowStateChanges) {
        var prev = globalState.allowStateChanges;
        globalState.allowStateChanges = allowStateChanges;
        return prev;
      }
      function allowStateChangesEnd(prev) {
        globalState.allowStateChanges = prev;
      }
      var _Symbol$toPrimitive;
      var CREATE = "create";
      _Symbol$toPrimitive = Symbol.toPrimitive;
      var ObservableValue = function(_Atom) {
        _inheritsLoose(ObservableValue, _Atom);
        function ObservableValue(value, enhancer, name_, notifySpy, equals) {
          var _this;
          void 0 === name_ && (name_ = "production" !== NODE_ENV ? "ObservableValue@" + getNextId() : "ObservableValue");
          void 0 === notifySpy && (notifySpy = true);
          void 0 === equals && (equals = comparer["default"]);
          _this = _Atom.call(this, name_) || this;
          _this.enhancer = void 0;
          _this.name_ = void 0;
          _this.equals = void 0;
          _this.hasUnreportedChange_ = false;
          _this.interceptors_ = void 0;
          _this.changeListeners_ = void 0;
          _this.value_ = void 0;
          _this.dehancer = void 0;
          _this.enhancer = enhancer;
          _this.name_ = name_;
          _this.equals = equals;
          _this.value_ = enhancer(value, void 0, name_);
          "production" !== NODE_ENV && notifySpy && isSpyEnabled() && spyReport({
            type: CREATE,
            object: _assertThisInitialized(_this),
            observableKind: "value",
            debugObjectName: _this.name_,
            newValue: "" + _this.value_
          });
          return _this;
        }
        var _proto = ObservableValue.prototype;
        _proto.dehanceValue = function dehanceValue(value) {
          if (void 0 !== this.dehancer) return this.dehancer(value);
          return value;
        };
        _proto.set = function set(newValue) {
          var oldValue = this.value_;
          newValue = this.prepareNewValue_(newValue);
          if (newValue !== globalState.UNCHANGED) {
            var notifySpy = isSpyEnabled();
            "production" !== NODE_ENV && notifySpy && spyReportStart({
              type: UPDATE,
              object: this,
              observableKind: "value",
              debugObjectName: this.name_,
              newValue: newValue,
              oldValue: oldValue
            });
            this.setNewValue_(newValue);
            "production" !== NODE_ENV && notifySpy && spyReportEnd();
          }
        };
        _proto.prepareNewValue_ = function prepareNewValue_(newValue) {
          checkIfStateModificationsAreAllowed(this);
          if (hasInterceptors(this)) {
            var change = interceptChange(this, {
              object: this,
              type: UPDATE,
              newValue: newValue
            });
            if (!change) return globalState.UNCHANGED;
            newValue = change.newValue;
          }
          newValue = this.enhancer(newValue, this.value_, this.name_);
          return this.equals(this.value_, newValue) ? globalState.UNCHANGED : newValue;
        };
        _proto.setNewValue_ = function setNewValue_(newValue) {
          var oldValue = this.value_;
          this.value_ = newValue;
          this.reportChanged();
          hasListeners(this) && notifyListeners(this, {
            type: UPDATE,
            object: this,
            newValue: newValue,
            oldValue: oldValue
          });
        };
        _proto.get = function get() {
          this.reportObserved();
          return this.dehanceValue(this.value_);
        };
        _proto.intercept_ = function intercept_(handler) {
          return registerInterceptor(this, handler);
        };
        _proto.observe_ = function observe_(listener, fireImmediately) {
          fireImmediately && listener({
            observableKind: "value",
            debugObjectName: this.name_,
            object: this,
            type: UPDATE,
            newValue: this.value_,
            oldValue: void 0
          });
          return registerListener(this, listener);
        };
        _proto.raw = function raw() {
          return this.value_;
        };
        _proto.toJSON = function toJSON() {
          return this.get();
        };
        _proto.toString = function toString() {
          return this.name_ + "[" + this.value_ + "]";
        };
        _proto.valueOf = function valueOf() {
          return toPrimitive(this.get());
        };
        _proto[_Symbol$toPrimitive] = function() {
          return this.valueOf();
        };
        return ObservableValue;
      }(Atom);
      var isObservableValue = createInstanceofPredicate("ObservableValue", ObservableValue);
      exports.isBoxedObservable = isObservableValue;
      var _Symbol$toPrimitive$1;
      _Symbol$toPrimitive$1 = Symbol.toPrimitive;
      var ComputedValue = function() {
        function ComputedValue(options) {
          this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
          this.observing_ = [];
          this.newObserving_ = null;
          this.isBeingObserved_ = false;
          this.isPendingUnobservation_ = false;
          this.observers_ = new Set();
          this.diffValue_ = 0;
          this.runId_ = 0;
          this.lastAccessedBy_ = 0;
          this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
          this.unboundDepsCount_ = 0;
          this.value_ = new CaughtException(null);
          this.name_ = void 0;
          this.triggeredBy_ = void 0;
          this.isComputing_ = false;
          this.isRunningSetter_ = false;
          this.derivation = void 0;
          this.setter_ = void 0;
          this.isTracing_ = TraceMode.NONE;
          this.scope_ = void 0;
          this.equals_ = void 0;
          this.requiresReaction_ = void 0;
          this.keepAlive_ = void 0;
          this.onBOL = void 0;
          this.onBUOL = void 0;
          options.get || die(31);
          this.derivation = options.get;
          this.name_ = options.name || ("production" !== NODE_ENV ? "ComputedValue@" + getNextId() : "ComputedValue");
          options.set && (this.setter_ = createAction("production" !== NODE_ENV ? this.name_ + "-setter" : "ComputedValue-setter", options.set));
          this.equals_ = options.equals || (options.compareStructural || options.struct ? comparer.structural : comparer["default"]);
          this.scope_ = options.context;
          this.requiresReaction_ = !!options.requiresReaction;
          this.keepAlive_ = !!options.keepAlive;
        }
        var _proto = ComputedValue.prototype;
        _proto.onBecomeStale_ = function onBecomeStale_() {
          propagateMaybeChanged(this);
        };
        _proto.onBO = function onBO() {
          this.onBOL && this.onBOL.forEach(function(listener) {
            return listener();
          });
        };
        _proto.onBUO = function onBUO() {
          this.onBUOL && this.onBUOL.forEach(function(listener) {
            return listener();
          });
        };
        _proto.get = function get() {
          this.isComputing_ && die(32, this.name_, this.derivation);
          if (0 !== globalState.inBatch || 0 !== this.observers_.size || this.keepAlive_) {
            reportObserved(this);
            if (shouldCompute(this)) {
              var prevTrackingContext = globalState.trackingContext;
              this.keepAlive_ && !prevTrackingContext && (globalState.trackingContext = this);
              this.trackAndCompute() && propagateChangeConfirmed(this);
              globalState.trackingContext = prevTrackingContext;
            }
          } else if (shouldCompute(this)) {
            this.warnAboutUntrackedRead_();
            startBatch();
            this.value_ = this.computeValue_(false);
            endBatch();
          }
          var result = this.value_;
          if (isCaughtException(result)) throw result.cause;
          return result;
        };
        _proto.set = function set(value) {
          if (this.setter_) {
            this.isRunningSetter_ && die(33, this.name_);
            this.isRunningSetter_ = true;
            try {
              this.setter_.call(this.scope_, value);
            } finally {
              this.isRunningSetter_ = false;
            }
          } else die(34, this.name_);
        };
        _proto.trackAndCompute = function trackAndCompute() {
          var oldValue = this.value_;
          var wasSuspended = this.dependenciesState_ === IDerivationState_.NOT_TRACKING_;
          var newValue = this.computeValue_(true);
          "production" !== NODE_ENV && isSpyEnabled() && spyReport({
            observableKind: "computed",
            debugObjectName: this.name_,
            object: this.scope_,
            type: "update",
            oldValue: this.value_,
            newValue: newValue
          });
          var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals_(oldValue, newValue);
          changed && (this.value_ = newValue);
          return changed;
        };
        _proto.computeValue_ = function computeValue_(track) {
          this.isComputing_ = true;
          var prev = allowStateChangesStart(false);
          var res;
          if (track) res = trackDerivedFunction(this, this.derivation, this.scope_); else if (true === globalState.disableErrorBoundaries) res = this.derivation.call(this.scope_); else try {
            res = this.derivation.call(this.scope_);
          } catch (e) {
            res = new CaughtException(e);
          }
          allowStateChangesEnd(prev);
          this.isComputing_ = false;
          return res;
        };
        _proto.suspend_ = function suspend_() {
          if (!this.keepAlive_) {
            clearObserving(this);
            this.value_ = void 0;
          }
        };
        _proto.observe_ = function observe_(listener, fireImmediately) {
          var _this = this;
          var firstTime = true;
          var prevValue = void 0;
          return autorun(function() {
            var newValue = _this.get();
            if (!firstTime || fireImmediately) {
              var prevU = untrackedStart();
              listener({
                observableKind: "computed",
                debugObjectName: _this.name_,
                type: UPDATE,
                object: _this,
                newValue: newValue,
                oldValue: prevValue
              });
              untrackedEnd(prevU);
            }
            firstTime = false;
            prevValue = newValue;
          });
        };
        _proto.warnAboutUntrackedRead_ = function warnAboutUntrackedRead_() {
          if (!("production" !== NODE_ENV)) return;
          true === this.requiresReaction_ && die("[mobx] Computed value " + this.name_ + " is read outside a reactive context");
          this.isTracing_ !== TraceMode.NONE && console.log("[mobx.trace] '" + this.name_ + "' is being read outside a reactive context. Doing a full recompute");
          globalState.computedRequiresReaction && console.warn("[mobx] Computed value " + this.name_ + " is being read outside a reactive context. Doing a full recompute");
        };
        _proto.toString = function toString() {
          return this.name_ + "[" + this.derivation.toString() + "]";
        };
        _proto.valueOf = function valueOf() {
          return toPrimitive(this.get());
        };
        _proto[_Symbol$toPrimitive$1] = function() {
          return this.valueOf();
        };
        return ComputedValue;
      }();
      var isComputedValue = createInstanceofPredicate("ComputedValue", ComputedValue);
      var IDerivationState_;
      (function(IDerivationState_) {
        IDerivationState_[IDerivationState_["NOT_TRACKING_"] = -1] = "NOT_TRACKING_";
        IDerivationState_[IDerivationState_["UP_TO_DATE_"] = 0] = "UP_TO_DATE_";
        IDerivationState_[IDerivationState_["POSSIBLY_STALE_"] = 1] = "POSSIBLY_STALE_";
        IDerivationState_[IDerivationState_["STALE_"] = 2] = "STALE_";
      })(IDerivationState_ || (IDerivationState_ = {}));
      var TraceMode;
      (function(TraceMode) {
        TraceMode[TraceMode["NONE"] = 0] = "NONE";
        TraceMode[TraceMode["LOG"] = 1] = "LOG";
        TraceMode[TraceMode["BREAK"] = 2] = "BREAK";
      })(TraceMode || (TraceMode = {}));
      var CaughtException = function CaughtException(cause) {
        this.cause = void 0;
        this.cause = cause;
      };
      function isCaughtException(e) {
        return e instanceof CaughtException;
      }
      function shouldCompute(derivation) {
        switch (derivation.dependenciesState_) {
         case IDerivationState_.UP_TO_DATE_:
          return false;

         case IDerivationState_.NOT_TRACKING_:
         case IDerivationState_.STALE_:
          return true;

         case IDerivationState_.POSSIBLY_STALE_:
          var prevAllowStateReads = allowStateReadsStart(true);
          var prevUntracked = untrackedStart();
          var obs = derivation.observing_, l = obs.length;
          for (var i = 0; i < l; i++) {
            var obj = obs[i];
            if (isComputedValue(obj)) {
              if (globalState.disableErrorBoundaries) obj.get(); else try {
                obj.get();
              } catch (e) {
                untrackedEnd(prevUntracked);
                allowStateReadsEnd(prevAllowStateReads);
                return true;
              }
              if (derivation.dependenciesState_ === IDerivationState_.STALE_) {
                untrackedEnd(prevUntracked);
                allowStateReadsEnd(prevAllowStateReads);
                return true;
              }
            }
          }
          changeDependenciesStateTo0(derivation);
          untrackedEnd(prevUntracked);
          allowStateReadsEnd(prevAllowStateReads);
          return false;
        }
      }
      function isComputingDerivation() {
        return null !== globalState.trackingDerivation;
      }
      function checkIfStateModificationsAreAllowed(atom) {
        if (!("production" !== NODE_ENV)) return;
        var hasObservers = atom.observers_.size > 0;
        globalState.allowStateChanges || !hasObservers && "always" !== globalState.enforceActions || console.warn("[MobX] " + (globalState.enforceActions ? "Since strict-mode is enabled, changing (observed) observable values without using an action is not allowed. Tried to modify: " : "Side effects like changing state are not allowed at this point. Are you trying to modify state from, for example, a computed value or the render function of a React component? You can wrap side effects in 'runInAction' (or decorate functions with 'action') if needed. Tried to modify: ") + atom.name_);
      }
      function checkIfStateReadsAreAllowed(observable) {
        "production" !== NODE_ENV && !globalState.allowStateReads && globalState.observableRequiresReaction && console.warn("[mobx] Observable " + observable.name_ + " being read outside a reactive context");
      }
      function trackDerivedFunction(derivation, f, context) {
        var prevAllowStateReads = allowStateReadsStart(true);
        changeDependenciesStateTo0(derivation);
        derivation.newObserving_ = new Array(derivation.observing_.length + 100);
        derivation.unboundDepsCount_ = 0;
        derivation.runId_ = ++globalState.runId;
        var prevTracking = globalState.trackingDerivation;
        globalState.trackingDerivation = derivation;
        globalState.inBatch++;
        var result;
        if (true === globalState.disableErrorBoundaries) result = f.call(context); else try {
          result = f.call(context);
        } catch (e) {
          result = new CaughtException(e);
        }
        globalState.inBatch--;
        globalState.trackingDerivation = prevTracking;
        bindDependencies(derivation);
        warnAboutDerivationWithoutDependencies(derivation);
        allowStateReadsEnd(prevAllowStateReads);
        return result;
      }
      function warnAboutDerivationWithoutDependencies(derivation) {
        if (!("production" !== NODE_ENV)) return;
        if (0 !== derivation.observing_.length) return;
        (globalState.reactionRequiresObservable || derivation.requiresObservable_) && console.warn("[mobx] Derivation " + derivation.name_ + " is created/updated without reading any observable value");
      }
      function bindDependencies(derivation) {
        var prevObserving = derivation.observing_;
        var observing = derivation.observing_ = derivation.newObserving_;
        var lowestNewObservingDerivationState = IDerivationState_.UP_TO_DATE_;
        var i0 = 0, l = derivation.unboundDepsCount_;
        for (var i = 0; i < l; i++) {
          var dep = observing[i];
          if (0 === dep.diffValue_) {
            dep.diffValue_ = 1;
            i0 !== i && (observing[i0] = dep);
            i0++;
          }
          dep.dependenciesState_ > lowestNewObservingDerivationState && (lowestNewObservingDerivationState = dep.dependenciesState_);
        }
        observing.length = i0;
        derivation.newObserving_ = null;
        l = prevObserving.length;
        while (l--) {
          var _dep = prevObserving[l];
          0 === _dep.diffValue_ && removeObserver(_dep, derivation);
          _dep.diffValue_ = 0;
        }
        while (i0--) {
          var _dep2 = observing[i0];
          if (1 === _dep2.diffValue_) {
            _dep2.diffValue_ = 0;
            addObserver(_dep2, derivation);
          }
        }
        if (lowestNewObservingDerivationState !== IDerivationState_.UP_TO_DATE_) {
          derivation.dependenciesState_ = lowestNewObservingDerivationState;
          derivation.onBecomeStale_();
        }
      }
      function clearObserving(derivation) {
        var obs = derivation.observing_;
        derivation.observing_ = [];
        var i = obs.length;
        while (i--) removeObserver(obs[i], derivation);
        derivation.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
      }
      function untracked(action) {
        var prev = untrackedStart();
        try {
          return action();
        } finally {
          untrackedEnd(prev);
        }
      }
      function untrackedStart() {
        var prev = globalState.trackingDerivation;
        globalState.trackingDerivation = null;
        return prev;
      }
      function untrackedEnd(prev) {
        globalState.trackingDerivation = prev;
      }
      function allowStateReadsStart(allowStateReads) {
        var prev = globalState.allowStateReads;
        globalState.allowStateReads = allowStateReads;
        return prev;
      }
      function allowStateReadsEnd(prev) {
        globalState.allowStateReads = prev;
      }
      function changeDependenciesStateTo0(derivation) {
        if (derivation.dependenciesState_ === IDerivationState_.UP_TO_DATE_) return;
        derivation.dependenciesState_ = IDerivationState_.UP_TO_DATE_;
        var obs = derivation.observing_;
        var i = obs.length;
        while (i--) obs[i].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
      }
      var persistentKeys = [ "mobxGuid", "spyListeners", "enforceActions", "computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "allowStateReads", "disableErrorBoundaries", "runId", "UNCHANGED", "useProxies" ];
      var MobXGlobals = function MobXGlobals() {
        this.version = 6;
        this.UNCHANGED = {};
        this.trackingDerivation = null;
        this.trackingContext = null;
        this.runId = 0;
        this.mobxGuid = 0;
        this.inBatch = 0;
        this.pendingUnobservations = [];
        this.pendingReactions = [];
        this.isRunningReactions = false;
        this.allowStateChanges = false;
        this.allowStateReads = true;
        this.enforceActions = true;
        this.spyListeners = [];
        this.globalReactionErrorHandlers = [];
        this.computedRequiresReaction = false;
        this.reactionRequiresObservable = false;
        this.observableRequiresReaction = false;
        this.disableErrorBoundaries = false;
        this.suppressReactionErrors = false;
        this.useProxies = true;
        this.verifyProxies = false;
        this.safeDescriptors = true;
      };
      var canMergeGlobalState = true;
      var isolateCalled = false;
      var globalState = function() {
        var global = getGlobal();
        global.__mobxInstanceCount > 0 && !global.__mobxGlobals && (canMergeGlobalState = false);
        global.__mobxGlobals && global.__mobxGlobals.version !== new MobXGlobals().version && (canMergeGlobalState = false);
        if (canMergeGlobalState) {
          if (global.__mobxGlobals) {
            global.__mobxInstanceCount += 1;
            global.__mobxGlobals.UNCHANGED || (global.__mobxGlobals.UNCHANGED = {});
            return global.__mobxGlobals;
          }
          global.__mobxInstanceCount = 1;
          return global.__mobxGlobals = new MobXGlobals();
        }
        setTimeout(function() {
          isolateCalled || die(35);
        }, 1);
        return new MobXGlobals();
      }();
      function isolateGlobalState() {
        (globalState.pendingReactions.length || globalState.inBatch || globalState.isRunningReactions) && die(36);
        isolateCalled = true;
        if (canMergeGlobalState) {
          var global = getGlobal();
          0 === --global.__mobxInstanceCount && (global.__mobxGlobals = void 0);
          globalState = new MobXGlobals();
        }
      }
      function getGlobalState() {
        return globalState;
      }
      function resetGlobalState() {
        var defaultGlobals = new MobXGlobals();
        for (var key in defaultGlobals) -1 === persistentKeys.indexOf(key) && (globalState[key] = defaultGlobals[key]);
        globalState.allowStateChanges = !globalState.enforceActions;
      }
      function hasObservers(observable) {
        return observable.observers_ && observable.observers_.size > 0;
      }
      function getObservers(observable) {
        return observable.observers_;
      }
      function addObserver(observable, node) {
        observable.observers_.add(node);
        observable.lowestObserverState_ > node.dependenciesState_ && (observable.lowestObserverState_ = node.dependenciesState_);
      }
      function removeObserver(observable, node) {
        observable.observers_["delete"](node);
        0 === observable.observers_.size && queueForUnobservation(observable);
      }
      function queueForUnobservation(observable) {
        if (false === observable.isPendingUnobservation_) {
          observable.isPendingUnobservation_ = true;
          globalState.pendingUnobservations.push(observable);
        }
      }
      function startBatch() {
        globalState.inBatch++;
      }
      function endBatch() {
        if (0 === --globalState.inBatch) {
          runReactions();
          var list = globalState.pendingUnobservations;
          for (var i = 0; i < list.length; i++) {
            var observable = list[i];
            observable.isPendingUnobservation_ = false;
            if (0 === observable.observers_.size) {
              if (observable.isBeingObserved_) {
                observable.isBeingObserved_ = false;
                observable.onBUO();
              }
              observable instanceof ComputedValue && observable.suspend_();
            }
          }
          globalState.pendingUnobservations = [];
        }
      }
      function reportObserved(observable) {
        checkIfStateReadsAreAllowed(observable);
        var derivation = globalState.trackingDerivation;
        if (null !== derivation) {
          if (derivation.runId_ !== observable.lastAccessedBy_) {
            observable.lastAccessedBy_ = derivation.runId_;
            derivation.newObserving_[derivation.unboundDepsCount_++] = observable;
            if (!observable.isBeingObserved_ && globalState.trackingContext) {
              observable.isBeingObserved_ = true;
              observable.onBO();
            }
          }
          return true;
        }
        0 === observable.observers_.size && globalState.inBatch > 0 && queueForUnobservation(observable);
        return false;
      }
      function propagateChanged(observable) {
        if (observable.lowestObserverState_ === IDerivationState_.STALE_) return;
        observable.lowestObserverState_ = IDerivationState_.STALE_;
        observable.observers_.forEach(function(d) {
          if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
            "production" !== NODE_ENV && d.isTracing_ !== TraceMode.NONE && logTraceInfo(d, observable);
            d.onBecomeStale_();
          }
          d.dependenciesState_ = IDerivationState_.STALE_;
        });
      }
      function propagateChangeConfirmed(observable) {
        if (observable.lowestObserverState_ === IDerivationState_.STALE_) return;
        observable.lowestObserverState_ = IDerivationState_.STALE_;
        observable.observers_.forEach(function(d) {
          if (d.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_) {
            d.dependenciesState_ = IDerivationState_.STALE_;
            "production" !== NODE_ENV && d.isTracing_ !== TraceMode.NONE && logTraceInfo(d, observable);
          } else d.dependenciesState_ === IDerivationState_.UP_TO_DATE_ && (observable.lowestObserverState_ = IDerivationState_.UP_TO_DATE_);
        });
      }
      function propagateMaybeChanged(observable) {
        if (observable.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_) return;
        observable.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_;
        observable.observers_.forEach(function(d) {
          if (d.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
            d.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_;
            d.onBecomeStale_();
          }
        });
      }
      function logTraceInfo(derivation, observable) {
        console.log("[mobx.trace] '" + derivation.name_ + "' is invalidated due to a change in: '" + observable.name_ + "'");
        if (derivation.isTracing_ === TraceMode.BREAK) {
          var lines = [];
          printDepTree(getDependencyTree(derivation), lines, 1);
          new Function("debugger;\n/*\nTracing '" + derivation.name_ + "'\n\nYou are entering this break point because derivation '" + derivation.name_ + "' is being traced and '" + observable.name_ + "' is now forcing it to update.\nJust follow the stacktrace you should now see in the devtools to see precisely what piece of your code is causing this update\nThe stackframe you are looking for is at least ~6-8 stack-frames up.\n\n" + (derivation instanceof ComputedValue ? derivation.derivation.toString().replace(/[*]\//g, "/") : "") + "\n\nThe dependencies for this derivation are:\n\n" + lines.join("\n") + "\n*/\n    ")();
        }
      }
      function printDepTree(tree, lines, depth) {
        if (lines.length >= 1e3) {
          lines.push("(and many more)");
          return;
        }
        lines.push("" + new Array(depth).join("\t") + tree.name);
        tree.dependencies && tree.dependencies.forEach(function(child) {
          return printDepTree(child, lines, depth + 1);
        });
      }
      var Reaction = function() {
        function Reaction(name_, onInvalidate_, errorHandler_, requiresObservable_) {
          void 0 === name_ && (name_ = "production" !== NODE_ENV ? "Reaction@" + getNextId() : "Reaction");
          void 0 === requiresObservable_ && (requiresObservable_ = false);
          this.name_ = void 0;
          this.onInvalidate_ = void 0;
          this.errorHandler_ = void 0;
          this.requiresObservable_ = void 0;
          this.observing_ = [];
          this.newObserving_ = [];
          this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
          this.diffValue_ = 0;
          this.runId_ = 0;
          this.unboundDepsCount_ = 0;
          this.isDisposed_ = false;
          this.isScheduled_ = false;
          this.isTrackPending_ = false;
          this.isRunning_ = false;
          this.isTracing_ = TraceMode.NONE;
          this.name_ = name_;
          this.onInvalidate_ = onInvalidate_;
          this.errorHandler_ = errorHandler_;
          this.requiresObservable_ = requiresObservable_;
        }
        var _proto = Reaction.prototype;
        _proto.onBecomeStale_ = function onBecomeStale_() {
          this.schedule_();
        };
        _proto.schedule_ = function schedule_() {
          if (!this.isScheduled_) {
            this.isScheduled_ = true;
            globalState.pendingReactions.push(this);
            runReactions();
          }
        };
        _proto.isScheduled = function isScheduled() {
          return this.isScheduled_;
        };
        _proto.runReaction_ = function runReaction_() {
          if (!this.isDisposed_) {
            startBatch();
            this.isScheduled_ = false;
            var prev = globalState.trackingContext;
            globalState.trackingContext = this;
            if (shouldCompute(this)) {
              this.isTrackPending_ = true;
              try {
                this.onInvalidate_();
                "production" !== NODE_ENV && this.isTrackPending_ && isSpyEnabled() && spyReport({
                  name: this.name_,
                  type: "scheduled-reaction"
                });
              } catch (e) {
                this.reportExceptionInDerivation_(e);
              }
            }
            globalState.trackingContext = prev;
            endBatch();
          }
        };
        _proto.track = function track(fn) {
          if (this.isDisposed_) return;
          startBatch();
          var notify = isSpyEnabled();
          var startTime;
          if ("production" !== NODE_ENV && notify) {
            startTime = Date.now();
            spyReportStart({
              name: this.name_,
              type: "reaction"
            });
          }
          this.isRunning_ = true;
          var prevReaction = globalState.trackingContext;
          globalState.trackingContext = this;
          var result = trackDerivedFunction(this, fn, void 0);
          globalState.trackingContext = prevReaction;
          this.isRunning_ = false;
          this.isTrackPending_ = false;
          this.isDisposed_ && clearObserving(this);
          isCaughtException(result) && this.reportExceptionInDerivation_(result.cause);
          "production" !== NODE_ENV && notify && spyReportEnd({
            time: Date.now() - startTime
          });
          endBatch();
        };
        _proto.reportExceptionInDerivation_ = function reportExceptionInDerivation_(error) {
          var _this = this;
          if (this.errorHandler_) {
            this.errorHandler_(error, this);
            return;
          }
          if (globalState.disableErrorBoundaries) throw error;
          var message = "production" !== NODE_ENV ? "[mobx] Encountered an uncaught exception that was thrown by a reaction or observer component, in: '" + this + "'" : "[mobx] uncaught error in '" + this + "'";
          globalState.suppressReactionErrors ? "production" !== NODE_ENV && console.warn("[mobx] (error in reaction '" + this.name_ + "' suppressed, fix error of causing action below)") : console.error(message, error);
          "production" !== NODE_ENV && isSpyEnabled() && spyReport({
            type: "error",
            name: this.name_,
            message: message,
            error: "" + error
          });
          globalState.globalReactionErrorHandlers.forEach(function(f) {
            return f(error, _this);
          });
        };
        _proto.dispose = function dispose() {
          if (!this.isDisposed_) {
            this.isDisposed_ = true;
            if (!this.isRunning_) {
              startBatch();
              clearObserving(this);
              endBatch();
            }
          }
        };
        _proto.getDisposer_ = function getDisposer_() {
          var r = this.dispose.bind(this);
          r[$mobx] = this;
          return r;
        };
        _proto.toString = function toString() {
          return "Reaction[" + this.name_ + "]";
        };
        _proto.trace = function trace$1(enterBreakPoint) {
          void 0 === enterBreakPoint && (enterBreakPoint = false);
          trace(this, enterBreakPoint);
        };
        return Reaction;
      }();
      exports.Reaction = Reaction;
      function onReactionError(handler) {
        globalState.globalReactionErrorHandlers.push(handler);
        return function() {
          var idx = globalState.globalReactionErrorHandlers.indexOf(handler);
          idx >= 0 && globalState.globalReactionErrorHandlers.splice(idx, 1);
        };
      }
      var MAX_REACTION_ITERATIONS = 100;
      var reactionScheduler = function reactionScheduler(f) {
        return f();
      };
      function runReactions() {
        if (globalState.inBatch > 0 || globalState.isRunningReactions) return;
        reactionScheduler(runReactionsHelper);
      }
      function runReactionsHelper() {
        globalState.isRunningReactions = true;
        var allReactions = globalState.pendingReactions;
        var iterations = 0;
        while (allReactions.length > 0) {
          if (++iterations === MAX_REACTION_ITERATIONS) {
            console.error("production" !== NODE_ENV ? "Reaction doesn't converge to a stable state after " + MAX_REACTION_ITERATIONS + " iterations. Probably there is a cycle in the reactive function: " + allReactions[0] : "[mobx] cycle in reaction: " + allReactions[0]);
            allReactions.splice(0);
          }
          var remainingReactions = allReactions.splice(0);
          for (var i = 0, l = remainingReactions.length; i < l; i++) remainingReactions[i].runReaction_();
        }
        globalState.isRunningReactions = false;
      }
      var isReaction = createInstanceofPredicate("Reaction", Reaction);
      function setReactionScheduler(fn) {
        var baseScheduler = reactionScheduler;
        reactionScheduler = function reactionScheduler(f) {
          return fn(function() {
            return baseScheduler(f);
          });
        };
      }
      function isSpyEnabled() {
        return "production" !== NODE_ENV && !!globalState.spyListeners.length;
      }
      function spyReport(event) {
        if (!("production" !== NODE_ENV)) return;
        if (!globalState.spyListeners.length) return;
        var listeners = globalState.spyListeners;
        for (var i = 0, l = listeners.length; i < l; i++) listeners[i](event);
      }
      function spyReportStart(event) {
        if (!("production" !== NODE_ENV)) return;
        var change = _extends({}, event, {
          spyReportStart: true
        });
        spyReport(change);
      }
      var END_EVENT = {
        type: "report-end",
        spyReportEnd: true
      };
      function spyReportEnd(change) {
        if (!("production" !== NODE_ENV)) return;
        spyReport(change ? _extends({}, change, {
          type: "report-end",
          spyReportEnd: true
        }) : END_EVENT);
      }
      function spy(listener) {
        if ("production" !== NODE_ENV) {
          globalState.spyListeners.push(listener);
          return once(function() {
            globalState.spyListeners = globalState.spyListeners.filter(function(l) {
              return l !== listener;
            });
          });
        }
        console.warn("[mobx.spy] Is a no-op in production builds");
        return function() {};
      }
      var ACTION = "action";
      var ACTION_BOUND = "action.bound";
      var AUTOACTION = "autoAction";
      var AUTOACTION_BOUND = "autoAction.bound";
      var DEFAULT_ACTION_NAME = "<unnamed action>";
      var actionAnnotation = createActionAnnotation(ACTION);
      var actionBoundAnnotation = createActionAnnotation(ACTION_BOUND, {
        bound: true
      });
      var autoActionAnnotation = createActionAnnotation(AUTOACTION, {
        autoAction: true
      });
      var autoActionBoundAnnotation = createActionAnnotation(AUTOACTION_BOUND, {
        autoAction: true,
        bound: true
      });
      function createActionFactory(autoAction) {
        var res = function action(arg1, arg2) {
          if (isFunction(arg1)) return createAction(arg1.name || DEFAULT_ACTION_NAME, arg1, autoAction);
          if (isFunction(arg2)) return createAction(arg1, arg2, autoAction);
          if (isStringish(arg2)) return storeAnnotation(arg1, arg2, autoAction ? autoActionAnnotation : actionAnnotation);
          if (isStringish(arg1)) return createDecoratorAnnotation(createActionAnnotation(autoAction ? AUTOACTION : ACTION, {
            name: arg1,
            autoAction: autoAction
          }));
          "production" !== NODE_ENV && die("Invalid arguments for `action`");
        };
        return res;
      }
      var action = createActionFactory(false);
      exports.action = action;
      Object.assign(action, actionAnnotation);
      var autoAction = createActionFactory(true);
      exports._autoAction = autoAction;
      Object.assign(autoAction, autoActionAnnotation);
      action.bound = createDecoratorAnnotation(actionBoundAnnotation);
      autoAction.bound = createDecoratorAnnotation(autoActionBoundAnnotation);
      function runInAction(fn) {
        return executeAction(fn.name || DEFAULT_ACTION_NAME, false, fn, this, void 0);
      }
      function isAction(thing) {
        return isFunction(thing) && true === thing.isMobxAction;
      }
      function autorun(view, opts) {
        var _opts$name, _opts;
        void 0 === opts && (opts = EMPTY_OBJECT);
        if ("production" !== NODE_ENV) {
          isFunction(view) || die("Autorun expects a function as first argument");
          isAction(view) && die("Autorun does not accept actions since actions are untrackable");
        }
        var name = null != (_opts$name = null == (_opts = opts) ? void 0 : _opts.name) ? _opts$name : "production" !== NODE_ENV ? view.name || "Autorun@" + getNextId() : "Autorun";
        var runSync = !opts.scheduler && !opts.delay;
        var reaction;
        if (runSync) reaction = new Reaction(name, function() {
          this.track(reactionRunner);
        }, opts.onError, opts.requiresObservable); else {
          var scheduler = createSchedulerFromOptions(opts);
          var isScheduled = false;
          reaction = new Reaction(name, function() {
            if (!isScheduled) {
              isScheduled = true;
              scheduler(function() {
                isScheduled = false;
                reaction.isDisposed_ || reaction.track(reactionRunner);
              });
            }
          }, opts.onError, opts.requiresObservable);
        }
        function reactionRunner() {
          view(reaction);
        }
        reaction.schedule_();
        return reaction.getDisposer_();
      }
      var run = function run(f) {
        return f();
      };
      function createSchedulerFromOptions(opts) {
        return opts.scheduler ? opts.scheduler : opts.delay ? function(f) {
          return setTimeout(f, opts.delay);
        } : run;
      }
      function reaction(expression, effect, opts) {
        var _opts$name2;
        void 0 === opts && (opts = EMPTY_OBJECT);
        if ("production" !== NODE_ENV) {
          isFunction(expression) && isFunction(effect) || die("First and second argument to reaction should be functions");
          isPlainObject(opts) || die("Third argument of reactions should be an object");
        }
        var name = null != (_opts$name2 = opts.name) ? _opts$name2 : "production" !== NODE_ENV ? "Reaction@" + getNextId() : "Reaction";
        var effectAction = action(name, opts.onError ? wrapErrorHandler(opts.onError, effect) : effect);
        var runSync = !opts.scheduler && !opts.delay;
        var scheduler = createSchedulerFromOptions(opts);
        var firstTime = true;
        var isScheduled = false;
        var value;
        var oldValue = void 0;
        var equals = opts.compareStructural ? comparer.structural : opts.equals || comparer["default"];
        var r = new Reaction(name, function() {
          if (firstTime || runSync) reactionRunner(); else if (!isScheduled) {
            isScheduled = true;
            scheduler(reactionRunner);
          }
        }, opts.onError, opts.requiresObservable);
        function reactionRunner() {
          isScheduled = false;
          if (r.isDisposed_) return;
          var changed = false;
          r.track(function() {
            var nextValue = allowStateChanges(false, function() {
              return expression(r);
            });
            changed = firstTime || !equals(value, nextValue);
            oldValue = value;
            value = nextValue;
          });
          firstTime && opts.fireImmediately ? effectAction(value, oldValue, r) : !firstTime && changed && effectAction(value, oldValue, r);
          firstTime = false;
        }
        r.schedule_();
        return r.getDisposer_();
      }
      function wrapErrorHandler(errorHandler, baseFn) {
        return function() {
          try {
            return baseFn.apply(this, arguments);
          } catch (e) {
            errorHandler.call(this, e);
          }
        };
      }
      var ON_BECOME_OBSERVED = "onBO";
      var ON_BECOME_UNOBSERVED = "onBUO";
      function onBecomeObserved(thing, arg2, arg3) {
        return interceptHook(ON_BECOME_OBSERVED, thing, arg2, arg3);
      }
      function onBecomeUnobserved(thing, arg2, arg3) {
        return interceptHook(ON_BECOME_UNOBSERVED, thing, arg2, arg3);
      }
      function interceptHook(hook, thing, arg2, arg3) {
        var atom = "function" === typeof arg3 ? getAtom(thing, arg2) : getAtom(thing);
        var cb = isFunction(arg3) ? arg3 : arg2;
        var listenersKey = hook + "L";
        atom[listenersKey] ? atom[listenersKey].add(cb) : atom[listenersKey] = new Set([ cb ]);
        return function() {
          var hookListeners = atom[listenersKey];
          if (hookListeners) {
            hookListeners["delete"](cb);
            0 === hookListeners.size && delete atom[listenersKey];
          }
        };
      }
      var NEVER = "never";
      var ALWAYS = "always";
      var OBSERVED = "observed";
      function configure(options) {
        true === options.isolateGlobalState && isolateGlobalState();
        var useProxies = options.useProxies, enforceActions = options.enforceActions;
        void 0 !== useProxies && (globalState.useProxies = useProxies === ALWAYS || useProxies !== NEVER && "undefined" !== typeof Proxy);
        "ifavailable" === useProxies && (globalState.verifyProxies = true);
        if (void 0 !== enforceActions) {
          var ea = enforceActions === ALWAYS ? ALWAYS : enforceActions === OBSERVED;
          globalState.enforceActions = ea;
          globalState.allowStateChanges = true !== ea && ea !== ALWAYS;
        }
        [ "computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "disableErrorBoundaries", "safeDescriptors" ].forEach(function(key) {
          key in options && (globalState[key] = !!options[key]);
        });
        globalState.allowStateReads = !globalState.observableRequiresReaction;
        "production" !== NODE_ENV && true === globalState.disableErrorBoundaries && console.warn("WARNING: Debug feature only. MobX will NOT recover from errors when `disableErrorBoundaries` is enabled.");
        options.reactionScheduler && setReactionScheduler(options.reactionScheduler);
      }
      function extendObservable(target, properties, annotations, options) {
        if ("production" !== NODE_ENV) {
          arguments.length > 4 && die("'extendObservable' expected 2-4 arguments");
          "object" !== typeof target && die("'extendObservable' expects an object as first argument");
          isObservableMap(target) && die("'extendObservable' should not be used on maps, use map.merge instead");
          isPlainObject(properties) || die("'extendObservabe' only accepts plain objects as second argument");
          (isObservable(properties) || isObservable(annotations)) && die("Extending an object with another observable (object) is not supported");
        }
        var descriptors = getOwnPropertyDescriptors(properties);
        var adm = asObservableObject(target, options)[$mobx];
        startBatch();
        try {
          ownKeys(descriptors).forEach(function(key) {
            adm.extend_(key, descriptors[key], !annotations || (!(key in annotations) || annotations[key]));
          });
        } finally {
          endBatch();
        }
        return target;
      }
      function getDependencyTree(thing, property) {
        return nodeToDependencyTree(getAtom(thing, property));
      }
      function nodeToDependencyTree(node) {
        var result = {
          name: node.name_
        };
        node.observing_ && node.observing_.length > 0 && (result.dependencies = unique(node.observing_).map(nodeToDependencyTree));
        return result;
      }
      function getObserverTree(thing, property) {
        return nodeToObserverTree(getAtom(thing, property));
      }
      function nodeToObserverTree(node) {
        var result = {
          name: node.name_
        };
        hasObservers(node) && (result.observers = Array.from(getObservers(node)).map(nodeToObserverTree));
        return result;
      }
      function unique(list) {
        return Array.from(new Set(list));
      }
      var generatorId = 0;
      function FlowCancellationError() {
        this.message = "FLOW_CANCELLED";
      }
      FlowCancellationError.prototype = Object.create(Error.prototype);
      function isFlowCancellationError(error) {
        return error instanceof FlowCancellationError;
      }
      var flowAnnotation = createFlowAnnotation("flow");
      var flowBoundAnnotation = createFlowAnnotation("flow.bound", {
        bound: true
      });
      var flow = Object.assign(function flow(arg1, arg2) {
        if (isStringish(arg2)) return storeAnnotation(arg1, arg2, flowAnnotation);
        "production" !== NODE_ENV && 1 !== arguments.length && die("Flow expects single argument with generator function");
        var generator = arg1;
        var name = generator.name || "<unnamed flow>";
        var res = function res() {
          var ctx = this;
          var args = arguments;
          var runId = ++generatorId;
          var gen = action(name + " - runid: " + runId + " - init", generator).apply(ctx, args);
          var rejector;
          var pendingPromise = void 0;
          var promise = new Promise(function(resolve, reject) {
            var stepId = 0;
            rejector = reject;
            function onFulfilled(res) {
              pendingPromise = void 0;
              var ret;
              try {
                ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen.next).call(gen, res);
              } catch (e) {
                return reject(e);
              }
              next(ret);
            }
            function onRejected(err) {
              pendingPromise = void 0;
              var ret;
              try {
                ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen["throw"]).call(gen, err);
              } catch (e) {
                return reject(e);
              }
              next(ret);
            }
            function next(ret) {
              if (isFunction(null == ret ? void 0 : ret.then)) {
                ret.then(next, reject);
                return;
              }
              if (ret.done) return resolve(ret.value);
              pendingPromise = Promise.resolve(ret.value);
              return pendingPromise.then(onFulfilled, onRejected);
            }
            onFulfilled(void 0);
          });
          promise.cancel = action(name + " - runid: " + runId + " - cancel", function() {
            try {
              pendingPromise && cancelPromise(pendingPromise);
              var _res = gen["return"](void 0);
              var yieldedPromise = Promise.resolve(_res.value);
              yieldedPromise.then(noop, noop);
              cancelPromise(yieldedPromise);
              rejector(new FlowCancellationError());
            } catch (e) {
              rejector(e);
            }
          });
          return promise;
        };
        res.isMobXFlow = true;
        return res;
      }, flowAnnotation);
      exports.flow = flow;
      flow.bound = createDecoratorAnnotation(flowBoundAnnotation);
      function cancelPromise(promise) {
        isFunction(promise.cancel) && promise.cancel();
      }
      function flowResult(result) {
        return result;
      }
      function isFlow(fn) {
        return true === (null == fn ? void 0 : fn.isMobXFlow);
      }
      function interceptReads(thing, propOrHandler, handler) {
        var target;
        if (isObservableMap(thing) || isObservableArray(thing) || isObservableValue(thing)) target = getAdministration(thing); else if (isObservableObject(thing)) {
          if ("production" !== NODE_ENV && !isStringish(propOrHandler)) return die("InterceptReads can only be used with a specific property, not with an object in general");
          target = getAdministration(thing, propOrHandler);
        } else if ("production" !== NODE_ENV) return die("Expected observable map, object or array as first array");
        if ("production" !== NODE_ENV && void 0 !== target.dehancer) return die("An intercept reader was already established");
        target.dehancer = "function" === typeof propOrHandler ? propOrHandler : handler;
        return function() {
          target.dehancer = void 0;
        };
      }
      function intercept(thing, propOrHandler, handler) {
        return isFunction(handler) ? interceptProperty(thing, propOrHandler, handler) : interceptInterceptable(thing, propOrHandler);
      }
      function interceptInterceptable(thing, handler) {
        return getAdministration(thing).intercept_(handler);
      }
      function interceptProperty(thing, property, handler) {
        return getAdministration(thing, property).intercept_(handler);
      }
      function _isComputed(value, property) {
        if (void 0 !== property) {
          if (false === isObservableObject(value)) return false;
          if (!value[$mobx].values_.has(property)) return false;
          var atom = getAtom(value, property);
          return isComputedValue(atom);
        }
        return isComputedValue(value);
      }
      function isComputed(value) {
        if ("production" !== NODE_ENV && arguments.length > 1) return die("isComputed expects only 1 argument. Use isComputedProp to inspect the observability of a property");
        return _isComputed(value);
      }
      function isComputedProp(value, propName) {
        if ("production" !== NODE_ENV && !isStringish(propName)) return die("isComputed expected a property name as second argument");
        return _isComputed(value, propName);
      }
      function _isObservable(value, property) {
        if (!value) return false;
        if (void 0 !== property) {
          if ("production" !== NODE_ENV && (isObservableMap(value) || isObservableArray(value))) return die("isObservable(object, propertyName) is not supported for arrays and maps. Use map.has or array.length instead.");
          if (isObservableObject(value)) return value[$mobx].values_.has(property);
          return false;
        }
        return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);
      }
      function isObservable(value) {
        "production" !== NODE_ENV && 1 !== arguments.length && die("isObservable expects only 1 argument. Use isObservableProp to inspect the observability of a property");
        return _isObservable(value);
      }
      function isObservableProp(value, propName) {
        if ("production" !== NODE_ENV && !isStringish(propName)) return die("expected a property name as second argument");
        return _isObservable(value, propName);
      }
      function keys(obj) {
        if (isObservableObject(obj)) return obj[$mobx].keys_();
        if (isObservableMap(obj) || isObservableSet(obj)) return Array.from(obj.keys());
        if (isObservableArray(obj)) return obj.map(function(_, index) {
          return index;
        });
        die(5);
      }
      function values(obj) {
        if (isObservableObject(obj)) return keys(obj).map(function(key) {
          return obj[key];
        });
        if (isObservableMap(obj)) return keys(obj).map(function(key) {
          return obj.get(key);
        });
        if (isObservableSet(obj)) return Array.from(obj.values());
        if (isObservableArray(obj)) return obj.slice();
        die(6);
      }
      function entries(obj) {
        if (isObservableObject(obj)) return keys(obj).map(function(key) {
          return [ key, obj[key] ];
        });
        if (isObservableMap(obj)) return keys(obj).map(function(key) {
          return [ key, obj.get(key) ];
        });
        if (isObservableSet(obj)) return Array.from(obj.entries());
        if (isObservableArray(obj)) return obj.map(function(key, index) {
          return [ index, key ];
        });
        die(7);
      }
      function set(obj, key, value) {
        if (2 === arguments.length && !isObservableSet(obj)) {
          startBatch();
          var _values = key;
          try {
            for (var _key in _values) set(obj, _key, _values[_key]);
          } finally {
            endBatch();
          }
          return;
        }
        if (isObservableObject(obj)) obj[$mobx].set_(key, value); else if (isObservableMap(obj)) obj.set(key, value); else if (isObservableSet(obj)) obj.add(key); else if (isObservableArray(obj)) {
          "number" !== typeof key && (key = parseInt(key, 10));
          key < 0 && die("Invalid index: '" + key + "'");
          startBatch();
          key >= obj.length && (obj.length = key + 1);
          obj[key] = value;
          endBatch();
        } else die(8);
      }
      function remove(obj, key) {
        if (isObservableObject(obj)) obj[$mobx].delete_(key); else if (isObservableMap(obj)) obj["delete"](key); else if (isObservableSet(obj)) obj["delete"](key); else if (isObservableArray(obj)) {
          "number" !== typeof key && (key = parseInt(key, 10));
          obj.splice(key, 1);
        } else die(9);
      }
      function has(obj, key) {
        if (isObservableObject(obj)) return obj[$mobx].has_(key);
        if (isObservableMap(obj)) return obj.has(key);
        if (isObservableSet(obj)) return obj.has(key);
        if (isObservableArray(obj)) return key >= 0 && key < obj.length;
        die(10);
      }
      function get(obj, key) {
        if (!has(obj, key)) return;
        if (isObservableObject(obj)) return obj[$mobx].get_(key);
        if (isObservableMap(obj)) return obj.get(key);
        if (isObservableArray(obj)) return obj[key];
        die(11);
      }
      function apiDefineProperty(obj, key, descriptor) {
        if (isObservableObject(obj)) return obj[$mobx].defineProperty_(key, descriptor);
        die(39);
      }
      function apiOwnKeys(obj) {
        if (isObservableObject(obj)) return obj[$mobx].ownKeys_();
        die(38);
      }
      function observe(thing, propOrCb, cbOrFire, fireImmediately) {
        return isFunction(cbOrFire) ? observeObservableProperty(thing, propOrCb, cbOrFire, fireImmediately) : observeObservable(thing, propOrCb, cbOrFire);
      }
      function observeObservable(thing, listener, fireImmediately) {
        return getAdministration(thing).observe_(listener, fireImmediately);
      }
      function observeObservableProperty(thing, property, listener, fireImmediately) {
        return getAdministration(thing, property).observe_(listener, fireImmediately);
      }
      function cache(map, key, value) {
        map.set(key, value);
        return value;
      }
      function toJSHelper(source, __alreadySeen) {
        if (null == source || "object" !== typeof source || source instanceof Date || !isObservable(source)) return source;
        if (isObservableValue(source) || isComputedValue(source)) return toJSHelper(source.get(), __alreadySeen);
        if (__alreadySeen.has(source)) return __alreadySeen.get(source);
        if (isObservableArray(source)) {
          var res = cache(__alreadySeen, source, new Array(source.length));
          source.forEach(function(value, idx) {
            res[idx] = toJSHelper(value, __alreadySeen);
          });
          return res;
        }
        if (isObservableSet(source)) {
          var _res = cache(__alreadySeen, source, new Set());
          source.forEach(function(value) {
            _res.add(toJSHelper(value, __alreadySeen));
          });
          return _res;
        }
        if (isObservableMap(source)) {
          var _res2 = cache(__alreadySeen, source, new Map());
          source.forEach(function(value, key) {
            _res2.set(key, toJSHelper(value, __alreadySeen));
          });
          return _res2;
        }
        var _res3 = cache(__alreadySeen, source, {});
        apiOwnKeys(source).forEach(function(key) {
          objectPrototype.propertyIsEnumerable.call(source, key) && (_res3[key] = toJSHelper(source[key], __alreadySeen));
        });
        return _res3;
      }
      function toJS(source, options) {
        "production" !== NODE_ENV && options && die("toJS no longer supports options");
        return toJSHelper(source, new Map());
      }
      function trace() {
        "production" !== NODE_ENV || die("trace() is not available in production builds");
        var enterBreakPoint = false;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) args[_key] = arguments[_key];
        "boolean" === typeof args[args.length - 1] && (enterBreakPoint = args.pop());
        var derivation = getAtomFromArgs(args);
        if (!derivation) return die("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");
        derivation.isTracing_ === TraceMode.NONE && console.log("[mobx.trace] '" + derivation.name_ + "' tracing enabled");
        derivation.isTracing_ = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG;
      }
      function getAtomFromArgs(args) {
        switch (args.length) {
         case 0:
          return globalState.trackingDerivation;

         case 1:
          return getAtom(args[0]);

         case 2:
          return getAtom(args[0], args[1]);
        }
      }
      function transaction(action, thisArg) {
        void 0 === thisArg && (thisArg = void 0);
        startBatch();
        try {
          return action.apply(thisArg);
        } finally {
          endBatch();
        }
      }
      function when(predicate, arg1, arg2) {
        if (1 === arguments.length || arg1 && "object" === typeof arg1) return whenPromise(predicate, arg1);
        return _when(predicate, arg1, arg2 || {});
      }
      function _when(predicate, effect, opts) {
        var timeoutHandle;
        "number" === typeof opts.timeout && (timeoutHandle = setTimeout(function() {
          if (!disposer[$mobx].isDisposed_) {
            disposer();
            var error = new Error("WHEN_TIMEOUT");
            if (!opts.onError) throw error;
            opts.onError(error);
          }
        }, opts.timeout));
        opts.name = "production" !== NODE_ENV ? opts.name || "When@" + getNextId() : "When";
        var effectAction = createAction("production" !== NODE_ENV ? opts.name + "-effect" : "When-effect", effect);
        var disposer = autorun(function(r) {
          var cond = allowStateChanges(false, predicate);
          if (cond) {
            r.dispose();
            timeoutHandle && clearTimeout(timeoutHandle);
            effectAction();
          }
        }, opts);
        return disposer;
      }
      function whenPromise(predicate, opts) {
        if ("production" !== NODE_ENV && opts && opts.onError) return die("the options 'onError' and 'promise' cannot be combined");
        var cancel;
        var res = new Promise(function(resolve, reject) {
          var disposer = _when(predicate, resolve, _extends({}, opts, {
            onError: reject
          }));
          cancel = function cancel() {
            disposer();
            reject("WHEN_CANCELLED");
          };
        });
        res.cancel = cancel;
        return res;
      }
      function getAdm(target) {
        return target[$mobx];
      }
      var objectProxyTraps = {
        has: function has(target, name) {
          "production" !== NODE_ENV && globalState.trackingDerivation && warnAboutProxyRequirement("detect new properties using the 'in' operator. Use 'has' from 'mobx' instead.");
          return getAdm(target).has_(name);
        },
        get: function get(target, name) {
          return getAdm(target).get_(name);
        },
        set: function set(target, name, value) {
          var _getAdm$set_;
          if (!isStringish(name)) return false;
          "production" === NODE_ENV || getAdm(target).values_.has(name) || warnAboutProxyRequirement("add a new observable property through direct assignment. Use 'set' from 'mobx' instead.");
          return null == (_getAdm$set_ = getAdm(target).set_(name, value, true)) || _getAdm$set_;
        },
        deleteProperty: function deleteProperty(target, name) {
          var _getAdm$delete_;
          "production" !== NODE_ENV && warnAboutProxyRequirement("delete properties from an observable object. Use 'remove' from 'mobx' instead.");
          if (!isStringish(name)) return false;
          return null == (_getAdm$delete_ = getAdm(target).delete_(name, true)) || _getAdm$delete_;
        },
        defineProperty: function defineProperty(target, name, descriptor) {
          var _getAdm$definePropert;
          "production" !== NODE_ENV && warnAboutProxyRequirement("define property on an observable object. Use 'defineProperty' from 'mobx' instead.");
          return null == (_getAdm$definePropert = getAdm(target).defineProperty_(name, descriptor)) || _getAdm$definePropert;
        },
        ownKeys: function ownKeys(target) {
          "production" !== NODE_ENV && globalState.trackingDerivation && warnAboutProxyRequirement("iterate keys to detect added / removed properties. Use 'keys' from 'mobx' instead.");
          return getAdm(target).ownKeys_();
        },
        preventExtensions: function preventExtensions(target) {
          die(13);
        }
      };
      function asDynamicObservableObject(target, options) {
        var _target$$mobx, _target$$mobx$proxy_;
        assertProxies();
        target = asObservableObject(target, options);
        return null != (_target$$mobx$proxy_ = (_target$$mobx = target[$mobx]).proxy_) ? _target$$mobx$proxy_ : _target$$mobx.proxy_ = new Proxy(target, objectProxyTraps);
      }
      function hasInterceptors(interceptable) {
        return void 0 !== interceptable.interceptors_ && interceptable.interceptors_.length > 0;
      }
      function registerInterceptor(interceptable, handler) {
        var interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = []);
        interceptors.push(handler);
        return once(function() {
          var idx = interceptors.indexOf(handler);
          -1 !== idx && interceptors.splice(idx, 1);
        });
      }
      function interceptChange(interceptable, change) {
        var prevU = untrackedStart();
        try {
          var interceptors = [].concat(interceptable.interceptors_ || []);
          for (var i = 0, l = interceptors.length; i < l; i++) {
            change = interceptors[i](change);
            change && !change.type && die(14);
            if (!change) break;
          }
          return change;
        } finally {
          untrackedEnd(prevU);
        }
      }
      function hasListeners(listenable) {
        return void 0 !== listenable.changeListeners_ && listenable.changeListeners_.length > 0;
      }
      function registerListener(listenable, handler) {
        var listeners = listenable.changeListeners_ || (listenable.changeListeners_ = []);
        listeners.push(handler);
        return once(function() {
          var idx = listeners.indexOf(handler);
          -1 !== idx && listeners.splice(idx, 1);
        });
      }
      function notifyListeners(listenable, change) {
        var prevU = untrackedStart();
        var listeners = listenable.changeListeners_;
        if (!listeners) return;
        listeners = listeners.slice();
        for (var i = 0, l = listeners.length; i < l; i++) listeners[i](change);
        untrackedEnd(prevU);
      }
      function makeObservable(target, annotations, options) {
        var adm = asObservableObject(target, options)[$mobx];
        startBatch();
        try {
          var _annotations;
          null != (_annotations = annotations) ? _annotations : annotations = collectStoredAnnotations(target);
          ownKeys(annotations).forEach(function(key) {
            return adm.make_(key, annotations[key]);
          });
        } finally {
          endBatch();
        }
        return target;
      }
      var keysSymbol = Symbol("mobx-keys");
      function makeAutoObservable(target, overrides, options) {
        if ("production" !== NODE_ENV) {
          isPlainObject(target) || isPlainObject(Object.getPrototypeOf(target)) || die("'makeAutoObservable' can only be used for classes that don't have a superclass");
          isObservableObject(target) && die("makeAutoObservable can only be used on objects not already made observable");
        }
        if (isPlainObject(target)) return extendObservable(target, target, overrides, options);
        var adm = asObservableObject(target, options)[$mobx];
        if (!target[keysSymbol]) {
          var proto = Object.getPrototypeOf(target);
          var keys = new Set([].concat(ownKeys(target), ownKeys(proto)));
          keys["delete"]("constructor");
          keys["delete"]($mobx);
          addHiddenProp(proto, keysSymbol, keys);
        }
        startBatch();
        try {
          target[keysSymbol].forEach(function(key) {
            return adm.make_(key, !overrides || (!(key in overrides) || overrides[key]));
          });
        } finally {
          endBatch();
        }
        return target;
      }
      var SPLICE = "splice";
      var UPDATE = "update";
      var MAX_SPLICE_SIZE = 1e4;
      var arrayTraps = {
        get: function get(target, name) {
          var adm = target[$mobx];
          if (name === $mobx) return adm;
          if ("length" === name) return adm.getArrayLength_();
          if ("string" === typeof name && !isNaN(name)) return adm.get_(parseInt(name));
          if (hasProp(arrayExtensions, name)) return arrayExtensions[name];
          return target[name];
        },
        set: function set(target, name, value) {
          var adm = target[$mobx];
          "length" === name && adm.setArrayLength_(value);
          "symbol" === typeof name || isNaN(name) ? target[name] = value : adm.set_(parseInt(name), value);
          return true;
        },
        preventExtensions: function preventExtensions() {
          die(15);
        }
      };
      var ObservableArrayAdministration = function() {
        function ObservableArrayAdministration(name, enhancer, owned_, legacyMode_) {
          void 0 === name && (name = "production" !== NODE_ENV ? "ObservableArray@" + getNextId() : "ObservableArray");
          this.owned_ = void 0;
          this.legacyMode_ = void 0;
          this.atom_ = void 0;
          this.values_ = [];
          this.interceptors_ = void 0;
          this.changeListeners_ = void 0;
          this.enhancer_ = void 0;
          this.dehancer = void 0;
          this.proxy_ = void 0;
          this.lastKnownLength_ = 0;
          this.owned_ = owned_;
          this.legacyMode_ = legacyMode_;
          this.atom_ = new Atom(name);
          this.enhancer_ = function(newV, oldV) {
            return enhancer(newV, oldV, "production" !== NODE_ENV ? name + "[..]" : "ObservableArray[..]");
          };
        }
        var _proto = ObservableArrayAdministration.prototype;
        _proto.dehanceValue_ = function dehanceValue_(value) {
          if (void 0 !== this.dehancer) return this.dehancer(value);
          return value;
        };
        _proto.dehanceValues_ = function dehanceValues_(values) {
          if (void 0 !== this.dehancer && values.length > 0) return values.map(this.dehancer);
          return values;
        };
        _proto.intercept_ = function intercept_(handler) {
          return registerInterceptor(this, handler);
        };
        _proto.observe_ = function observe_(listener, fireImmediately) {
          void 0 === fireImmediately && (fireImmediately = false);
          fireImmediately && listener({
            observableKind: "array",
            object: this.proxy_,
            debugObjectName: this.atom_.name_,
            type: "splice",
            index: 0,
            added: this.values_.slice(),
            addedCount: this.values_.length,
            removed: [],
            removedCount: 0
          });
          return registerListener(this, listener);
        };
        _proto.getArrayLength_ = function getArrayLength_() {
          this.atom_.reportObserved();
          return this.values_.length;
        };
        _proto.setArrayLength_ = function setArrayLength_(newLength) {
          ("number" !== typeof newLength || newLength < 0) && die("Out of range: " + newLength);
          var currentLength = this.values_.length;
          if (newLength === currentLength) return;
          if (newLength > currentLength) {
            var newItems = new Array(newLength - currentLength);
            for (var i = 0; i < newLength - currentLength; i++) newItems[i] = void 0;
            this.spliceWithArray_(currentLength, 0, newItems);
          } else this.spliceWithArray_(newLength, currentLength - newLength);
        };
        _proto.updateArrayLength_ = function updateArrayLength_(oldLength, delta) {
          oldLength !== this.lastKnownLength_ && die(16);
          this.lastKnownLength_ += delta;
          this.legacyMode_ && delta > 0 && reserveArrayBuffer(oldLength + delta + 1);
        };
        _proto.spliceWithArray_ = function spliceWithArray_(index, deleteCount, newItems) {
          var _this = this;
          checkIfStateModificationsAreAllowed(this.atom_);
          var length = this.values_.length;
          void 0 === index ? index = 0 : index > length ? index = length : index < 0 && (index = Math.max(0, length + index));
          deleteCount = 1 === arguments.length ? length - index : void 0 === deleteCount || null === deleteCount ? 0 : Math.max(0, Math.min(deleteCount, length - index));
          void 0 === newItems && (newItems = EMPTY_ARRAY);
          if (hasInterceptors(this)) {
            var change = interceptChange(this, {
              object: this.proxy_,
              type: SPLICE,
              index: index,
              removedCount: deleteCount,
              added: newItems
            });
            if (!change) return EMPTY_ARRAY;
            deleteCount = change.removedCount;
            newItems = change.added;
          }
          newItems = 0 === newItems.length ? newItems : newItems.map(function(v) {
            return _this.enhancer_(v, void 0);
          });
          if (this.legacyMode_ || "production" !== NODE_ENV) {
            var lengthDelta = newItems.length - deleteCount;
            this.updateArrayLength_(length, lengthDelta);
          }
          var res = this.spliceItemsIntoValues_(index, deleteCount, newItems);
          0 === deleteCount && 0 === newItems.length || this.notifyArraySplice_(index, newItems, res);
          return this.dehanceValues_(res);
        };
        _proto.spliceItemsIntoValues_ = function spliceItemsIntoValues_(index, deleteCount, newItems) {
          if (newItems.length < MAX_SPLICE_SIZE) {
            var _this$values_;
            return (_this$values_ = this.values_).splice.apply(_this$values_, [ index, deleteCount ].concat(newItems));
          }
          var res = this.values_.slice(index, index + deleteCount);
          var oldItems = this.values_.slice(index + deleteCount);
          this.values_.length = index + newItems.length - deleteCount;
          for (var i = 0; i < newItems.length; i++) this.values_[index + i] = newItems[i];
          for (var _i = 0; _i < oldItems.length; _i++) this.values_[index + newItems.length + _i] = oldItems[_i];
          return res;
        };
        _proto.notifyArrayChildUpdate_ = function notifyArrayChildUpdate_(index, newValue, oldValue) {
          var notifySpy = !this.owned_ && isSpyEnabled();
          var notify = hasListeners(this);
          var change = notify || notifySpy ? {
            observableKind: "array",
            object: this.proxy_,
            type: UPDATE,
            debugObjectName: this.atom_.name_,
            index: index,
            newValue: newValue,
            oldValue: oldValue
          } : null;
          "production" !== NODE_ENV && notifySpy && spyReportStart(change);
          this.atom_.reportChanged();
          notify && notifyListeners(this, change);
          "production" !== NODE_ENV && notifySpy && spyReportEnd();
        };
        _proto.notifyArraySplice_ = function notifyArraySplice_(index, added, removed) {
          var notifySpy = !this.owned_ && isSpyEnabled();
          var notify = hasListeners(this);
          var change = notify || notifySpy ? {
            observableKind: "array",
            object: this.proxy_,
            debugObjectName: this.atom_.name_,
            type: SPLICE,
            index: index,
            removed: removed,
            added: added,
            removedCount: removed.length,
            addedCount: added.length
          } : null;
          "production" !== NODE_ENV && notifySpy && spyReportStart(change);
          this.atom_.reportChanged();
          notify && notifyListeners(this, change);
          "production" !== NODE_ENV && notifySpy && spyReportEnd();
        };
        _proto.get_ = function get_(index) {
          if (index < this.values_.length) {
            this.atom_.reportObserved();
            return this.dehanceValue_(this.values_[index]);
          }
          console.warn("production" !== NODE_ENV ? "[mobx] Out of bounds read: " + index : "[mobx.array] Attempt to read an array index (" + index + ") that is out of bounds (" + this.values_.length + "). Please check length first. Out of bound indices will not be tracked by MobX");
        };
        _proto.set_ = function set_(index, newValue) {
          var values = this.values_;
          if (index < values.length) {
            checkIfStateModificationsAreAllowed(this.atom_);
            var oldValue = values[index];
            if (hasInterceptors(this)) {
              var change = interceptChange(this, {
                type: UPDATE,
                object: this.proxy_,
                index: index,
                newValue: newValue
              });
              if (!change) return;
              newValue = change.newValue;
            }
            newValue = this.enhancer_(newValue, oldValue);
            var changed = newValue !== oldValue;
            if (changed) {
              values[index] = newValue;
              this.notifyArrayChildUpdate_(index, newValue, oldValue);
            }
          } else index === values.length ? this.spliceWithArray_(index, 0, [ newValue ]) : die(17, index, values.length);
        };
        return ObservableArrayAdministration;
      }();
      function createObservableArray(initialValues, enhancer, name, owned) {
        void 0 === name && (name = "production" !== NODE_ENV ? "ObservableArray@" + getNextId() : "ObservableArray");
        void 0 === owned && (owned = false);
        assertProxies();
        var adm = new ObservableArrayAdministration(name, enhancer, owned, false);
        addHiddenFinalProp(adm.values_, $mobx, adm);
        var proxy = new Proxy(adm.values_, arrayTraps);
        adm.proxy_ = proxy;
        if (initialValues && initialValues.length) {
          var prev = allowStateChangesStart(true);
          adm.spliceWithArray_(0, 0, initialValues);
          allowStateChangesEnd(prev);
        }
        return proxy;
      }
      var arrayExtensions = {
        clear: function clear() {
          return this.splice(0);
        },
        replace: function replace(newItems) {
          var adm = this[$mobx];
          return adm.spliceWithArray_(0, adm.values_.length, newItems);
        },
        toJSON: function toJSON() {
          return this.slice();
        },
        splice: function splice(index, deleteCount) {
          for (var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) newItems[_key - 2] = arguments[_key];
          var adm = this[$mobx];
          switch (arguments.length) {
           case 0:
            return [];

           case 1:
            return adm.spliceWithArray_(index);

           case 2:
            return adm.spliceWithArray_(index, deleteCount);
          }
          return adm.spliceWithArray_(index, deleteCount, newItems);
        },
        spliceWithArray: function spliceWithArray(index, deleteCount, newItems) {
          return this[$mobx].spliceWithArray_(index, deleteCount, newItems);
        },
        push: function push() {
          var adm = this[$mobx];
          for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) items[_key2] = arguments[_key2];
          adm.spliceWithArray_(adm.values_.length, 0, items);
          return adm.values_.length;
        },
        pop: function pop() {
          return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];
        },
        shift: function shift() {
          return this.splice(0, 1)[0];
        },
        unshift: function unshift() {
          var adm = this[$mobx];
          for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) items[_key3] = arguments[_key3];
          adm.spliceWithArray_(0, 0, items);
          return adm.values_.length;
        },
        reverse: function reverse() {
          globalState.trackingDerivation && die(37, "reverse");
          this.replace(this.slice().reverse());
          return this;
        },
        sort: function sort() {
          globalState.trackingDerivation && die(37, "sort");
          var copy = this.slice();
          copy.sort.apply(copy, arguments);
          this.replace(copy);
          return this;
        },
        remove: function remove(value) {
          var adm = this[$mobx];
          var idx = adm.dehanceValues_(adm.values_).indexOf(value);
          if (idx > -1) {
            this.splice(idx, 1);
            return true;
          }
          return false;
        }
      };
      addArrayExtension("concat", simpleFunc);
      addArrayExtension("flat", simpleFunc);
      addArrayExtension("includes", simpleFunc);
      addArrayExtension("indexOf", simpleFunc);
      addArrayExtension("join", simpleFunc);
      addArrayExtension("lastIndexOf", simpleFunc);
      addArrayExtension("slice", simpleFunc);
      addArrayExtension("toString", simpleFunc);
      addArrayExtension("toLocaleString", simpleFunc);
      addArrayExtension("every", mapLikeFunc);
      addArrayExtension("filter", mapLikeFunc);
      addArrayExtension("find", mapLikeFunc);
      addArrayExtension("findIndex", mapLikeFunc);
      addArrayExtension("flatMap", mapLikeFunc);
      addArrayExtension("forEach", mapLikeFunc);
      addArrayExtension("map", mapLikeFunc);
      addArrayExtension("some", mapLikeFunc);
      addArrayExtension("reduce", reduceLikeFunc);
      addArrayExtension("reduceRight", reduceLikeFunc);
      function addArrayExtension(funcName, funcFactory) {
        "function" === typeof Array.prototype[funcName] && (arrayExtensions[funcName] = funcFactory(funcName));
      }
      function simpleFunc(funcName) {
        return function() {
          var adm = this[$mobx];
          adm.atom_.reportObserved();
          var dehancedValues = adm.dehanceValues_(adm.values_);
          return dehancedValues[funcName].apply(dehancedValues, arguments);
        };
      }
      function mapLikeFunc(funcName) {
        return function(callback, thisArg) {
          var _this2 = this;
          var adm = this[$mobx];
          adm.atom_.reportObserved();
          var dehancedValues = adm.dehanceValues_(adm.values_);
          return dehancedValues[funcName](function(element, index) {
            return callback.call(thisArg, element, index, _this2);
          });
        };
      }
      function reduceLikeFunc(funcName) {
        return function() {
          var _this3 = this;
          var adm = this[$mobx];
          adm.atom_.reportObserved();
          var dehancedValues = adm.dehanceValues_(adm.values_);
          var callback = arguments[0];
          arguments[0] = function(accumulator, currentValue, index) {
            return callback(accumulator, currentValue, index, _this3);
          };
          return dehancedValues[funcName].apply(dehancedValues, arguments);
        };
      }
      var isObservableArrayAdministration = createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
      function isObservableArray(thing) {
        return isObject(thing) && isObservableArrayAdministration(thing[$mobx]);
      }
      var _Symbol$iterator, _Symbol$toStringTag;
      var ObservableMapMarker = {};
      var ADD = "add";
      var DELETE = "delete";
      _Symbol$iterator = Symbol.iterator;
      _Symbol$toStringTag = Symbol.toStringTag;
      var ObservableMap = function() {
        function ObservableMap(initialData, enhancer_, name_) {
          void 0 === enhancer_ && (enhancer_ = deepEnhancer);
          void 0 === name_ && (name_ = "production" !== NODE_ENV ? "ObservableMap@" + getNextId() : "ObservableMap");
          this.enhancer_ = void 0;
          this.name_ = void 0;
          this[$mobx] = ObservableMapMarker;
          this.data_ = void 0;
          this.hasMap_ = void 0;
          this.keysAtom_ = void 0;
          this.interceptors_ = void 0;
          this.changeListeners_ = void 0;
          this.dehancer = void 0;
          this.enhancer_ = enhancer_;
          this.name_ = name_;
          isFunction(Map) || die(18);
          this.keysAtom_ = createAtom("production" !== NODE_ENV ? this.name_ + ".keys()" : "ObservableMap.keys()");
          this.data_ = new Map();
          this.hasMap_ = new Map();
          this.merge(initialData);
        }
        var _proto = ObservableMap.prototype;
        _proto.has_ = function has_(key) {
          return this.data_.has(key);
        };
        _proto.has = function has(key) {
          var _this = this;
          if (!globalState.trackingDerivation) return this.has_(key);
          var entry = this.hasMap_.get(key);
          if (!entry) {
            var newEntry = entry = new ObservableValue(this.has_(key), referenceEnhancer, "production" !== NODE_ENV ? this.name_ + "." + stringifyKey(key) + "?" : "ObservableMap.key?", false);
            this.hasMap_.set(key, newEntry);
            onBecomeUnobserved(newEntry, function() {
              return _this.hasMap_["delete"](key);
            });
          }
          return entry.get();
        };
        _proto.set = function set(key, value) {
          var hasKey = this.has_(key);
          if (hasInterceptors(this)) {
            var change = interceptChange(this, {
              type: hasKey ? UPDATE : ADD,
              object: this,
              newValue: value,
              name: key
            });
            if (!change) return this;
            value = change.newValue;
          }
          hasKey ? this.updateValue_(key, value) : this.addValue_(key, value);
          return this;
        };
        _proto["delete"] = function _delete(key) {
          var _this2 = this;
          checkIfStateModificationsAreAllowed(this.keysAtom_);
          if (hasInterceptors(this)) {
            var change = interceptChange(this, {
              type: DELETE,
              object: this,
              name: key
            });
            if (!change) return false;
          }
          if (this.has_(key)) {
            var notifySpy = isSpyEnabled();
            var notify = hasListeners(this);
            var _change = notify || notifySpy ? {
              observableKind: "map",
              debugObjectName: this.name_,
              type: DELETE,
              object: this,
              oldValue: this.data_.get(key).value_,
              name: key
            } : null;
            "production" !== NODE_ENV && notifySpy && spyReportStart(_change);
            transaction(function() {
              _this2.keysAtom_.reportChanged();
              _this2.updateHasMapEntry_(key, false);
              var observable = _this2.data_.get(key);
              observable.setNewValue_(void 0);
              _this2.data_["delete"](key);
            });
            notify && notifyListeners(this, _change);
            "production" !== NODE_ENV && notifySpy && spyReportEnd();
            return true;
          }
          return false;
        };
        _proto.updateHasMapEntry_ = function updateHasMapEntry_(key, value) {
          var entry = this.hasMap_.get(key);
          entry && entry.setNewValue_(value);
        };
        _proto.updateValue_ = function updateValue_(key, newValue) {
          var observable = this.data_.get(key);
          newValue = observable.prepareNewValue_(newValue);
          if (newValue !== globalState.UNCHANGED) {
            var notifySpy = isSpyEnabled();
            var notify = hasListeners(this);
            var change = notify || notifySpy ? {
              observableKind: "map",
              debugObjectName: this.name_,
              type: UPDATE,
              object: this,
              oldValue: observable.value_,
              name: key,
              newValue: newValue
            } : null;
            "production" !== NODE_ENV && notifySpy && spyReportStart(change);
            observable.setNewValue_(newValue);
            notify && notifyListeners(this, change);
            "production" !== NODE_ENV && notifySpy && spyReportEnd();
          }
        };
        _proto.addValue_ = function addValue_(key, newValue) {
          var _this3 = this;
          checkIfStateModificationsAreAllowed(this.keysAtom_);
          transaction(function() {
            var observable = new ObservableValue(newValue, _this3.enhancer_, "production" !== NODE_ENV ? _this3.name_ + "." + stringifyKey(key) : "ObservableMap.key", false);
            _this3.data_.set(key, observable);
            newValue = observable.value_;
            _this3.updateHasMapEntry_(key, true);
            _this3.keysAtom_.reportChanged();
          });
          var notifySpy = isSpyEnabled();
          var notify = hasListeners(this);
          var change = notify || notifySpy ? {
            observableKind: "map",
            debugObjectName: this.name_,
            type: ADD,
            object: this,
            name: key,
            newValue: newValue
          } : null;
          "production" !== NODE_ENV && notifySpy && spyReportStart(change);
          notify && notifyListeners(this, change);
          "production" !== NODE_ENV && notifySpy && spyReportEnd();
        };
        _proto.get = function get(key) {
          if (this.has(key)) return this.dehanceValue_(this.data_.get(key).get());
          return this.dehanceValue_(void 0);
        };
        _proto.dehanceValue_ = function dehanceValue_(value) {
          if (void 0 !== this.dehancer) return this.dehancer(value);
          return value;
        };
        _proto.keys = function keys() {
          this.keysAtom_.reportObserved();
          return this.data_.keys();
        };
        _proto.values = function values() {
          var self = this;
          var keys = this.keys();
          return makeIterable({
            next: function next() {
              var _keys$next = keys.next(), done = _keys$next.done, value = _keys$next.value;
              return {
                done: done,
                value: done ? void 0 : self.get(value)
              };
            }
          });
        };
        _proto.entries = function entries() {
          var self = this;
          var keys = this.keys();
          return makeIterable({
            next: function next() {
              var _keys$next2 = keys.next(), done = _keys$next2.done, value = _keys$next2.value;
              return {
                done: done,
                value: done ? void 0 : [ value, self.get(value) ]
              };
            }
          });
        };
        _proto[_Symbol$iterator] = function() {
          return this.entries();
        };
        _proto.forEach = function forEach(callback, thisArg) {
          for (var _iterator = _createForOfIteratorHelperLoose(this), _step; !(_step = _iterator()).done; ) {
            var _step$value = _step.value, key = _step$value[0], value = _step$value[1];
            callback.call(thisArg, value, key, this);
          }
        };
        _proto.merge = function merge(other) {
          var _this4 = this;
          isObservableMap(other) && (other = new Map(other));
          transaction(function() {
            if (isPlainObject(other)) getPlainObjectKeys(other).forEach(function(key) {
              return _this4.set(key, other[key]);
            }); else if (Array.isArray(other)) other.forEach(function(_ref) {
              var key = _ref[0], value = _ref[1];
              return _this4.set(key, value);
            }); else if (isES6Map(other)) {
              other.constructor !== Map && die(19, other);
              other.forEach(function(value, key) {
                return _this4.set(key, value);
              });
            } else null !== other && void 0 !== other && die(20, other);
          });
          return this;
        };
        _proto.clear = function clear() {
          var _this5 = this;
          transaction(function() {
            untracked(function() {
              for (var _iterator2 = _createForOfIteratorHelperLoose(_this5.keys()), _step2; !(_step2 = _iterator2()).done; ) {
                var key = _step2.value;
                _this5["delete"](key);
              }
            });
          });
        };
        _proto.replace = function replace(values) {
          var _this6 = this;
          transaction(function() {
            var replacementMap = convertToMap(values);
            var orderedData = new Map();
            var keysReportChangedCalled = false;
            for (var _iterator3 = _createForOfIteratorHelperLoose(_this6.data_.keys()), _step3; !(_step3 = _iterator3()).done; ) {
              var key = _step3.value;
              if (!replacementMap.has(key)) {
                var deleted = _this6["delete"](key);
                if (deleted) keysReportChangedCalled = true; else {
                  var value = _this6.data_.get(key);
                  orderedData.set(key, value);
                }
              }
            }
            for (var _iterator4 = _createForOfIteratorHelperLoose(replacementMap.entries()), _step4; !(_step4 = _iterator4()).done; ) {
              var _step4$value = _step4.value, _key = _step4$value[0], _value = _step4$value[1];
              var keyExisted = _this6.data_.has(_key);
              _this6.set(_key, _value);
              if (_this6.data_.has(_key)) {
                var _value2 = _this6.data_.get(_key);
                orderedData.set(_key, _value2);
                keyExisted || (keysReportChangedCalled = true);
              }
            }
            if (!keysReportChangedCalled) if (_this6.data_.size !== orderedData.size) _this6.keysAtom_.reportChanged(); else {
              var iter1 = _this6.data_.keys();
              var iter2 = orderedData.keys();
              var next1 = iter1.next();
              var next2 = iter2.next();
              while (!next1.done) {
                if (next1.value !== next2.value) {
                  _this6.keysAtom_.reportChanged();
                  break;
                }
                next1 = iter1.next();
                next2 = iter2.next();
              }
            }
            _this6.data_ = orderedData;
          });
          return this;
        };
        _proto.toString = function toString() {
          return "[object ObservableMap]";
        };
        _proto.toJSON = function toJSON() {
          return Array.from(this);
        };
        _proto.observe_ = function observe_(listener, fireImmediately) {
          "production" !== NODE_ENV && true === fireImmediately && die("`observe` doesn't support fireImmediately=true in combination with maps.");
          return registerListener(this, listener);
        };
        _proto.intercept_ = function intercept_(handler) {
          return registerInterceptor(this, handler);
        };
        _createClass(ObservableMap, [ {
          key: "size",
          get: function get() {
            this.keysAtom_.reportObserved();
            return this.data_.size;
          }
        }, {
          key: _Symbol$toStringTag,
          get: function get() {
            return "Map";
          }
        } ]);
        return ObservableMap;
      }();
      exports.ObservableMap = ObservableMap;
      var isObservableMap = createInstanceofPredicate("ObservableMap", ObservableMap);
      exports.isObservableMap = isObservableMap;
      function convertToMap(dataStructure) {
        if (isES6Map(dataStructure) || isObservableMap(dataStructure)) return dataStructure;
        if (Array.isArray(dataStructure)) return new Map(dataStructure);
        if (isPlainObject(dataStructure)) {
          var map = new Map();
          for (var key in dataStructure) map.set(key, dataStructure[key]);
          return map;
        }
        return die(21, dataStructure);
      }
      var _Symbol$iterator$1, _Symbol$toStringTag$1;
      var ObservableSetMarker = {};
      _Symbol$iterator$1 = Symbol.iterator;
      _Symbol$toStringTag$1 = Symbol.toStringTag;
      var ObservableSet = function() {
        function ObservableSet(initialData, enhancer, name_) {
          void 0 === enhancer && (enhancer = deepEnhancer);
          void 0 === name_ && (name_ = "production" !== NODE_ENV ? "ObservableSet@" + getNextId() : "ObservableSet");
          this.name_ = void 0;
          this[$mobx] = ObservableSetMarker;
          this.data_ = new Set();
          this.atom_ = void 0;
          this.changeListeners_ = void 0;
          this.interceptors_ = void 0;
          this.dehancer = void 0;
          this.enhancer_ = void 0;
          this.name_ = name_;
          isFunction(Set) || die(22);
          this.atom_ = createAtom(this.name_);
          this.enhancer_ = function(newV, oldV) {
            return enhancer(newV, oldV, name_);
          };
          initialData && this.replace(initialData);
        }
        var _proto = ObservableSet.prototype;
        _proto.dehanceValue_ = function dehanceValue_(value) {
          if (void 0 !== this.dehancer) return this.dehancer(value);
          return value;
        };
        _proto.clear = function clear() {
          var _this = this;
          transaction(function() {
            untracked(function() {
              for (var _iterator = _createForOfIteratorHelperLoose(_this.data_.values()), _step; !(_step = _iterator()).done; ) {
                var value = _step.value;
                _this["delete"](value);
              }
            });
          });
        };
        _proto.forEach = function forEach(callbackFn, thisArg) {
          for (var _iterator2 = _createForOfIteratorHelperLoose(this), _step2; !(_step2 = _iterator2()).done; ) {
            var value = _step2.value;
            callbackFn.call(thisArg, value, value, this);
          }
        };
        _proto.add = function add(value) {
          var _this2 = this;
          checkIfStateModificationsAreAllowed(this.atom_);
          if (hasInterceptors(this)) {
            var change = interceptChange(this, {
              type: ADD,
              object: this,
              newValue: value
            });
            if (!change) return this;
          }
          if (!this.has(value)) {
            transaction(function() {
              _this2.data_.add(_this2.enhancer_(value, void 0));
              _this2.atom_.reportChanged();
            });
            var notifySpy = "production" !== NODE_ENV && isSpyEnabled();
            var notify = hasListeners(this);
            var _change = notify || notifySpy ? {
              observableKind: "set",
              debugObjectName: this.name_,
              type: ADD,
              object: this,
              newValue: value
            } : null;
            notifySpy && "production" !== NODE_ENV && spyReportStart(_change);
            notify && notifyListeners(this, _change);
            notifySpy && "production" !== NODE_ENV && spyReportEnd();
          }
          return this;
        };
        _proto["delete"] = function _delete(value) {
          var _this3 = this;
          if (hasInterceptors(this)) {
            var change = interceptChange(this, {
              type: DELETE,
              object: this,
              oldValue: value
            });
            if (!change) return false;
          }
          if (this.has(value)) {
            var notifySpy = "production" !== NODE_ENV && isSpyEnabled();
            var notify = hasListeners(this);
            var _change2 = notify || notifySpy ? {
              observableKind: "set",
              debugObjectName: this.name_,
              type: DELETE,
              object: this,
              oldValue: value
            } : null;
            notifySpy && "production" !== NODE_ENV && spyReportStart(_change2);
            transaction(function() {
              _this3.atom_.reportChanged();
              _this3.data_["delete"](value);
            });
            notify && notifyListeners(this, _change2);
            notifySpy && "production" !== NODE_ENV && spyReportEnd();
            return true;
          }
          return false;
        };
        _proto.has = function has(value) {
          this.atom_.reportObserved();
          return this.data_.has(this.dehanceValue_(value));
        };
        _proto.entries = function entries() {
          var nextIndex = 0;
          var keys = Array.from(this.keys());
          var values = Array.from(this.values());
          return makeIterable({
            next: function next() {
              var index = nextIndex;
              nextIndex += 1;
              return index < values.length ? {
                value: [ keys[index], values[index] ],
                done: false
              } : {
                done: true
              };
            }
          });
        };
        _proto.keys = function keys() {
          return this.values();
        };
        _proto.values = function values() {
          this.atom_.reportObserved();
          var self = this;
          var nextIndex = 0;
          var observableValues = Array.from(this.data_.values());
          return makeIterable({
            next: function next() {
              return nextIndex < observableValues.length ? {
                value: self.dehanceValue_(observableValues[nextIndex++]),
                done: false
              } : {
                done: true
              };
            }
          });
        };
        _proto.replace = function replace(other) {
          var _this4 = this;
          isObservableSet(other) && (other = new Set(other));
          transaction(function() {
            if (Array.isArray(other)) {
              _this4.clear();
              other.forEach(function(value) {
                return _this4.add(value);
              });
            } else if (isES6Set(other)) {
              _this4.clear();
              other.forEach(function(value) {
                return _this4.add(value);
              });
            } else null !== other && void 0 !== other && die("Cannot initialize set from " + other);
          });
          return this;
        };
        _proto.observe_ = function observe_(listener, fireImmediately) {
          "production" !== NODE_ENV && true === fireImmediately && die("`observe` doesn't support fireImmediately=true in combination with sets.");
          return registerListener(this, listener);
        };
        _proto.intercept_ = function intercept_(handler) {
          return registerInterceptor(this, handler);
        };
        _proto.toJSON = function toJSON() {
          return Array.from(this);
        };
        _proto.toString = function toString() {
          return "[object ObservableSet]";
        };
        _proto[_Symbol$iterator$1] = function() {
          return this.values();
        };
        _createClass(ObservableSet, [ {
          key: "size",
          get: function get() {
            this.atom_.reportObserved();
            return this.data_.size;
          }
        }, {
          key: _Symbol$toStringTag$1,
          get: function get() {
            return "Set";
          }
        } ]);
        return ObservableSet;
      }();
      exports.ObservableSet = ObservableSet;
      var isObservableSet = createInstanceofPredicate("ObservableSet", ObservableSet);
      exports.isObservableSet = isObservableSet;
      var descriptorCache = Object.create(null);
      var REMOVE = "remove";
      var ObservableObjectAdministration = function() {
        function ObservableObjectAdministration(target_, values_, name_, defaultAnnotation_) {
          void 0 === values_ && (values_ = new Map());
          void 0 === defaultAnnotation_ && (defaultAnnotation_ = autoAnnotation);
          this.target_ = void 0;
          this.values_ = void 0;
          this.name_ = void 0;
          this.defaultAnnotation_ = void 0;
          this.keysAtom_ = void 0;
          this.changeListeners_ = void 0;
          this.interceptors_ = void 0;
          this.proxy_ = void 0;
          this.isPlainObject_ = void 0;
          this.appliedAnnotations_ = void 0;
          this.pendingKeys_ = void 0;
          this.target_ = target_;
          this.values_ = values_;
          this.name_ = name_;
          this.defaultAnnotation_ = defaultAnnotation_;
          this.keysAtom_ = new Atom("production" !== NODE_ENV ? this.name_ + ".keys" : "ObservableObject.keys");
          this.isPlainObject_ = isPlainObject(this.target_);
          "production" === NODE_ENV || isAnnotation(this.defaultAnnotation_) || die("defaultAnnotation must be valid annotation");
          "production" !== NODE_ENV && (this.appliedAnnotations_ = {});
        }
        var _proto = ObservableObjectAdministration.prototype;
        _proto.getObservablePropValue_ = function getObservablePropValue_(key) {
          return this.values_.get(key).get();
        };
        _proto.setObservablePropValue_ = function setObservablePropValue_(key, newValue) {
          var observable = this.values_.get(key);
          if (observable instanceof ComputedValue) {
            observable.set(newValue);
            return true;
          }
          if (hasInterceptors(this)) {
            var change = interceptChange(this, {
              type: UPDATE,
              object: this.proxy_ || this.target_,
              name: key,
              newValue: newValue
            });
            if (!change) return null;
            newValue = change.newValue;
          }
          newValue = observable.prepareNewValue_(newValue);
          if (newValue !== globalState.UNCHANGED) {
            var notify = hasListeners(this);
            var notifySpy = "production" !== NODE_ENV && isSpyEnabled();
            var _change = notify || notifySpy ? {
              type: UPDATE,
              observableKind: "object",
              debugObjectName: this.name_,
              object: this.proxy_ || this.target_,
              oldValue: observable.value_,
              name: key,
              newValue: newValue
            } : null;
            "production" !== NODE_ENV && notifySpy && spyReportStart(_change);
            observable.setNewValue_(newValue);
            notify && notifyListeners(this, _change);
            "production" !== NODE_ENV && notifySpy && spyReportEnd();
          }
          return true;
        };
        _proto.get_ = function get_(key) {
          globalState.trackingDerivation && !hasProp(this.target_, key) && this.has_(key);
          return this.target_[key];
        };
        _proto.set_ = function set_(key, value, proxyTrap) {
          void 0 === proxyTrap && (proxyTrap = false);
          if (hasProp(this.target_, key)) {
            if (this.values_.has(key)) return this.setObservablePropValue_(key, value);
            if (proxyTrap) return Reflect.set(this.target_, key, value);
            this.target_[key] = value;
            return true;
          }
          return this.extend_(key, {
            value: value,
            enumerable: true,
            writable: true,
            configurable: true
          }, this.defaultAnnotation_, proxyTrap);
        };
        _proto.has_ = function has_(key) {
          if (!globalState.trackingDerivation) return key in this.target_;
          this.pendingKeys_ || (this.pendingKeys_ = new Map());
          var entry = this.pendingKeys_.get(key);
          if (!entry) {
            entry = new ObservableValue(key in this.target_, referenceEnhancer, "production" !== NODE_ENV ? this.name_ + "." + stringifyKey(key) + "?" : "ObservableObject.key?", false);
            this.pendingKeys_.set(key, entry);
          }
          return entry.get();
        };
        _proto.make_ = function make_(key, annotation) {
          true === annotation && (annotation = this.defaultAnnotation_);
          if (false === annotation) return;
          assertAnnotable(this, annotation, key);
          if (!(key in this.target_)) {
            var _this$target_$storedA;
            if (null == (_this$target_$storedA = this.target_[storedAnnotationsSymbol]) ? void 0 : _this$target_$storedA[key]) return;
            die(1, annotation.annotationType_, this.name_ + "." + key.toString());
          }
          var source = this.target_;
          while (source && source !== objectPrototype) {
            var descriptor = getDescriptor(source, key);
            if (descriptor) {
              var outcome = annotation.make_(this, key, descriptor, source);
              if (0 === outcome) return;
              if (1 === outcome) break;
            }
            source = Object.getPrototypeOf(source);
          }
          recordAnnotationApplied(this, annotation, key);
        };
        _proto.extend_ = function extend_(key, descriptor, annotation, proxyTrap) {
          void 0 === proxyTrap && (proxyTrap = false);
          true === annotation && (annotation = this.defaultAnnotation_);
          if (false === annotation) return this.defineProperty_(key, descriptor, proxyTrap);
          assertAnnotable(this, annotation, key);
          var outcome = annotation.extend_(this, key, descriptor, proxyTrap);
          outcome && recordAnnotationApplied(this, annotation, key);
          return outcome;
        };
        _proto.defineProperty_ = function defineProperty_(key, descriptor, proxyTrap) {
          void 0 === proxyTrap && (proxyTrap = false);
          try {
            startBatch();
            var deleteOutcome = this.delete_(key);
            if (!deleteOutcome) return deleteOutcome;
            if (hasInterceptors(this)) {
              var change = interceptChange(this, {
                object: this.proxy_ || this.target_,
                name: key,
                type: ADD,
                newValue: descriptor.value
              });
              if (!change) return null;
              var newValue = change.newValue;
              descriptor.value !== newValue && (descriptor = _extends({}, descriptor, {
                value: newValue
              }));
            }
            if (proxyTrap) {
              if (!Reflect.defineProperty(this.target_, key, descriptor)) return false;
            } else defineProperty(this.target_, key, descriptor);
            this.notifyPropertyAddition_(key, descriptor.value);
          } finally {
            endBatch();
          }
          return true;
        };
        _proto.defineObservableProperty_ = function defineObservableProperty_(key, value, enhancer, proxyTrap) {
          void 0 === proxyTrap && (proxyTrap = false);
          try {
            startBatch();
            var deleteOutcome = this.delete_(key);
            if (!deleteOutcome) return deleteOutcome;
            if (hasInterceptors(this)) {
              var change = interceptChange(this, {
                object: this.proxy_ || this.target_,
                name: key,
                type: ADD,
                newValue: value
              });
              if (!change) return null;
              value = change.newValue;
            }
            var cachedDescriptor = getCachedObservablePropDescriptor(key);
            var descriptor = {
              configurable: !globalState.safeDescriptors || this.isPlainObject_,
              enumerable: true,
              get: cachedDescriptor.get,
              set: cachedDescriptor.set
            };
            if (proxyTrap) {
              if (!Reflect.defineProperty(this.target_, key, descriptor)) return false;
            } else defineProperty(this.target_, key, descriptor);
            var observable = new ObservableValue(value, enhancer, "production" !== NODE_ENV ? this.name_ + "." + key.toString() : "ObservableObject.key", false);
            this.values_.set(key, observable);
            this.notifyPropertyAddition_(key, observable.value_);
          } finally {
            endBatch();
          }
          return true;
        };
        _proto.defineComputedProperty_ = function defineComputedProperty_(key, options, proxyTrap) {
          void 0 === proxyTrap && (proxyTrap = false);
          try {
            startBatch();
            var deleteOutcome = this.delete_(key);
            if (!deleteOutcome) return deleteOutcome;
            if (hasInterceptors(this)) {
              var change = interceptChange(this, {
                object: this.proxy_ || this.target_,
                name: key,
                type: ADD,
                newValue: void 0
              });
              if (!change) return null;
            }
            options.name || (options.name = "production" !== NODE_ENV ? this.name_ + "." + key.toString() : "ObservableObject.key");
            options.context = this.proxy_ || this.target_;
            var cachedDescriptor = getCachedObservablePropDescriptor(key);
            var descriptor = {
              configurable: !globalState.safeDescriptors || this.isPlainObject_,
              enumerable: false,
              get: cachedDescriptor.get,
              set: cachedDescriptor.set
            };
            if (proxyTrap) {
              if (!Reflect.defineProperty(this.target_, key, descriptor)) return false;
            } else defineProperty(this.target_, key, descriptor);
            this.values_.set(key, new ComputedValue(options));
            this.notifyPropertyAddition_(key, void 0);
          } finally {
            endBatch();
          }
          return true;
        };
        _proto.delete_ = function delete_(key, proxyTrap) {
          void 0 === proxyTrap && (proxyTrap = false);
          if (!hasProp(this.target_, key)) return true;
          if (hasInterceptors(this)) {
            var change = interceptChange(this, {
              object: this.proxy_ || this.target_,
              name: key,
              type: REMOVE
            });
            if (!change) return null;
          }
          try {
            var _this$pendingKeys_, _this$pendingKeys_$ge;
            startBatch();
            var notify = hasListeners(this);
            var notifySpy = "production" !== NODE_ENV && isSpyEnabled();
            var observable = this.values_.get(key);
            var value = void 0;
            if (!observable && (notify || notifySpy)) {
              var _getDescriptor;
              value = null == (_getDescriptor = getDescriptor(this.target_, key)) ? void 0 : _getDescriptor.value;
            }
            if (proxyTrap) {
              if (!Reflect.deleteProperty(this.target_, key)) return false;
            } else delete this.target_[key];
            "production" !== NODE_ENV && delete this.appliedAnnotations_[key];
            if (observable) {
              this.values_["delete"](key);
              observable instanceof ObservableValue && (value = observable.value_);
              propagateChanged(observable);
            }
            this.keysAtom_.reportChanged();
            null == (_this$pendingKeys_ = this.pendingKeys_) ? void 0 : null == (_this$pendingKeys_$ge = _this$pendingKeys_.get(key)) ? void 0 : _this$pendingKeys_$ge.set(key in this.target_);
            if (notify || notifySpy) {
              var _change2 = {
                type: REMOVE,
                observableKind: "object",
                object: this.proxy_ || this.target_,
                debugObjectName: this.name_,
                oldValue: value,
                name: key
              };
              "production" !== NODE_ENV && notifySpy && spyReportStart(_change2);
              notify && notifyListeners(this, _change2);
              "production" !== NODE_ENV && notifySpy && spyReportEnd();
            }
          } finally {
            endBatch();
          }
          return true;
        };
        _proto.observe_ = function observe_(callback, fireImmediately) {
          "production" !== NODE_ENV && true === fireImmediately && die("`observe` doesn't support the fire immediately property for observable objects.");
          return registerListener(this, callback);
        };
        _proto.intercept_ = function intercept_(handler) {
          return registerInterceptor(this, handler);
        };
        _proto.notifyPropertyAddition_ = function notifyPropertyAddition_(key, value) {
          var _this$pendingKeys_2, _this$pendingKeys_2$g;
          var notify = hasListeners(this);
          var notifySpy = "production" !== NODE_ENV && isSpyEnabled();
          if (notify || notifySpy) {
            var change = notify || notifySpy ? {
              type: ADD,
              observableKind: "object",
              debugObjectName: this.name_,
              object: this.proxy_ || this.target_,
              name: key,
              newValue: value
            } : null;
            "production" !== NODE_ENV && notifySpy && spyReportStart(change);
            notify && notifyListeners(this, change);
            "production" !== NODE_ENV && notifySpy && spyReportEnd();
          }
          null == (_this$pendingKeys_2 = this.pendingKeys_) ? void 0 : null == (_this$pendingKeys_2$g = _this$pendingKeys_2.get(key)) ? void 0 : _this$pendingKeys_2$g.set(true);
          this.keysAtom_.reportChanged();
        };
        _proto.ownKeys_ = function ownKeys_() {
          this.keysAtom_.reportObserved();
          return ownKeys(this.target_);
        };
        _proto.keys_ = function keys_() {
          this.keysAtom_.reportObserved();
          return Object.keys(this.target_);
        };
        return ObservableObjectAdministration;
      }();
      function asObservableObject(target, options) {
        var _options$name;
        "production" !== NODE_ENV && options && isObservableObject(target) && die("Options can't be provided for already observable objects.");
        if (hasProp(target, $mobx)) {
          "production" === NODE_ENV || getAdministration(target) instanceof ObservableObjectAdministration || die("Cannot convert '" + getDebugName(target) + "' into observable object:\nThe target is already observable of different type.\nExtending builtins is not supported.");
          return target;
        }
        "production" === NODE_ENV || Object.isExtensible(target) || die("Cannot make the designated object observable; it is not extensible");
        var name = null != (_options$name = null == options ? void 0 : options.name) ? _options$name : "production" !== NODE_ENV ? (isPlainObject(target) ? "ObservableObject" : target.constructor.name) + "@" + getNextId() : "ObservableObject";
        var adm = new ObservableObjectAdministration(target, new Map(), String(name), getAnnotationFromOptions(options));
        addHiddenProp(target, $mobx, adm);
        return target;
      }
      var isObservableObjectAdministration = createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);
      function getCachedObservablePropDescriptor(key) {
        return descriptorCache[key] || (descriptorCache[key] = {
          get: function get() {
            return this[$mobx].getObservablePropValue_(key);
          },
          set: function set(value) {
            return this[$mobx].setObservablePropValue_(key, value);
          }
        });
      }
      function isObservableObject(thing) {
        if (isObject(thing)) return isObservableObjectAdministration(thing[$mobx]);
        return false;
      }
      function recordAnnotationApplied(adm, annotation, key) {
        var _adm$target_$storedAn;
        "production" !== NODE_ENV && (adm.appliedAnnotations_[key] = annotation);
        null == (_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) || delete _adm$target_$storedAn[key];
      }
      function assertAnnotable(adm, annotation, key) {
        "production" === NODE_ENV || isAnnotation(annotation) || die("Cannot annotate '" + adm.name_ + "." + key.toString() + "': Invalid annotation.");
        if ("production" !== NODE_ENV && !isOverride(annotation) && hasProp(adm.appliedAnnotations_, key)) {
          var fieldName = adm.name_ + "." + key.toString();
          var currentAnnotationType = adm.appliedAnnotations_[key].annotationType_;
          var requestedAnnotationType = annotation.annotationType_;
          die("Cannot apply '" + requestedAnnotationType + "' to '" + fieldName + "':\nThe field is already annotated with '" + currentAnnotationType + "'.\nRe-annotating fields is not allowed.\nUse 'override' annotation for methods overriden by subclass.");
        }
      }
      var OBSERVABLE_ARRAY_BUFFER_SIZE = 0;
      var StubArray = function StubArray() {};
      function inherit(ctor, proto) {
        Object.setPrototypeOf ? Object.setPrototypeOf(ctor.prototype, proto) : void 0 !== ctor.prototype.__proto__ ? ctor.prototype.__proto__ = proto : ctor.prototype = proto;
      }
      inherit(StubArray, Array.prototype);
      var LegacyObservableArray = function(_StubArray) {
        _inheritsLoose(LegacyObservableArray, _StubArray);
        function LegacyObservableArray(initialValues, enhancer, name, owned) {
          var _this;
          void 0 === name && (name = "production" !== NODE_ENV ? "ObservableArray@" + getNextId() : "ObservableArray");
          void 0 === owned && (owned = false);
          _this = _StubArray.call(this) || this;
          var adm = new ObservableArrayAdministration(name, enhancer, owned, true);
          adm.proxy_ = _assertThisInitialized(_this);
          addHiddenFinalProp(_assertThisInitialized(_this), $mobx, adm);
          if (initialValues && initialValues.length) {
            var prev = allowStateChangesStart(true);
            _this.spliceWithArray(0, 0, initialValues);
            allowStateChangesEnd(prev);
          }
          return _this;
        }
        var _proto = LegacyObservableArray.prototype;
        _proto.concat = function concat() {
          this[$mobx].atom_.reportObserved();
          for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) arrays[_key] = arguments[_key];
          return Array.prototype.concat.apply(this.slice(), arrays.map(function(a) {
            return isObservableArray(a) ? a.slice() : a;
          }));
        };
        _proto[Symbol.iterator] = function() {
          var self = this;
          var nextIndex = 0;
          return makeIterable({
            next: function next() {
              return nextIndex < self.length ? {
                value: self[nextIndex++],
                done: false
              } : {
                done: true,
                value: void 0
              };
            }
          });
        };
        _createClass(LegacyObservableArray, [ {
          key: "length",
          get: function get() {
            return this[$mobx].getArrayLength_();
          },
          set: function set(newLength) {
            this[$mobx].setArrayLength_(newLength);
          }
        }, {
          key: Symbol.toStringTag,
          get: function get() {
            return "Array";
          }
        } ]);
        return LegacyObservableArray;
      }(StubArray);
      Object.entries(arrayExtensions).forEach(function(_ref) {
        var prop = _ref[0], fn = _ref[1];
        "concat" !== prop && addHiddenProp(LegacyObservableArray.prototype, prop, fn);
      });
      function createArrayEntryDescriptor(index) {
        return {
          enumerable: false,
          configurable: true,
          get: function get() {
            return this[$mobx].get_(index);
          },
          set: function set(value) {
            this[$mobx].set_(index, value);
          }
        };
      }
      function createArrayBufferItem(index) {
        defineProperty(LegacyObservableArray.prototype, "" + index, createArrayEntryDescriptor(index));
      }
      function reserveArrayBuffer(max) {
        if (max > OBSERVABLE_ARRAY_BUFFER_SIZE) {
          for (var index = OBSERVABLE_ARRAY_BUFFER_SIZE; index < max + 100; index++) createArrayBufferItem(index);
          OBSERVABLE_ARRAY_BUFFER_SIZE = max;
        }
      }
      reserveArrayBuffer(1e3);
      function createLegacyArray(initialValues, enhancer, name) {
        return new LegacyObservableArray(initialValues, enhancer, name);
      }
      function getAtom(thing, property) {
        if ("object" === typeof thing && null !== thing) {
          if (isObservableArray(thing)) {
            void 0 !== property && die(23);
            return thing[$mobx].atom_;
          }
          if (isObservableSet(thing)) return thing[$mobx];
          if (isObservableMap(thing)) {
            if (void 0 === property) return thing.keysAtom_;
            var observable = thing.data_.get(property) || thing.hasMap_.get(property);
            observable || die(25, property, getDebugName(thing));
            return observable;
          }
          if (isObservableObject(thing)) {
            if (!property) return die(26);
            var _observable = thing[$mobx].values_.get(property);
            _observable || die(27, property, getDebugName(thing));
            return _observable;
          }
          if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) return thing;
        } else if (isFunction(thing) && isReaction(thing[$mobx])) return thing[$mobx];
        die(28);
      }
      function getAdministration(thing, property) {
        thing || die(29);
        if (void 0 !== property) return getAdministration(getAtom(thing, property));
        if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) return thing;
        if (isObservableMap(thing) || isObservableSet(thing)) return thing;
        if (thing[$mobx]) return thing[$mobx];
        die(24, thing);
      }
      function getDebugName(thing, property) {
        var named;
        if (void 0 !== property) named = getAtom(thing, property); else {
          if (isAction(thing)) return thing.name;
          named = isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing) ? getAdministration(thing) : getAtom(thing);
        }
        return named.name_;
      }
      var toString = objectPrototype.toString;
      function deepEqual(a, b, depth) {
        void 0 === depth && (depth = -1);
        return eq(a, b, depth);
      }
      function eq(a, b, depth, aStack, bStack) {
        if (a === b) return 0 !== a || 1 / a === 1 / b;
        if (null == a || null == b) return false;
        if (a !== a) return b !== b;
        var type = typeof a;
        if (!isFunction(type) && "object" !== type && "object" != typeof b) return false;
        var className = toString.call(a);
        if (className !== toString.call(b)) return false;
        switch (className) {
         case "[object RegExp]":
         case "[object String]":
          return "" + a === "" + b;

         case "[object Number]":
          if (+a !== +a) return +b !== +b;
          return 0 === +a ? 1 / +a === 1 / b : +a === +b;

         case "[object Date]":
         case "[object Boolean]":
          return +a === +b;

         case "[object Symbol]":
          return "undefined" !== typeof Symbol && Symbol.valueOf.call(a) === Symbol.valueOf.call(b);

         case "[object Map]":
         case "[object Set]":
          depth >= 0 && depth++;
        }
        a = unwrap(a);
        b = unwrap(b);
        var areArrays = "[object Array]" === className;
        if (!areArrays) {
          if ("object" != typeof a || "object" != typeof b) return false;
          var aCtor = a.constructor, bCtor = b.constructor;
          if (aCtor !== bCtor && !(isFunction(aCtor) && aCtor instanceof aCtor && isFunction(bCtor) && bCtor instanceof bCtor) && "constructor" in a && "constructor" in b) return false;
        }
        if (0 === depth) return false;
        depth < 0 && (depth = -1);
        aStack = aStack || [];
        bStack = bStack || [];
        var length = aStack.length;
        while (length--) if (aStack[length] === a) return bStack[length] === b;
        aStack.push(a);
        bStack.push(b);
        if (areArrays) {
          length = a.length;
          if (length !== b.length) return false;
          while (length--) if (!eq(a[length], b[length], depth - 1, aStack, bStack)) return false;
        } else {
          var keys = Object.keys(a);
          var key;
          length = keys.length;
          if (Object.keys(b).length !== length) return false;
          while (length--) {
            key = keys[length];
            if (!(hasProp(b, key) && eq(a[key], b[key], depth - 1, aStack, bStack))) return false;
          }
        }
        aStack.pop();
        bStack.pop();
        return true;
      }
      function unwrap(a) {
        if (isObservableArray(a)) return a.slice();
        if (isES6Map(a) || isObservableMap(a)) return Array.from(a.entries());
        if (isES6Set(a) || isObservableSet(a)) return Array.from(a.entries());
        return a;
      }
      function makeIterable(iterator) {
        iterator[Symbol.iterator] = getSelf;
        return iterator;
      }
      function getSelf() {
        return this;
      }
      function isAnnotation(thing) {
        return thing instanceof Object && "string" === typeof thing.annotationType_ && isFunction(thing.make_) && isFunction(thing.extend_);
      }
      [ "Symbol", "Map", "Set", "Symbol" ].forEach(function(m) {
        var g = getGlobal();
        "undefined" === typeof g[m] && die("MobX requires global '" + m + "' to be available or polyfilled");
      });
      "object" === typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ && __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
        spy: spy,
        extras: {
          getDebugName: getDebugName
        },
        $mobx: $mobx
      });
      cc._RF.pop();
    }).call(this, "undefined" !== typeof global ? global : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {});
  }, {} ],
  "mode-cfb": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "a4b34aqLWBK2b2lorfyua/Q", "mode-cfb");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./cipher-core")) : "function" === typeof define && define.amd ? define([ "./core", "./cipher-core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      CryptoJS.mode.CFB = function() {
        var CFB = CryptoJS.lib.BlockCipherMode.extend();
        CFB.Encryptor = CFB.extend({
          processBlock: function processBlock(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = words.slice(offset, offset + blockSize);
          }
        });
        CFB.Decryptor = CFB.extend({
          processBlock: function processBlock(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var thisBlock = words.slice(offset, offset + blockSize);
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = thisBlock;
          }
        });
        function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
          var iv = this._iv;
          if (iv) {
            var keystream = iv.slice(0);
            this._iv = void 0;
          } else var keystream = this._prevBlock;
          cipher.encryptBlock(keystream, 0);
          for (var i = 0; i < blockSize; i++) words[offset + i] ^= keystream[i];
        }
        return CFB;
      }();
      return CryptoJS.mode.CFB;
    });
    cc._RF.pop();
  }, {
    "./cipher-core": "cipher-core",
    "./core": "core"
  } ],
  "mode-ctr-gladman": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "6b39e1pUz1LX4ZYPqEDNtrt", "mode-ctr-gladman");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./cipher-core")) : "function" === typeof define && define.amd ? define([ "./core", "./cipher-core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      CryptoJS.mode.CTRGladman = function() {
        var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
        function incWord(word) {
          if (255 === (word >> 24 & 255)) {
            var b1 = word >> 16 & 255;
            var b2 = word >> 8 & 255;
            var b3 = 255 & word;
            if (255 === b1) {
              b1 = 0;
              if (255 === b2) {
                b2 = 0;
                255 === b3 ? b3 = 0 : ++b3;
              } else ++b2;
            } else ++b1;
            word = 0;
            word += b1 << 16;
            word += b2 << 8;
            word += b3;
          } else word += 1 << 24;
          return word;
        }
        function incCounter(counter) {
          0 === (counter[0] = incWord(counter[0])) && (counter[1] = incWord(counter[1]));
          return counter;
        }
        var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
          processBlock: function processBlock(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            incCounter(counter);
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            for (var i = 0; i < blockSize; i++) words[offset + i] ^= keystream[i];
          }
        });
        CTRGladman.Decryptor = Encryptor;
        return CTRGladman;
      }();
      return CryptoJS.mode.CTRGladman;
    });
    cc._RF.pop();
  }, {
    "./cipher-core": "cipher-core",
    "./core": "core"
  } ],
  "mode-ctr": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "9757f4ZVtxL741rKxFsf+8x", "mode-ctr");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./cipher-core")) : "function" === typeof define && define.amd ? define([ "./core", "./cipher-core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      CryptoJS.mode.CTR = function() {
        var CTR = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = CTR.Encryptor = CTR.extend({
          processBlock: function processBlock(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
            for (var i = 0; i < blockSize; i++) words[offset + i] ^= keystream[i];
          }
        });
        CTR.Decryptor = Encryptor;
        return CTR;
      }();
      return CryptoJS.mode.CTR;
    });
    cc._RF.pop();
  }, {
    "./cipher-core": "cipher-core",
    "./core": "core"
  } ],
  "mode-ecb": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "9faffiNUQdFkKYNHz4o/omh", "mode-ecb");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./cipher-core")) : "function" === typeof define && define.amd ? define([ "./core", "./cipher-core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      CryptoJS.mode.ECB = function() {
        var ECB = CryptoJS.lib.BlockCipherMode.extend();
        ECB.Encryptor = ECB.extend({
          processBlock: function processBlock(words, offset) {
            this._cipher.encryptBlock(words, offset);
          }
        });
        ECB.Decryptor = ECB.extend({
          processBlock: function processBlock(words, offset) {
            this._cipher.decryptBlock(words, offset);
          }
        });
        return ECB;
      }();
      return CryptoJS.mode.ECB;
    });
    cc._RF.pop();
  }, {
    "./cipher-core": "cipher-core",
    "./core": "core"
  } ],
  "mode-ofb": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "caf7eyDn49C44GUvrofOFdb", "mode-ofb");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./cipher-core")) : "function" === typeof define && define.amd ? define([ "./core", "./cipher-core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      CryptoJS.mode.OFB = function() {
        var OFB = CryptoJS.lib.BlockCipherMode.extend();
        var Encryptor = OFB.Encryptor = OFB.extend({
          processBlock: function processBlock(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var keystream = this._keystream;
            if (iv) {
              keystream = this._keystream = iv.slice(0);
              this._iv = void 0;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i = 0; i < blockSize; i++) words[offset + i] ^= keystream[i];
          }
        });
        OFB.Decryptor = Encryptor;
        return OFB;
      }();
      return CryptoJS.mode.OFB;
    });
    cc._RF.pop();
  }, {
    "./cipher-core": "cipher-core",
    "./core": "core"
  } ],
  "pad-ansix923": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "bc552a8YcpK8aBvKIYqts71", "pad-ansix923");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./cipher-core")) : "function" === typeof define && define.amd ? define([ "./core", "./cipher-core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      CryptoJS.pad.AnsiX923 = {
        pad: function pad(data, blockSize) {
          var dataSigBytes = data.sigBytes;
          var blockSizeBytes = 4 * blockSize;
          var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
          var lastBytePos = dataSigBytes + nPaddingBytes - 1;
          data.clamp();
          data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
          data.sigBytes += nPaddingBytes;
        },
        unpad: function unpad(data) {
          var nPaddingBytes = 255 & data.words[data.sigBytes - 1 >>> 2];
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Ansix923;
    });
    cc._RF.pop();
  }, {
    "./cipher-core": "cipher-core",
    "./core": "core"
  } ],
  "pad-iso10126": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "f8ead33oShJ/IyfYZEVJp3t", "pad-iso10126");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./cipher-core")) : "function" === typeof define && define.amd ? define([ "./core", "./cipher-core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      CryptoJS.pad.Iso10126 = {
        pad: function pad(data, blockSize) {
          var blockSizeBytes = 4 * blockSize;
          var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
          data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([ nPaddingBytes << 24 ], 1));
        },
        unpad: function unpad(data) {
          var nPaddingBytes = 255 & data.words[data.sigBytes - 1 >>> 2];
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS.pad.Iso10126;
    });
    cc._RF.pop();
  }, {
    "./cipher-core": "cipher-core",
    "./core": "core"
  } ],
  "pad-iso97971": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "212daZAEB5G14g0yi/p6c2D", "pad-iso97971");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./cipher-core")) : "function" === typeof define && define.amd ? define([ "./core", "./cipher-core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      CryptoJS.pad.Iso97971 = {
        pad: function pad(data, blockSize) {
          data.concat(CryptoJS.lib.WordArray.create([ 2147483648 ], 1));
          CryptoJS.pad.ZeroPadding.pad(data, blockSize);
        },
        unpad: function unpad(data) {
          CryptoJS.pad.ZeroPadding.unpad(data);
          data.sigBytes--;
        }
      };
      return CryptoJS.pad.Iso97971;
    });
    cc._RF.pop();
  }, {
    "./cipher-core": "cipher-core",
    "./core": "core"
  } ],
  "pad-nopadding": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "36d3bq/NdZK/KsZu3Sehk8x", "pad-nopadding");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./cipher-core")) : "function" === typeof define && define.amd ? define([ "./core", "./cipher-core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      CryptoJS.pad.NoPadding = {
        pad: function pad() {},
        unpad: function unpad() {}
      };
      return CryptoJS.pad.NoPadding;
    });
    cc._RF.pop();
  }, {
    "./cipher-core": "cipher-core",
    "./core": "core"
  } ],
  "pad-pkcs7": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "a0326ziym5Iqro1TtSHsy0s", "pad-pkcs7");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./cipher-core")) : "function" === typeof define && define.amd ? define([ "./core", "./cipher-core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      return CryptoJS.pad.Pkcs7;
    });
    cc._RF.pop();
  }, {
    "./cipher-core": "cipher-core",
    "./core": "core"
  } ],
  "pad-zeropadding": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "904a7Gp24xICr4AR7mmMtQF", "pad-zeropadding");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./cipher-core")) : "function" === typeof define && define.amd ? define([ "./core", "./cipher-core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      CryptoJS.pad.ZeroPadding = {
        pad: function pad(data, blockSize) {
          var blockSizeBytes = 4 * blockSize;
          data.clamp();
          data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
        },
        unpad: function unpad(data) {
          var dataWords = data.words;
          var i = data.sigBytes - 1;
          while (!(dataWords[i >>> 2] >>> 24 - i % 4 * 8 & 255)) i--;
          data.sigBytes = i + 1;
        }
      };
      return CryptoJS.pad.ZeroPadding;
    });
    cc._RF.pop();
  }, {
    "./cipher-core": "cipher-core",
    "./core": "core"
  } ],
  pbkdf2: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "d7d4d1W/ZVMYp8mKP/qZ5/d", "pbkdf2");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./sha1"), require("./hmac")) : "function" === typeof define && define.amd ? define([ "./core", "./sha1", "./hmac" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA1 = C_algo.SHA1;
        var HMAC = C_algo.HMAC;
        var PBKDF2 = C_algo.PBKDF2 = Base.extend({
          cfg: Base.extend({
            keySize: 4,
            hasher: SHA1,
            iterations: 1
          }),
          init: function init(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          compute: function compute(password, salt) {
            var cfg = this.cfg;
            var hmac = HMAC.create(cfg.hasher, password);
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([ 1 ]);
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              var block = hmac.update(salt).finalize(blockIndex);
              hmac.reset();
              var blockWords = block.words;
              var blockWordsLength = blockWords.length;
              var intermediate = block;
              for (var i = 1; i < iterations; i++) {
                intermediate = hmac.finalize(intermediate);
                hmac.reset();
                var intermediateWords = intermediate.words;
                for (var j = 0; j < blockWordsLength; j++) blockWords[j] ^= intermediateWords[j];
              }
              derivedKey.concat(block);
              blockIndexWords[0]++;
            }
            derivedKey.sigBytes = 4 * keySize;
            return derivedKey;
          }
        });
        C.PBKDF2 = function(password, salt, cfg) {
          return PBKDF2.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS.PBKDF2;
    });
    cc._RF.pop();
  }, {
    "./core": "core",
    "./hmac": "hmac",
    "./sha1": "sha1"
  } ],
  "rabbit-legacy": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "7f5d4yG/HVE064jXqmYoa/+", "rabbit-legacy");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core")) : "function" === typeof define && define.amd ? define([ "./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S = [];
        var C_ = [];
        var G = [];
        var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
          _doReset: function _doReset() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            var X = this._X = [ K[0], K[3] << 16 | K[2] >>> 16, K[1], K[0] << 16 | K[3] >>> 16, K[2], K[1] << 16 | K[0] >>> 16, K[3], K[2] << 16 | K[1] >>> 16 ];
            var C = this._C = [ K[2] << 16 | K[2] >>> 16, 4294901760 & K[0] | 65535 & K[1], K[3] << 16 | K[3] >>> 16, 4294901760 & K[1] | 65535 & K[2], K[0] << 16 | K[0] >>> 16, 4294901760 & K[2] | 65535 & K[3], K[1] << 16 | K[1] >>> 16, 4294901760 & K[3] | 65535 & K[0] ];
            this._b = 0;
            for (var i = 0; i < 4; i++) nextState.call(this);
            for (var i = 0; i < 8; i++) C[i] ^= X[i + 4 & 7];
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = 16711935 & (IV_0 << 8 | IV_0 >>> 24) | 4278255360 & (IV_0 << 24 | IV_0 >>> 8);
              var i2 = 16711935 & (IV_1 << 8 | IV_1 >>> 24) | 4278255360 & (IV_1 << 24 | IV_1 >>> 8);
              var i1 = i0 >>> 16 | 4294901760 & i2;
              var i3 = i2 << 16 | 65535 & i0;
              C[0] ^= i0;
              C[1] ^= i1;
              C[2] ^= i2;
              C[3] ^= i3;
              C[4] ^= i0;
              C[5] ^= i1;
              C[6] ^= i2;
              C[7] ^= i3;
              for (var i = 0; i < 4; i++) nextState.call(this);
            }
          },
          _doProcessBlock: function _doProcessBlock(M, offset) {
            var X = this._X;
            nextState.call(this);
            S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i = 0; i < 4; i++) {
              S[i] = 16711935 & (S[i] << 8 | S[i] >>> 24) | 4278255360 & (S[i] << 24 | S[i] >>> 8);
              M[offset + i] ^= S[i];
            }
          },
          blockSize: 4,
          ivSize: 2
        });
        function nextState() {
          var X = this._X;
          var C = this._C;
          for (var i = 0; i < 8; i++) C_[i] = C[i];
          C[0] = C[0] + 1295307597 + this._b | 0;
          C[1] = C[1] + 3545052371 + (C[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C[2] = C[2] + 886263092 + (C[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C[3] = C[3] + 1295307597 + (C[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C[4] = C[4] + 3545052371 + (C[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C[5] = C[5] + 886263092 + (C[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C[6] = C[6] + 1295307597 + (C[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C[7] = C[7] + 3545052371 + (C[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i = 0; i < 8; i++) {
            var gx = X[i] + C[i];
            var ga = 65535 & gx;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((4294901760 & gx) * gx | 0) + ((65535 & gx) * gx | 0);
            G[i] = gh ^ gl;
          }
          X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
      })();
      return CryptoJS.RabbitLegacy;
    });
    cc._RF.pop();
  }, {
    "./cipher-core": "cipher-core",
    "./core": "core",
    "./enc-base64": "enc-base64",
    "./evpkdf": "evpkdf",
    "./md5": "md5"
  } ],
  rabbit: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "a75c6fYMilCjZOgsMB7EGSz", "rabbit");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core")) : "function" === typeof define && define.amd ? define([ "./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S = [];
        var C_ = [];
        var G = [];
        var Rabbit = C_algo.Rabbit = StreamCipher.extend({
          _doReset: function _doReset() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            for (var i = 0; i < 4; i++) K[i] = 16711935 & (K[i] << 8 | K[i] >>> 24) | 4278255360 & (K[i] << 24 | K[i] >>> 8);
            var X = this._X = [ K[0], K[3] << 16 | K[2] >>> 16, K[1], K[0] << 16 | K[3] >>> 16, K[2], K[1] << 16 | K[0] >>> 16, K[3], K[2] << 16 | K[1] >>> 16 ];
            var C = this._C = [ K[2] << 16 | K[2] >>> 16, 4294901760 & K[0] | 65535 & K[1], K[3] << 16 | K[3] >>> 16, 4294901760 & K[1] | 65535 & K[2], K[0] << 16 | K[0] >>> 16, 4294901760 & K[2] | 65535 & K[3], K[1] << 16 | K[1] >>> 16, 4294901760 & K[3] | 65535 & K[0] ];
            this._b = 0;
            for (var i = 0; i < 4; i++) nextState.call(this);
            for (var i = 0; i < 8; i++) C[i] ^= X[i + 4 & 7];
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = 16711935 & (IV_0 << 8 | IV_0 >>> 24) | 4278255360 & (IV_0 << 24 | IV_0 >>> 8);
              var i2 = 16711935 & (IV_1 << 8 | IV_1 >>> 24) | 4278255360 & (IV_1 << 24 | IV_1 >>> 8);
              var i1 = i0 >>> 16 | 4294901760 & i2;
              var i3 = i2 << 16 | 65535 & i0;
              C[0] ^= i0;
              C[1] ^= i1;
              C[2] ^= i2;
              C[3] ^= i3;
              C[4] ^= i0;
              C[5] ^= i1;
              C[6] ^= i2;
              C[7] ^= i3;
              for (var i = 0; i < 4; i++) nextState.call(this);
            }
          },
          _doProcessBlock: function _doProcessBlock(M, offset) {
            var X = this._X;
            nextState.call(this);
            S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i = 0; i < 4; i++) {
              S[i] = 16711935 & (S[i] << 8 | S[i] >>> 24) | 4278255360 & (S[i] << 24 | S[i] >>> 8);
              M[offset + i] ^= S[i];
            }
          },
          blockSize: 4,
          ivSize: 2
        });
        function nextState() {
          var X = this._X;
          var C = this._C;
          for (var i = 0; i < 8; i++) C_[i] = C[i];
          C[0] = C[0] + 1295307597 + this._b | 0;
          C[1] = C[1] + 3545052371 + (C[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C[2] = C[2] + 886263092 + (C[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C[3] = C[3] + 1295307597 + (C[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C[4] = C[4] + 3545052371 + (C[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C[5] = C[5] + 886263092 + (C[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C[6] = C[6] + 1295307597 + (C[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C[7] = C[7] + 3545052371 + (C[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i = 0; i < 8; i++) {
            var gx = X[i] + C[i];
            var ga = 65535 & gx;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((4294901760 & gx) * gx | 0) + ((65535 & gx) * gx | 0);
            G[i] = gh ^ gl;
          }
          X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        C.Rabbit = StreamCipher._createHelper(Rabbit);
      })();
      return CryptoJS.Rabbit;
    });
    cc._RF.pop();
  }, {
    "./cipher-core": "cipher-core",
    "./core": "core",
    "./enc-base64": "enc-base64",
    "./evpkdf": "evpkdf",
    "./md5": "md5"
  } ],
  rc4: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "33ca9APwudHa5IQ4Pu9Xrh/", "rc4");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core")) : "function" === typeof define && define.amd ? define([ "./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var RC4 = C_algo.RC4 = StreamCipher.extend({
          _doReset: function _doReset() {
            var key = this._key;
            var keyWords = key.words;
            var keySigBytes = key.sigBytes;
            var S = this._S = [];
            for (var i = 0; i < 256; i++) S[i] = i;
            for (var i = 0, j = 0; i < 256; i++) {
              var keyByteIndex = i % keySigBytes;
              var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
              j = (j + S[i] + keyByte) % 256;
              var t = S[i];
              S[i] = S[j];
              S[j] = t;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function _doProcessBlock(M, offset) {
            M[offset] ^= generateKeystreamWord.call(this);
          },
          keySize: 8,
          ivSize: 0
        });
        function generateKeystreamWord() {
          var S = this._S;
          var i = this._i;
          var j = this._j;
          var keystreamWord = 0;
          for (var n = 0; n < 4; n++) {
            i = (i + 1) % 256;
            j = (j + S[i]) % 256;
            var t = S[i];
            S[i] = S[j];
            S[j] = t;
            keystreamWord |= S[(S[i] + S[j]) % 256] << 24 - 8 * n;
          }
          this._i = i;
          this._j = j;
          return keystreamWord;
        }
        C.RC4 = StreamCipher._createHelper(RC4);
        var RC4Drop = C_algo.RC4Drop = RC4.extend({
          cfg: RC4.cfg.extend({
            drop: 192
          }),
          _doReset: function _doReset() {
            RC4._doReset.call(this);
            for (var i = this.cfg.drop; i > 0; i--) generateKeystreamWord.call(this);
          }
        });
        C.RC4Drop = StreamCipher._createHelper(RC4Drop);
      })();
      return CryptoJS.RC4;
    });
    cc._RF.pop();
  }, {
    "./cipher-core": "cipher-core",
    "./core": "core",
    "./enc-base64": "enc-base64",
    "./evpkdf": "evpkdf",
    "./md5": "md5"
  } ],
  ripemd160: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "224f1IxtpdGwrx6yoh0OGs7", "ripemd160");
    "use strict";
    (function(root, factory) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core")) : "function" === typeof define && define.amd ? define([ "./core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      (function(Math) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var _zl = WordArray.create([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13 ]);
        var _zr = WordArray.create([ 5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11 ]);
        var _sl = WordArray.create([ 11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6 ]);
        var _sr = WordArray.create([ 8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11 ]);
        var _hl = WordArray.create([ 0, 1518500249, 1859775393, 2400959708, 2840853838 ]);
        var _hr = WordArray.create([ 1352829926, 1548603684, 1836072691, 2053994217, 0 ]);
        var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
          _doReset: function _doReset() {
            this._hash = WordArray.create([ 1732584193, 4023233417, 2562383102, 271733878, 3285377520 ]);
          },
          _doProcessBlock: function _doProcessBlock(M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = 16711935 & (M_offset_i << 8 | M_offset_i >>> 24) | 4278255360 & (M_offset_i << 24 | M_offset_i >>> 8);
            }
            var H = this._hash.words;
            var hl = _hl.words;
            var hr = _hr.words;
            var zl = _zl.words;
            var zr = _zr.words;
            var sl = _sl.words;
            var sr = _sr.words;
            var al, bl, cl, dl, el;
            var ar, br, cr, dr, er;
            ar = al = H[0];
            br = bl = H[1];
            cr = cl = H[2];
            dr = dl = H[3];
            er = el = H[4];
            var t;
            for (var i = 0; i < 80; i += 1) {
              t = al + M[offset + zl[i]] | 0;
              t += i < 16 ? f1(bl, cl, dl) + hl[0] : i < 32 ? f2(bl, cl, dl) + hl[1] : i < 48 ? f3(bl, cl, dl) + hl[2] : i < 64 ? f4(bl, cl, dl) + hl[3] : f5(bl, cl, dl) + hl[4];
              t |= 0;
              t = rotl(t, sl[i]);
              t = t + el | 0;
              al = el;
              el = dl;
              dl = rotl(cl, 10);
              cl = bl;
              bl = t;
              t = ar + M[offset + zr[i]] | 0;
              t += i < 16 ? f5(br, cr, dr) + hr[0] : i < 32 ? f4(br, cr, dr) + hr[1] : i < 48 ? f3(br, cr, dr) + hr[2] : i < 64 ? f2(br, cr, dr) + hr[3] : f1(br, cr, dr) + hr[4];
              t |= 0;
              t = rotl(t, sr[i]);
              t = t + er | 0;
              ar = er;
              er = dr;
              dr = rotl(cr, 10);
              cr = br;
              br = t;
            }
            t = H[1] + cl + dr | 0;
            H[1] = H[2] + dl + er | 0;
            H[2] = H[3] + el + ar | 0;
            H[3] = H[4] + al + br | 0;
            H[4] = H[0] + bl + cr | 0;
            H[0] = t;
          },
          _doFinalize: function _doFinalize() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = 8 * this._nDataBytes;
            var nBitsLeft = 8 * data.sigBytes;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[14 + (nBitsLeft + 64 >>> 9 << 4)] = 16711935 & (nBitsTotal << 8 | nBitsTotal >>> 24) | 4278255360 & (nBitsTotal << 24 | nBitsTotal >>> 8);
            data.sigBytes = 4 * (dataWords.length + 1);
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i = 0; i < 5; i++) {
              var H_i = H[i];
              H[i] = 16711935 & (H_i << 8 | H_i >>> 24) | 4278255360 & (H_i << 24 | H_i >>> 8);
            }
            return hash;
          },
          clone: function clone() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function f1(x, y, z) {
          return x ^ y ^ z;
        }
        function f2(x, y, z) {
          return x & y | ~x & z;
        }
        function f3(x, y, z) {
          return (x | ~y) ^ z;
        }
        function f4(x, y, z) {
          return x & z | y & ~z;
        }
        function f5(x, y, z) {
          return x ^ (y | ~z);
        }
        function rotl(x, n) {
          return x << n | x >>> 32 - n;
        }
        C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
        C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
      })(Math);
      return CryptoJS.RIPEMD160;
    });
    cc._RF.pop();
  }, {
    "./core": "core"
  } ],
  sha1: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "3316c/rSntB3J4Zk2D0aLfZ", "sha1");
    "use strict";
    (function(root, factory) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core")) : "function" === typeof define && define.amd ? define([ "./core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var W = [];
        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function _doReset() {
            this._hash = new WordArray.init([ 1732584193, 4023233417, 2562383102, 271733878, 3285377520 ]);
          },
          _doProcessBlock: function _doProcessBlock(M, offset) {
            var H = this._hash.words;
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];
            for (var i = 0; i < 80; i++) {
              if (i < 16) W[i] = 0 | M[offset + i]; else {
                var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                W[i] = n << 1 | n >>> 31;
              }
              var t = (a << 5 | a >>> 27) + e + W[i];
              t += i < 20 ? 1518500249 + (b & c | ~b & d) : i < 40 ? 1859775393 + (b ^ c ^ d) : i < 60 ? (b & c | b & d | c & d) - 1894007588 : (b ^ c ^ d) - 899497514;
              e = d;
              d = c;
              c = b << 30 | b >>> 2;
              b = a;
              a = t;
            }
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
            H[4] = H[4] + e | 0;
          },
          _doFinalize: function _doFinalize() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = 8 * this._nDataBytes;
            var nBitsLeft = 8 * data.sigBytes;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[14 + (nBitsLeft + 64 >>> 9 << 4)] = Math.floor(nBitsTotal / 4294967296);
            dataWords[15 + (nBitsLeft + 64 >>> 9 << 4)] = nBitsTotal;
            data.sigBytes = 4 * dataWords.length;
            this._process();
            return this._hash;
          },
          clone: function clone() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA1 = Hasher._createHelper(SHA1);
        C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();
      return CryptoJS.SHA1;
    });
    cc._RF.pop();
  }, {
    "./core": "core"
  } ],
  sha224: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "d1bb9vHgNNLt6Mu6copDIIV", "sha224");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./sha256")) : "function" === typeof define && define.amd ? define([ "./core", "./sha256" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA256 = C_algo.SHA256;
        var SHA224 = C_algo.SHA224 = SHA256.extend({
          _doReset: function _doReset() {
            this._hash = new WordArray.init([ 3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428 ]);
          },
          _doFinalize: function _doFinalize() {
            var hash = SHA256._doFinalize.call(this);
            hash.sigBytes -= 4;
            return hash;
          }
        });
        C.SHA224 = SHA256._createHelper(SHA224);
        C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
      })();
      return CryptoJS.SHA224;
    });
    cc._RF.pop();
  }, {
    "./core": "core",
    "./sha256": "sha256"
  } ],
  sha256: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "db35b/q7BlHAo4qUMq4YzZ0", "sha256");
    "use strict";
    (function(root, factory) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core")) : "function" === typeof define && define.amd ? define([ "./core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      (function(Math) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var H = [];
        var K = [];
        (function() {
          function isPrime(n) {
            var sqrtN = Math.sqrt(n);
            for (var factor = 2; factor <= sqrtN; factor++) if (!(n % factor)) return false;
            return true;
          }
          function getFractionalBits(n) {
            return 4294967296 * (n - (0 | n)) | 0;
          }
          var n = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n)) {
              nPrime < 8 && (H[nPrime] = getFractionalBits(Math.pow(n, .5)));
              K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));
              nPrime++;
            }
            n++;
          }
        })();
        var W = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function _doReset() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function _doProcessBlock(M, offset) {
            var H = this._hash.words;
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];
            var f = H[5];
            var g = H[6];
            var h = H[7];
            for (var i = 0; i < 64; i++) {
              if (i < 16) W[i] = 0 | M[offset + i]; else {
                var gamma0x = W[i - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
              }
              var ch = e & f ^ ~e & g;
              var maj = a & b ^ a & c ^ b & c;
              var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
              var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
              var t1 = h + sigma1 + ch + K[i] + W[i];
              var t2 = sigma0 + maj;
              h = g;
              g = f;
              f = e;
              e = d + t1 | 0;
              d = c;
              c = b;
              b = a;
              a = t1 + t2 | 0;
            }
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
            H[4] = H[4] + e | 0;
            H[5] = H[5] + f | 0;
            H[6] = H[6] + g | 0;
            H[7] = H[7] + h | 0;
          },
          _doFinalize: function _doFinalize() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = 8 * this._nDataBytes;
            var nBitsLeft = 8 * data.sigBytes;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[14 + (nBitsLeft + 64 >>> 9 << 4)] = Math.floor(nBitsTotal / 4294967296);
            dataWords[15 + (nBitsLeft + 64 >>> 9 << 4)] = nBitsTotal;
            data.sigBytes = 4 * dataWords.length;
            this._process();
            return this._hash;
          },
          clone: function clone() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA256 = Hasher._createHelper(SHA256);
        C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS.SHA256;
    });
    cc._RF.pop();
  }, {
    "./core": "core"
  } ],
  sha384: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "473895C7YVK94qOedpELTUU", "sha384");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./x64-core"), require("./sha512")) : "function" === typeof define && define.amd ? define([ "./core", "./x64-core", "./sha512" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        var SHA512 = C_algo.SHA512;
        var SHA384 = C_algo.SHA384 = SHA512.extend({
          _doReset: function _doReset() {
            this._hash = new X64WordArray.init([ new X64Word.init(3418070365, 3238371032), new X64Word.init(1654270250, 914150663), new X64Word.init(2438529370, 812702999), new X64Word.init(355462360, 4144912697), new X64Word.init(1731405415, 4290775857), new X64Word.init(2394180231, 1750603025), new X64Word.init(3675008525, 1694076839), new X64Word.init(1203062813, 3204075428) ]);
          },
          _doFinalize: function _doFinalize() {
            var hash = SHA512._doFinalize.call(this);
            hash.sigBytes -= 16;
            return hash;
          }
        });
        C.SHA384 = SHA512._createHelper(SHA384);
        C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
      })();
      return CryptoJS.SHA384;
    });
    cc._RF.pop();
  }, {
    "./core": "core",
    "./sha512": "sha512",
    "./x64-core": "x64-core"
  } ],
  sha3: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "9489f413WpObLwrPrwWLD04", "sha3");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./x64-core")) : "function" === typeof define && define.amd ? define([ "./core", "./x64-core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      (function(Math) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var C_algo = C.algo;
        var RHO_OFFSETS = [];
        var PI_INDEXES = [];
        var ROUND_CONSTANTS = [];
        (function() {
          var x = 1, y = 0;
          for (var t = 0; t < 24; t++) {
            RHO_OFFSETS[x + 5 * y] = (t + 1) * (t + 2) / 2 % 64;
            var newX = y % 5;
            var newY = (2 * x + 3 * y) % 5;
            x = newX;
            y = newY;
          }
          for (var x = 0; x < 5; x++) for (var y = 0; y < 5; y++) PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;
          var LFSR = 1;
          for (var i = 0; i < 24; i++) {
            var roundConstantMsw = 0;
            var roundConstantLsw = 0;
            for (var j = 0; j < 7; j++) {
              if (1 & LFSR) {
                var bitPosition = (1 << j) - 1;
                bitPosition < 32 ? roundConstantLsw ^= 1 << bitPosition : roundConstantMsw ^= 1 << bitPosition - 32;
              }
              128 & LFSR ? LFSR = LFSR << 1 ^ 113 : LFSR <<= 1;
            }
            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
          }
        })();
        var T = [];
        (function() {
          for (var i = 0; i < 25; i++) T[i] = X64Word.create();
        })();
        var SHA3 = C_algo.SHA3 = Hasher.extend({
          cfg: Hasher.cfg.extend({
            outputLength: 512
          }),
          _doReset: function _doReset() {
            var state = this._state = [];
            for (var i = 0; i < 25; i++) state[i] = new X64Word.init();
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function _doProcessBlock(M, offset) {
            var state = this._state;
            var nBlockSizeLanes = this.blockSize / 2;
            for (var i = 0; i < nBlockSizeLanes; i++) {
              var M2i = M[offset + 2 * i];
              var M2i1 = M[offset + 2 * i + 1];
              M2i = 16711935 & (M2i << 8 | M2i >>> 24) | 4278255360 & (M2i << 24 | M2i >>> 8);
              M2i1 = 16711935 & (M2i1 << 8 | M2i1 >>> 24) | 4278255360 & (M2i1 << 24 | M2i1 >>> 8);
              var lane = state[i];
              lane.high ^= M2i1;
              lane.low ^= M2i;
            }
            for (var round = 0; round < 24; round++) {
              for (var x = 0; x < 5; x++) {
                var tMsw = 0, tLsw = 0;
                for (var y = 0; y < 5; y++) {
                  var lane = state[x + 5 * y];
                  tMsw ^= lane.high;
                  tLsw ^= lane.low;
                }
                var Tx = T[x];
                Tx.high = tMsw;
                Tx.low = tLsw;
              }
              for (var x = 0; x < 5; x++) {
                var Tx4 = T[(x + 4) % 5];
                var Tx1 = T[(x + 1) % 5];
                var Tx1Msw = Tx1.high;
                var Tx1Lsw = Tx1.low;
                var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                for (var y = 0; y < 5; y++) {
                  var lane = state[x + 5 * y];
                  lane.high ^= tMsw;
                  lane.low ^= tLsw;
                }
              }
              for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                var lane = state[laneIndex];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                var rhoOffset = RHO_OFFSETS[laneIndex];
                if (rhoOffset < 32) {
                  var tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                  var tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                } else {
                  var tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                  var tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                }
                var TPiLane = T[PI_INDEXES[laneIndex]];
                TPiLane.high = tMsw;
                TPiLane.low = tLsw;
              }
              var T0 = T[0];
              var state0 = state[0];
              T0.high = state0.high;
              T0.low = state0.low;
              for (var x = 0; x < 5; x++) for (var y = 0; y < 5; y++) {
                var laneIndex = x + 5 * y;
                var lane = state[laneIndex];
                var TLane = T[laneIndex];
                var Tx1Lane = T[(x + 1) % 5 + 5 * y];
                var Tx2Lane = T[(x + 2) % 5 + 5 * y];
                lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
              }
              var lane = state[0];
              var roundConstant = ROUND_CONSTANTS[round];
              lane.high ^= roundConstant.high;
              lane.low ^= roundConstant.low;
            }
          },
          _doFinalize: function _doFinalize() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = 8 * this._nDataBytes;
            var nBitsLeft = 8 * data.sigBytes;
            var blockSizeBits = 32 * this.blockSize;
            dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
            dataWords[(Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
            data.sigBytes = 4 * dataWords.length;
            this._process();
            var state = this._state;
            var outputLengthBytes = this.cfg.outputLength / 8;
            var outputLengthLanes = outputLengthBytes / 8;
            var hashWords = [];
            for (var i = 0; i < outputLengthLanes; i++) {
              var lane = state[i];
              var laneMsw = lane.high;
              var laneLsw = lane.low;
              laneMsw = 16711935 & (laneMsw << 8 | laneMsw >>> 24) | 4278255360 & (laneMsw << 24 | laneMsw >>> 8);
              laneLsw = 16711935 & (laneLsw << 8 | laneLsw >>> 24) | 4278255360 & (laneLsw << 24 | laneLsw >>> 8);
              hashWords.push(laneLsw);
              hashWords.push(laneMsw);
            }
            return new WordArray.init(hashWords, outputLengthBytes);
          },
          clone: function clone() {
            var clone = Hasher.clone.call(this);
            var state = clone._state = this._state.slice(0);
            for (var i = 0; i < 25; i++) state[i] = state[i].clone();
            return clone;
          }
        });
        C.SHA3 = Hasher._createHelper(SHA3);
        C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
      })(Math);
      return CryptoJS.SHA3;
    });
    cc._RF.pop();
  }, {
    "./core": "core",
    "./x64-core": "x64-core"
  } ],
  sha512: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "ee724DmyZ1AfrdxrDAQ2NQ4", "sha512");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./x64-core")) : "function" === typeof define && define.amd ? define([ "./core", "./x64-core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        function X64Word_create() {
          return X64Word.create.apply(X64Word, arguments);
        }
        var K = [ X64Word_create(1116352408, 3609767458), X64Word_create(1899447441, 602891725), X64Word_create(3049323471, 3964484399), X64Word_create(3921009573, 2173295548), X64Word_create(961987163, 4081628472), X64Word_create(1508970993, 3053834265), X64Word_create(2453635748, 2937671579), X64Word_create(2870763221, 3664609560), X64Word_create(3624381080, 2734883394), X64Word_create(310598401, 1164996542), X64Word_create(607225278, 1323610764), X64Word_create(1426881987, 3590304994), X64Word_create(1925078388, 4068182383), X64Word_create(2162078206, 991336113), X64Word_create(2614888103, 633803317), X64Word_create(3248222580, 3479774868), X64Word_create(3835390401, 2666613458), X64Word_create(4022224774, 944711139), X64Word_create(264347078, 2341262773), X64Word_create(604807628, 2007800933), X64Word_create(770255983, 1495990901), X64Word_create(1249150122, 1856431235), X64Word_create(1555081692, 3175218132), X64Word_create(1996064986, 2198950837), X64Word_create(2554220882, 3999719339), X64Word_create(2821834349, 766784016), X64Word_create(2952996808, 2566594879), X64Word_create(3210313671, 3203337956), X64Word_create(3336571891, 1034457026), X64Word_create(3584528711, 2466948901), X64Word_create(113926993, 3758326383), X64Word_create(338241895, 168717936), X64Word_create(666307205, 1188179964), X64Word_create(773529912, 1546045734), X64Word_create(1294757372, 1522805485), X64Word_create(1396182291, 2643833823), X64Word_create(1695183700, 2343527390), X64Word_create(1986661051, 1014477480), X64Word_create(2177026350, 1206759142), X64Word_create(2456956037, 344077627), X64Word_create(2730485921, 1290863460), X64Word_create(2820302411, 3158454273), X64Word_create(3259730800, 3505952657), X64Word_create(3345764771, 106217008), X64Word_create(3516065817, 3606008344), X64Word_create(3600352804, 1432725776), X64Word_create(4094571909, 1467031594), X64Word_create(275423344, 851169720), X64Word_create(430227734, 3100823752), X64Word_create(506948616, 1363258195), X64Word_create(659060556, 3750685593), X64Word_create(883997877, 3785050280), X64Word_create(958139571, 3318307427), X64Word_create(1322822218, 3812723403), X64Word_create(1537002063, 2003034995), X64Word_create(1747873779, 3602036899), X64Word_create(1955562222, 1575990012), X64Word_create(2024104815, 1125592928), X64Word_create(2227730452, 2716904306), X64Word_create(2361852424, 442776044), X64Word_create(2428436474, 593698344), X64Word_create(2756734187, 3733110249), X64Word_create(3204031479, 2999351573), X64Word_create(3329325298, 3815920427), X64Word_create(3391569614, 3928383900), X64Word_create(3515267271, 566280711), X64Word_create(3940187606, 3454069534), X64Word_create(4118630271, 4000239992), X64Word_create(116418474, 1914138554), X64Word_create(174292421, 2731055270), X64Word_create(289380356, 3203993006), X64Word_create(460393269, 320620315), X64Word_create(685471733, 587496836), X64Word_create(852142971, 1086792851), X64Word_create(1017036298, 365543100), X64Word_create(1126000580, 2618297676), X64Word_create(1288033470, 3409855158), X64Word_create(1501505948, 4234509866), X64Word_create(1607167915, 987167468), X64Word_create(1816402316, 1246189591) ];
        var W = [];
        (function() {
          for (var i = 0; i < 80; i++) W[i] = X64Word_create();
        })();
        var SHA512 = C_algo.SHA512 = Hasher.extend({
          _doReset: function _doReset() {
            this._hash = new X64WordArray.init([ new X64Word.init(1779033703, 4089235720), new X64Word.init(3144134277, 2227873595), new X64Word.init(1013904242, 4271175723), new X64Word.init(2773480762, 1595750129), new X64Word.init(1359893119, 2917565137), new X64Word.init(2600822924, 725511199), new X64Word.init(528734635, 4215389547), new X64Word.init(1541459225, 327033209) ]);
          },
          _doProcessBlock: function _doProcessBlock(M, offset) {
            var H = this._hash.words;
            var H0 = H[0];
            var H1 = H[1];
            var H2 = H[2];
            var H3 = H[3];
            var H4 = H[4];
            var H5 = H[5];
            var H6 = H[6];
            var H7 = H[7];
            var H0h = H0.high;
            var H0l = H0.low;
            var H1h = H1.high;
            var H1l = H1.low;
            var H2h = H2.high;
            var H2l = H2.low;
            var H3h = H3.high;
            var H3l = H3.low;
            var H4h = H4.high;
            var H4l = H4.low;
            var H5h = H5.high;
            var H5l = H5.low;
            var H6h = H6.high;
            var H6l = H6.low;
            var H7h = H7.high;
            var H7l = H7.low;
            var ah = H0h;
            var al = H0l;
            var bh = H1h;
            var bl = H1l;
            var ch = H2h;
            var cl = H2l;
            var dh = H3h;
            var dl = H3l;
            var eh = H4h;
            var el = H4l;
            var fh = H5h;
            var fl = H5l;
            var gh = H6h;
            var gl = H6l;
            var hh = H7h;
            var hl = H7l;
            for (var i = 0; i < 80; i++) {
              var Wi = W[i];
              if (i < 16) {
                var Wih = Wi.high = 0 | M[offset + 2 * i];
                var Wil = Wi.low = 0 | M[offset + 2 * i + 1];
              } else {
                var gamma0x = W[i - 15];
                var gamma0xh = gamma0x.high;
                var gamma0xl = gamma0x.low;
                var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                var gamma1x = W[i - 2];
                var gamma1xh = gamma1x.high;
                var gamma1xl = gamma1x.low;
                var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                var Wi7 = W[i - 7];
                var Wi7h = Wi7.high;
                var Wi7l = Wi7.low;
                var Wi16 = W[i - 16];
                var Wi16h = Wi16.high;
                var Wi16l = Wi16.low;
                var Wil = gamma0l + Wi7l;
                var Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                var Wil = Wil + gamma1l;
                var Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                var Wil = Wil + Wi16l;
                var Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                Wi.high = Wih;
                Wi.low = Wil;
              }
              var chh = eh & fh ^ ~eh & gh;
              var chl = el & fl ^ ~el & gl;
              var majh = ah & bh ^ ah & ch ^ bh & ch;
              var majl = al & bl ^ al & cl ^ bl & cl;
              var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
              var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
              var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
              var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
              var Ki = K[i];
              var Kih = Ki.high;
              var Kil = Ki.low;
              var t1l = hl + sigma1l;
              var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
              var t1l = t1l + chl;
              var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
              var t1l = t1l + Kil;
              var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
              var t1l = t1l + Wil;
              var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
              var t2l = sigma0l + majl;
              var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
              hh = gh;
              hl = gl;
              gh = fh;
              gl = fl;
              fh = eh;
              fl = el;
              el = dl + t1l | 0;
              eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
              dh = ch;
              dl = cl;
              ch = bh;
              cl = bl;
              bh = ah;
              bl = al;
              al = t1l + t2l | 0;
              ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
            }
            H0l = H0.low = H0l + al;
            H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
            H1l = H1.low = H1l + bl;
            H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
            H2l = H2.low = H2l + cl;
            H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
            H3l = H3.low = H3l + dl;
            H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
            H4l = H4.low = H4l + el;
            H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
            H5l = H5.low = H5l + fl;
            H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
            H6l = H6.low = H6l + gl;
            H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
            H7l = H7.low = H7l + hl;
            H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
          },
          _doFinalize: function _doFinalize() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = 8 * this._nDataBytes;
            var nBitsLeft = 8 * data.sigBytes;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[30 + (nBitsLeft + 128 >>> 10 << 5)] = Math.floor(nBitsTotal / 4294967296);
            dataWords[31 + (nBitsLeft + 128 >>> 10 << 5)] = nBitsTotal;
            data.sigBytes = 4 * dataWords.length;
            this._process();
            var hash = this._hash.toX32();
            return hash;
          },
          clone: function clone() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          },
          blockSize: 32
        });
        C.SHA512 = Hasher._createHelper(SHA512);
        C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
      })();
      return CryptoJS.SHA512;
    });
    cc._RF.pop();
  }, {
    "./core": "core",
    "./x64-core": "x64-core"
  } ],
  tripledes: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "93678n1SJ5Jl4FVhmvCRT/E", "tripledes");
    "use strict";
    (function(root, factory, undef) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core"), require("./enc-base64"), require("./md5"), require("./evpkdf"), require("./cipher-core")) : "function" === typeof define && define.amd ? define([ "./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      (function() {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var PC1 = [ 57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4 ];
        var PC2 = [ 14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32 ];
        var BIT_SHIFTS = [ 1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28 ];
        var SBOX_P = [ {
          0: 8421888,
          268435456: 32768,
          536870912: 8421378,
          805306368: 2,
          1073741824: 512,
          1342177280: 8421890,
          1610612736: 8389122,
          1879048192: 8388608,
          2147483648: 514,
          2415919104: 8389120,
          2684354560: 33280,
          2952790016: 8421376,
          3221225472: 32770,
          3489660928: 8388610,
          3758096384: 0,
          4026531840: 33282,
          134217728: 0,
          402653184: 8421890,
          671088640: 33282,
          939524096: 32768,
          1207959552: 8421888,
          1476395008: 512,
          1744830464: 8421378,
          2013265920: 2,
          2281701376: 8389120,
          2550136832: 33280,
          2818572288: 8421376,
          3087007744: 8389122,
          3355443200: 8388610,
          3623878656: 32770,
          3892314112: 514,
          4160749568: 8388608,
          1: 32768,
          268435457: 2,
          536870913: 8421888,
          805306369: 8388608,
          1073741825: 8421378,
          1342177281: 33280,
          1610612737: 512,
          1879048193: 8389122,
          2147483649: 8421890,
          2415919105: 8421376,
          2684354561: 8388610,
          2952790017: 33282,
          3221225473: 514,
          3489660929: 8389120,
          3758096385: 32770,
          4026531841: 0,
          134217729: 8421890,
          402653185: 8421376,
          671088641: 8388608,
          939524097: 512,
          1207959553: 32768,
          1476395009: 8388610,
          1744830465: 2,
          2013265921: 33282,
          2281701377: 32770,
          2550136833: 8389122,
          2818572289: 514,
          3087007745: 8421888,
          3355443201: 8389120,
          3623878657: 0,
          3892314113: 33280,
          4160749569: 8421378
        }, {
          0: 1074282512,
          16777216: 16384,
          33554432: 524288,
          50331648: 1074266128,
          67108864: 1073741840,
          83886080: 1074282496,
          100663296: 1073758208,
          117440512: 16,
          134217728: 540672,
          150994944: 1073758224,
          167772160: 1073741824,
          184549376: 540688,
          201326592: 524304,
          218103808: 0,
          234881024: 16400,
          251658240: 1074266112,
          8388608: 1073758208,
          25165824: 540688,
          41943040: 16,
          58720256: 1073758224,
          75497472: 1074282512,
          92274688: 1073741824,
          109051904: 524288,
          125829120: 1074266128,
          142606336: 524304,
          159383552: 0,
          176160768: 16384,
          192937984: 1074266112,
          209715200: 1073741840,
          226492416: 540672,
          243269632: 1074282496,
          260046848: 16400,
          268435456: 0,
          285212672: 1074266128,
          301989888: 1073758224,
          318767104: 1074282496,
          335544320: 1074266112,
          352321536: 16,
          369098752: 540688,
          385875968: 16384,
          402653184: 16400,
          419430400: 524288,
          436207616: 524304,
          452984832: 1073741840,
          469762048: 540672,
          486539264: 1073758208,
          503316480: 1073741824,
          520093696: 1074282512,
          276824064: 540688,
          293601280: 524288,
          310378496: 1074266112,
          327155712: 16384,
          343932928: 1073758208,
          360710144: 1074282512,
          377487360: 16,
          394264576: 1073741824,
          411041792: 1074282496,
          427819008: 1073741840,
          444596224: 1073758224,
          461373440: 524304,
          478150656: 0,
          494927872: 16400,
          511705088: 1074266128,
          528482304: 540672
        }, {
          0: 260,
          1048576: 0,
          2097152: 67109120,
          3145728: 65796,
          4194304: 65540,
          5242880: 67108868,
          6291456: 67174660,
          7340032: 67174400,
          8388608: 67108864,
          9437184: 67174656,
          10485760: 65792,
          11534336: 67174404,
          12582912: 67109124,
          13631488: 65536,
          14680064: 4,
          15728640: 256,
          524288: 67174656,
          1572864: 67174404,
          2621440: 0,
          3670016: 67109120,
          4718592: 67108868,
          5767168: 65536,
          6815744: 65540,
          7864320: 260,
          8912896: 4,
          9961472: 256,
          11010048: 67174400,
          12058624: 65796,
          13107200: 65792,
          14155776: 67109124,
          15204352: 67174660,
          16252928: 67108864,
          16777216: 67174656,
          17825792: 65540,
          18874368: 65536,
          19922944: 67109120,
          20971520: 256,
          22020096: 67174660,
          23068672: 67108868,
          24117248: 0,
          25165824: 67109124,
          26214400: 67108864,
          27262976: 4,
          28311552: 65792,
          29360128: 67174400,
          30408704: 260,
          31457280: 65796,
          32505856: 67174404,
          17301504: 67108864,
          18350080: 260,
          19398656: 67174656,
          20447232: 0,
          21495808: 65540,
          22544384: 67109120,
          23592960: 256,
          24641536: 67174404,
          25690112: 65536,
          26738688: 67174660,
          27787264: 65796,
          28835840: 67108868,
          29884416: 67109124,
          30932992: 67174400,
          31981568: 4,
          33030144: 65792
        }, {
          0: 2151682048,
          65536: 2147487808,
          131072: 4198464,
          196608: 2151677952,
          262144: 0,
          327680: 4198400,
          393216: 2147483712,
          458752: 4194368,
          524288: 2147483648,
          589824: 4194304,
          655360: 64,
          720896: 2147487744,
          786432: 2151678016,
          851968: 4160,
          917504: 4096,
          983040: 2151682112,
          32768: 2147487808,
          98304: 64,
          163840: 2151678016,
          229376: 2147487744,
          294912: 4198400,
          360448: 2151682112,
          425984: 0,
          491520: 2151677952,
          557056: 4096,
          622592: 2151682048,
          688128: 4194304,
          753664: 4160,
          819200: 2147483648,
          884736: 4194368,
          950272: 4198464,
          1015808: 2147483712,
          1048576: 4194368,
          1114112: 4198400,
          1179648: 2147483712,
          1245184: 0,
          1310720: 4160,
          1376256: 2151678016,
          1441792: 2151682048,
          1507328: 2147487808,
          1572864: 2151682112,
          1638400: 2147483648,
          1703936: 2151677952,
          1769472: 4198464,
          1835008: 2147487744,
          1900544: 4194304,
          1966080: 64,
          2031616: 4096,
          1081344: 2151677952,
          1146880: 2151682112,
          1212416: 0,
          1277952: 4198400,
          1343488: 4194368,
          1409024: 2147483648,
          1474560: 2147487808,
          1540096: 64,
          1605632: 2147483712,
          1671168: 4096,
          1736704: 2147487744,
          1802240: 2151678016,
          1867776: 4160,
          1933312: 2151682048,
          1998848: 4194304,
          2064384: 4198464
        }, {
          0: 128,
          4096: 17039360,
          8192: 262144,
          12288: 536870912,
          16384: 537133184,
          20480: 16777344,
          24576: 553648256,
          28672: 262272,
          32768: 16777216,
          36864: 537133056,
          40960: 536871040,
          45056: 553910400,
          49152: 553910272,
          53248: 0,
          57344: 17039488,
          61440: 553648128,
          2048: 17039488,
          6144: 553648256,
          10240: 128,
          14336: 17039360,
          18432: 262144,
          22528: 537133184,
          26624: 553910272,
          30720: 536870912,
          34816: 537133056,
          38912: 0,
          43008: 553910400,
          47104: 16777344,
          51200: 536871040,
          55296: 553648128,
          59392: 16777216,
          63488: 262272,
          65536: 262144,
          69632: 128,
          73728: 536870912,
          77824: 553648256,
          81920: 16777344,
          86016: 553910272,
          90112: 537133184,
          94208: 16777216,
          98304: 553910400,
          102400: 553648128,
          106496: 17039360,
          110592: 537133056,
          114688: 262272,
          118784: 536871040,
          122880: 0,
          126976: 17039488,
          67584: 553648256,
          71680: 16777216,
          75776: 17039360,
          79872: 537133184,
          83968: 536870912,
          88064: 17039488,
          92160: 128,
          96256: 553910272,
          100352: 262272,
          104448: 553910400,
          108544: 0,
          112640: 553648128,
          116736: 16777344,
          120832: 262144,
          124928: 537133056,
          129024: 536871040
        }, {
          0: 268435464,
          256: 8192,
          512: 270532608,
          768: 270540808,
          1024: 268443648,
          1280: 2097152,
          1536: 2097160,
          1792: 268435456,
          2048: 0,
          2304: 268443656,
          2560: 2105344,
          2816: 8,
          3072: 270532616,
          3328: 2105352,
          3584: 8200,
          3840: 270540800,
          128: 270532608,
          384: 270540808,
          640: 8,
          896: 2097152,
          1152: 2105352,
          1408: 268435464,
          1664: 268443648,
          1920: 8200,
          2176: 2097160,
          2432: 8192,
          2688: 268443656,
          2944: 270532616,
          3200: 0,
          3456: 270540800,
          3712: 2105344,
          3968: 268435456,
          4096: 268443648,
          4352: 270532616,
          4608: 270540808,
          4864: 8200,
          5120: 2097152,
          5376: 268435456,
          5632: 268435464,
          5888: 2105344,
          6144: 2105352,
          6400: 0,
          6656: 8,
          6912: 270532608,
          7168: 8192,
          7424: 268443656,
          7680: 270540800,
          7936: 2097160,
          4224: 8,
          4480: 2105344,
          4736: 2097152,
          4992: 268435464,
          5248: 268443648,
          5504: 8200,
          5760: 270540808,
          6016: 270532608,
          6272: 270540800,
          6528: 270532616,
          6784: 8192,
          7040: 2105352,
          7296: 2097160,
          7552: 0,
          7808: 268435456,
          8064: 268443656
        }, {
          0: 1048576,
          16: 33555457,
          32: 1024,
          48: 1049601,
          64: 34604033,
          80: 0,
          96: 1,
          112: 34603009,
          128: 33555456,
          144: 1048577,
          160: 33554433,
          176: 34604032,
          192: 34603008,
          208: 1025,
          224: 1049600,
          240: 33554432,
          8: 34603009,
          24: 0,
          40: 33555457,
          56: 34604032,
          72: 1048576,
          88: 33554433,
          104: 33554432,
          120: 1025,
          136: 1049601,
          152: 33555456,
          168: 34603008,
          184: 1048577,
          200: 1024,
          216: 34604033,
          232: 1,
          248: 1049600,
          256: 33554432,
          272: 1048576,
          288: 33555457,
          304: 34603009,
          320: 1048577,
          336: 33555456,
          352: 34604032,
          368: 1049601,
          384: 1025,
          400: 34604033,
          416: 1049600,
          432: 1,
          448: 0,
          464: 34603008,
          480: 33554433,
          496: 1024,
          264: 1049600,
          280: 33555457,
          296: 34603009,
          312: 1,
          328: 33554432,
          344: 1048576,
          360: 1025,
          376: 34604032,
          392: 33554433,
          408: 34603008,
          424: 0,
          440: 34604033,
          456: 1049601,
          472: 1024,
          488: 33555456,
          504: 1048577
        }, {
          0: 134219808,
          1: 131072,
          2: 134217728,
          3: 32,
          4: 131104,
          5: 134350880,
          6: 134350848,
          7: 2048,
          8: 134348800,
          9: 134219776,
          10: 133120,
          11: 134348832,
          12: 2080,
          13: 0,
          14: 134217760,
          15: 133152,
          2147483648: 2048,
          2147483649: 134350880,
          2147483650: 134219808,
          2147483651: 134217728,
          2147483652: 134348800,
          2147483653: 133120,
          2147483654: 133152,
          2147483655: 32,
          2147483656: 134217760,
          2147483657: 2080,
          2147483658: 131104,
          2147483659: 134350848,
          2147483660: 0,
          2147483661: 134348832,
          2147483662: 134219776,
          2147483663: 131072,
          16: 133152,
          17: 134350848,
          18: 32,
          19: 2048,
          20: 134219776,
          21: 134217760,
          22: 134348832,
          23: 131072,
          24: 0,
          25: 131104,
          26: 134348800,
          27: 134219808,
          28: 134350880,
          29: 133120,
          30: 2080,
          31: 134217728,
          2147483664: 131072,
          2147483665: 2048,
          2147483666: 134348832,
          2147483667: 133152,
          2147483668: 32,
          2147483669: 134348800,
          2147483670: 134217728,
          2147483671: 134219808,
          2147483672: 134350880,
          2147483673: 134217760,
          2147483674: 134219776,
          2147483675: 0,
          2147483676: 133120,
          2147483677: 2080,
          2147483678: 131104,
          2147483679: 134350848
        } ];
        var SBOX_MASK = [ 4160749569, 528482304, 33030144, 2064384, 129024, 8064, 504, 2147483679 ];
        var DES = C_algo.DES = BlockCipher.extend({
          _doReset: function _doReset() {
            var key = this._key;
            var keyWords = key.words;
            var keyBits = [];
            for (var i = 0; i < 56; i++) {
              var keyBitPos = PC1[i] - 1;
              keyBits[i] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
            }
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
              var subKey = subKeys[nSubKey] = [];
              var bitShift = BIT_SHIFTS[nSubKey];
              for (var i = 0; i < 24; i++) {
                subKey[i / 6 | 0] |= keyBits[(PC2[i] - 1 + bitShift) % 28] << 31 - i % 6;
                subKey[4 + (i / 6 | 0)] |= keyBits[28 + (PC2[i + 24] - 1 + bitShift) % 28] << 31 - i % 6;
              }
              subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
              for (var i = 1; i < 7; i++) subKey[i] = subKey[i] >>> 4 * (i - 1) + 3;
              subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
            }
            var invSubKeys = this._invSubKeys = [];
            for (var i = 0; i < 16; i++) invSubKeys[i] = subKeys[15 - i];
          },
          encryptBlock: function encryptBlock(M, offset) {
            this._doCryptBlock(M, offset, this._subKeys);
          },
          decryptBlock: function decryptBlock(M, offset) {
            this._doCryptBlock(M, offset, this._invSubKeys);
          },
          _doCryptBlock: function _doCryptBlock(M, offset, subKeys) {
            this._lBlock = M[offset];
            this._rBlock = M[offset + 1];
            exchangeLR.call(this, 4, 252645135);
            exchangeLR.call(this, 16, 65535);
            exchangeRL.call(this, 2, 858993459);
            exchangeRL.call(this, 8, 16711935);
            exchangeLR.call(this, 1, 1431655765);
            for (var round = 0; round < 16; round++) {
              var subKey = subKeys[round];
              var lBlock = this._lBlock;
              var rBlock = this._rBlock;
              var f = 0;
              for (var i = 0; i < 8; i++) f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
              this._lBlock = rBlock;
              this._rBlock = lBlock ^ f;
            }
            var t = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t;
            exchangeLR.call(this, 1, 1431655765);
            exchangeRL.call(this, 8, 16711935);
            exchangeRL.call(this, 2, 858993459);
            exchangeLR.call(this, 16, 65535);
            exchangeLR.call(this, 4, 252645135);
            M[offset] = this._lBlock;
            M[offset + 1] = this._rBlock;
          },
          keySize: 2,
          ivSize: 2,
          blockSize: 2
        });
        function exchangeLR(offset, mask) {
          var t = (this._lBlock >>> offset ^ this._rBlock) & mask;
          this._rBlock ^= t;
          this._lBlock ^= t << offset;
        }
        function exchangeRL(offset, mask) {
          var t = (this._rBlock >>> offset ^ this._lBlock) & mask;
          this._lBlock ^= t;
          this._rBlock ^= t << offset;
        }
        C.DES = BlockCipher._createHelper(DES);
        var TripleDES = C_algo.TripleDES = BlockCipher.extend({
          _doReset: function _doReset() {
            var key = this._key;
            var keyWords = key.words;
            this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));
            this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));
            this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));
          },
          encryptBlock: function encryptBlock(M, offset) {
            this._des1.encryptBlock(M, offset);
            this._des2.decryptBlock(M, offset);
            this._des3.encryptBlock(M, offset);
          },
          decryptBlock: function decryptBlock(M, offset) {
            this._des3.decryptBlock(M, offset);
            this._des2.encryptBlock(M, offset);
            this._des1.decryptBlock(M, offset);
          },
          keySize: 6,
          ivSize: 2,
          blockSize: 2
        });
        C.TripleDES = BlockCipher._createHelper(TripleDES);
      })();
      return CryptoJS.TripleDES;
    });
    cc._RF.pop();
  }, {
    "./cipher-core": "cipher-core",
    "./core": "core",
    "./enc-base64": "enc-base64",
    "./evpkdf": "evpkdf",
    "./md5": "md5"
  } ],
  utils: [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "1bc9aVAZH1Atrd5s8qUIVLr", "utils");
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.timeFormat = exports.dateToStr = exports.ArrayRemove = exports.clearStorage = exports.getStorage = exports.setStorage = exports.loadRemoteImg = exports.getPosByDesign = exports.getSpriteSiteAuto = exports.setSafeArea = exports.someTimeOnce = exports.getOddsByNum = exports.getUrlParams = void 0;
    function getUrlParams(url) {
      var obj = {};
      var Params = url.split("?")[1] || url;
      Params.split("&").forEach(function(t) {
        var arr = t.split("=");
        obj[arr[0]] = arr[1];
      });
      return obj;
    }
    exports.getUrlParams = getUrlParams;
    function getOddsByNum(odds) {
      var random = Math.random();
      return random < odds;
    }
    exports.getOddsByNum = getOddsByNum;
    function someTimeOnce(name, time) {
      void 0 === time && (time = 1);
      var onceObj = JSON.parse(cc.sys.localStorage.getItem("onceObj") || "{}");
      var nowDate = new Date().getDate();
      if (onceObj[name] && nowDate - onceObj[name] < time) return false;
      onceObj[name] = nowDate;
      cc.sys.localStorage.setItem("onceObj", JSON.stringify(onceObj));
      return true;
    }
    exports.someTimeOnce = someTimeOnce;
    function setSafeArea(node, offset, minTop) {
      void 0 === minTop && (minTop = 0);
      var safeTop = cc.view.getVisibleSize().height - cc.sys.getSafeAreaRect().height;
      safeTop += offset;
      safeTop < minTop && (safeTop = minTop);
      var widget = node.getComponent(cc.Widget);
      widget.top = safeTop;
      widget.updateAlignment();
      return safeTop;
    }
    exports.setSafeArea = setSafeArea;
    function getSpriteSiteAuto(atlasImage, type, value) {
      var size = atlasImage.getOriginalSize();
      if ("w" === type) {
        var height = value / size.width * size.height;
        return cc.size(value, height);
      }
      if ("h" === type) {
        var width = value / size.height * size.width;
        return cc.size(width, value);
      }
    }
    exports.getSpriteSiteAuto = getSpriteSiteAuto;
    function getPosByDesign(pos) {
      var _pos = cc.v2(pos);
      var designHeight = 1624;
      var dis = (designHeight - cc.winSize.height) / 2;
      _pos.y > 0 ? _pos.y -= dis : _pos.y += dis;
      return _pos;
    }
    exports.getPosByDesign = getPosByDesign;
    function loadRemoteImg(url) {
      return new Promise(function(resolve, reject) {
        cc.assetManager.loadRemote(url, {
          ext: ".png"
        }, function(err, asset) {
          if (err) {
            cc.error(url + " [\u56fe\u7247\u8d44\u6e90\u52a0\u8f7d] \u9519\u8bef " + err);
            resolve(null);
          } else resolve(new cc.SpriteFrame(asset));
        });
      });
    }
    exports.loadRemoteImg = loadRemoteImg;
    function setStorage(key, value) {
      if ("" === value) {
        cc.error(key + " [\u5b58\u50a8value:" + value + "] \u9519\u8bef");
        return;
      }
      var jsonVal = "string" === typeof value ? value : JSON.stringify(value);
      cc.sys.localStorage.setItem(key, jsonVal);
    }
    exports.setStorage = setStorage;
    function getStorage(key, type) {
      void 0 === type && (type = "st");
      var jsonVal = cc.sys.localStorage.getItem(key);
      if ("st" === type) return jsonVal;
      if ("obj" === type && jsonVal) return JSON.parse(jsonVal);
    }
    exports.getStorage = getStorage;
    function clearStorage() {
      cc.sys.localStorage.clear();
    }
    exports.clearStorage = clearStorage;
    function ArrayRemove(arr, reItem) {
      if (!Array.isArray(arr)) return;
      var index = arr.indexOf(reItem);
      index > -1 && arr.splice(index, 1);
    }
    exports.ArrayRemove = ArrayRemove;
    function dateToStr(date) {
      void 0 === date && (date = new Date());
      var seperator1 = "-";
      var seperator2 = ":";
      var month = date.getMonth() + 1;
      var strDate = date.getDate();
      month >= 1 && month <= 9 && (month = "0" + month);
      strDate >= 0 && strDate <= 9 && (strDate = "0" + strDate);
      var currentdate = date.getFullYear() + seperator1 + month + seperator1 + strDate + " " + date.getHours() + seperator2 + date.getMinutes() + seperator2 + date.getSeconds();
      return currentdate;
    }
    exports.dateToStr = dateToStr;
    function timeFormat(time) {
      var oldDate = new Date(time);
      var newDate = new Date();
      var dayNum = "";
      var getTime = (newDate.getTime() - oldDate.getTime()) / 1e3;
      getTime < 300 ? dayNum = "\u521a\u521a" : getTime >= 300 && getTime < 3600 ? dayNum = parseInt((getTime / 60).toString()) + "\u5206\u949f\u524d" : getTime >= 3600 && getTime < 86400 ? dayNum = parseInt((getTime / 3600).toString()) + "\u5c0f\u65f6\u524d" : getTime >= 86400 && getTime < 2592e3 ? dayNum = parseInt((getTime / 3600 / 24).toString()) + "\u5929\u524d" : getTime >= 2592e3 && getTime < 31104e3 ? dayNum = parseInt((getTime / 3600 / 24 / 30).toString()) + "\u4e2a\u6708\u524d" : time >= 31104e3 && (dayNum = parseInt((getTime / 3600 / 24 / 30 / 12).toString()) + "\u5e74\u524d");
      return dayNum;
    }
    exports.timeFormat = timeFormat;
    cc._RF.pop();
  }, {} ],
  "x64-core": [ function(require, module, exports) {
    "use strict";
    cc._RF.push(module, "00569OfXKBJDZjjsRUEdXWW", "x64-core");
    "use strict";
    (function(root, factory) {
      "object" === typeof exports ? module.exports = exports = factory(require("./core")) : "function" === typeof define && define.amd ? define([ "./core" ], factory) : factory(root.CryptoJS);
    })(void 0, function(CryptoJS) {
      (function(undefined) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var X32WordArray = C_lib.WordArray;
        var C_x64 = C.x64 = {};
        var X64Word = C_x64.Word = Base.extend({
          init: function init(high, low) {
            this.high = high;
            this.low = low;
          }
        });
        var X64WordArray = C_x64.WordArray = Base.extend({
          init: function init(words, sigBytes) {
            words = this.words = words || [];
            this.sigBytes = sigBytes != undefined ? sigBytes : 8 * words.length;
          },
          toX32: function toX32() {
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;
            var x32Words = [];
            for (var i = 0; i < x64WordsLength; i++) {
              var x64Word = x64Words[i];
              x32Words.push(x64Word.high);
              x32Words.push(x64Word.low);
            }
            return X32WordArray.create(x32Words, this.sigBytes);
          },
          clone: function clone() {
            var clone = Base.clone.call(this);
            var words = clone.words = this.words.slice(0);
            var wordsLength = words.length;
            for (var i = 0; i < wordsLength; i++) words[i] = words[i].clone();
            return clone;
          }
        });
      })();
      return CryptoJS;
    });
    cc._RF.pop();
  }, {
    "./core": "core"
  } ]
}, {}, [ "UIBackpackInfo_Auto", "UIBackpack_Auto", "UIBuild_Auto", "UIHome_Auto", "UILoading_Auto", "UIRecipeInfo_Auto", "UIRecipe_Auto", "UITop_Auto", "UIVarietyInfo_Auto", "UIVariety_Auto", "UIWorkDesk_Auto", "BaseAssembler", "BatchAssembler", "MeshAssembler", "TextureAssembler", "BroadcastCenter", "BatchComponent", "ButtonPlus", "CacheUtils", "CameraCapture", "DrawBorad", "GPWorkFlow", "GridScrollList", "KawaseBlur", "List", "ListItem", "MaskPlus", "MeshTexture", "Printer", "PropController", "PropSelector", "QuadTree", "RecycleScroll", "ScrollViewHelper", "Shake", "SpinePlus", "TexturePlus", "TouchPlus", "ViewGroupNesting_2x", "adaptToPositionArr", "EventBox", "GPDrag", "GameConfig", "Light", "LightStruct", "LightUtils", "Obstacle", "Logger", "mobx", "StateMachine", "StorageManager", "BigNumUtils", "BroadCast", "ClassHelper", "CommonUtils", "DebugWindowUtils", "DrawingBoard", "Dungeon", "EncryptUtil", "EnumUtils", "GlobalHelper", "LRUCache", "MatchUtils", "Measure", "PolygonUtil", "Pool", "PriorityQueue", "PriorityStack", "PropBind", "Queue", "RenderUtil", "TaskMgr", "utils", "aes", "cipher-core", "core", "crypto-js", "enc-base64", "enc-hex", "enc-latin1", "enc-utf16", "enc-utf8", "evpkdf", "format-hex", "format-openssl", "hmac-md5", "hmac-ripemd160", "hmac-sha1", "hmac-sha224", "hmac-sha256", "hmac-sha3", "hmac-sha384", "hmac-sha512", "hmac", "index", "lib-typedarrays", "md5", "mode-cfb", "mode-ctr-gladman", "mode-ctr", "mode-ecb", "mode-ofb", "pad-ansix923", "pad-iso10126", "pad-iso97971", "pad-nopadding", "pad-pkcs7", "pad-zeropadding", "pbkdf2", "rabbit-legacy", "rabbit", "rc4", "ripemd160", "sha1", "sha224", "sha256", "sha3", "sha384", "sha512", "tripledes", "x64-core", "GlobalData", "InitGameData", "MessageInfo", "RawMaterial", "ResConfig", "TableKey", "MessageType", "AutoFindPath", "Joystick", "Coffee", "BackpackContent", "BackpackItem", "BackpackTypeItem", "BuildGrid", "BuildItem", "BuildTypeItem", "MenuItem", "RawItem", "RecipeCoffeeItem", "RecipeItem", "RecipeModuleItem", "RoleMgr", "TableMgr", "Player", "CoinFlyToWallet", "BaseRole", "BaseTable", "Game", "BaseMgr", "ConfigMgr", "DataMgr", "PlayerMgr", "Main", "Scene", "UIConfig", "AdapterMgr", "CocosHelper", "DrawerMgr", "EventCenter", "EventType", "FixedMgr", "FormMgr", "ModalMgr", "ModalMgr1", "ResMgr", "SceneMgr", "SoundMgr", "Struct", "TipsMgr", "ToastMgr", "UIBase", "UIForm", "UIManager", "UIModalScript", "WindowMgr", "SysConfig", "SysDefine", "UIBackpack", "UIBackpackInfo", "UIBuild", "UIHome", "UILoading", "UIRecipe", "UIRecipeInfo", "UITop", "UIVariety", "UIVarietyInfo", "UIWorkDesk", "UIToast1" ]);